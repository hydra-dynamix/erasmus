#!/usr/bin/env python3
"""
Python script packager that bundles multiple .py files into a single-file executable.
Uses AST for safe code analysis and uv for runtime virtual environment creation.
"""

import ast
import os
import sys
import tokenize
import subprocess
from pathlib import Path
from typing import Set, List, Dict, Optional, Generator, Tuple

class ScriptPackager:
    """Handles the packaging of multiple Python files into a single executable."""
    
    def __init__(self, base_path: Path):
        self.base_path = Path(base_path)
        self.import_set: Set[str] = set()
        self.script_bodies: List[str] = []
        self.requirements: Set[str] = set()
        
    def extract_imports(self, source_code: str) -> Set[str]:
        """Extract all imports from source code using AST."""
        tree = ast.parse(source_code)
        imports = set()
        
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name.split('.')[0])
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.add(node.module.split('.')[0])
        return imports
    
    def strip_imports(self, source_code: str) -> str:
        """Remove import statements while preserving the rest of the code."""
        tree = ast.parse(source_code)
        lines = source_code.splitlines()
        kept_lines = []
        
        for node in tree.body:
            if not isinstance(node, (ast.Import, ast.ImportFrom)):
                start = node.lineno - 1
                end = getattr(node, 'end_lineno', start)
                kept_lines.extend(lines[start:end + 1])
        return '\n'.join(kept_lines)
    
    def collect_python_files(self) -> Generator[Path, None, None]:
        """Collect all Python files in the project directory."""
        for item in self.base_path.rglob('*.py'):
            if item.is_file() and not item.name.startswith('__'):
                yield item
    
    def process_file(self, file_path: Path) -> None:
        """Process a single Python file, extracting imports and code."""
        try:
            with tokenize.open(file_path) as f:
                code = f.read()
                self.import_set.update(self.extract_imports(code))
                self.script_bodies.append(f"\n# Source: {file_path.relative_to(self.base_path)}")
                self.script_bodies.append(self.strip_imports(code))
        except Exception as e:
            print(f"Error processing {file_path}: {e}", file=sys.stderr)
    
    def generate_uv_bootstrap(self) -> str:
        """Generate the uv bootstrap code."""
        requirements_str = repr(sorted(list(self.requirements)))
        return f'''
def bootstrap_uv():
    """Set up uv virtual environment and install requirements."""
    import subprocess
    import sys
    from pathlib import Path
    
    def write_requirements():
        """Write requirements.txt from embedded requirements."""
        reqs = {requirements_str}
        if not reqs:
            return
        with open("requirements.txt", "w") as f:
            for req in sorted(reqs):
                f.write(f"{{req}}\\n")
    
    try:
        write_requirements()
        subprocess.run(
            [sys.executable, "-m", "uv", "pip", "install", "-r", "requirements.txt"],
            check=True
        )
    except subprocess.CalledProcessError as e:
        print(f"Error setting up environment: {{e}}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error during setup: {{e}}", file=sys.stderr)
        sys.exit(1)
'''
    
    def package_scripts(self, output_path: Optional[Path] = None) -> str:
        """Package all scripts into a single file."""
        # Process all Python files
        for file_path in self.collect_python_files():
            self.process_file(file_path)
        
        # Build the final script
        lines = [
            "#!/usr/bin/env python3",
            '"""',
            "Generated single-file executable.",
            "This file was automatically generated by the Python script packager.",
            '"""',
            "",
            "import os",
            "import sys",
            "from pathlib import Path",
            "",
        ]
        
        # Add imports
        lines.extend(f"import {imp}" for imp in sorted(self.import_set))
        lines.append("")
        
        # Add uv bootstrap
        lines.append(self.generate_uv_bootstrap())
        lines.append("")
        
        # Add script bodies
        lines.extend(self.script_bodies)
        
        # Add main execution
        lines.extend([
            "",
            'if __name__ == "__main__":',
            "    bootstrap_uv()",
            "    sys.exit(main())"
        ])
        
        final_script = '\n'.join(lines)
        
        # Write to file if output path is provided
        if output_path:
            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(final_script)
            os.chmod(output_path, 0o755)  # Make executable
            
        return final_script

def main():
    """CLI entry point for the packager."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Package Python scripts into a single executable")
    parser.add_argument("source_dir", help="Source directory containing Python files")
    parser.add_argument("--output", "-o", help="Output file path", default="dist/packaged_script.py")
    
    args = parser.parse_args()
    
    packager = ScriptPackager(args.source_dir)
    output_path = Path(args.output)
    
    try:
        packager.package_scripts(output_path)
        print(f"Successfully packaged scripts to: {output_path}")
        return 0
    except Exception as e:
        print(f"Error packaging scripts: {e}", file=sys.stderr)
        return 1

if __name__ == '__main__':
    sys.exit(main()) 