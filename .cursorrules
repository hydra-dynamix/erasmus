<?xml version="1.0" encoding="UTF-8"?>
<MetaRules>
  <?xml version="1.0" encoding="UTF-8"?>
<Architecture>
  <Title>Erasmus Packager</Title>
  <Overview>
    <Description>
      The Erasmus Packager is a standalone Python tool for packaging, dependency analysis, and management. It analyzes Python projects, extracts and categorizes imports, maps them to PyPI packages, and produces a single executable script with a platform-aware bootstrap for dependency installation and execution. The tool is designed for automation, reproducibility, and cross-platform compatibility, providing a robust CLI for all operations.
    </Description>
  </Overview>
  <CoreComponents>
    <Component name="Packager">
      <Purpose>Automates packaging, dependency tracking, and script generation for Python projects.</Purpose>
      <Responsibilities>
        <Responsibility>Recursively collect Python files from a directory, respecting exclusion patterns.</Responsibility>
        <Responsibility>Parse and extract all import dependencies from Python files.</Responsibility>
        <Responsibility>Distinguish between standard library, third-party, and local imports.</Responsibility>
        <Responsibility>Map import names to PyPI package names, handling aliases and special cases.</Responsibility>
        <Responsibility>Build a single script by merging code and imports, normalizing indentation and structure.</Responsibility>
        <Responsibility>Generate platform-aware bootstrap scripts for dependency installation and execution using uv.</Responsibility>
        <Responsibility>Provide a Typer-based CLI for packaging, file listing, and version display.</Responsibility>
      </Responsibilities>
      <TestFocus>
        <Test>Correct extraction and categorization of imports from various Python files.</Test>
        <Test>Accurate mapping of imports to PyPI packages, including custom and default mappings.</Test>
        <Test>Proper exclusion of files and directories during collection.</Test>
        <Test>Successful packaging of multi-file projects into a single script.</Test>
        <Test>Generation of valid and executable bootstrap scripts for all supported platforms.</Test>
        <Test>CLI commands function as expected and handle errors gracefully.</Test>
      </TestFocus>
    </Component>
  </CoreComponents>
  
  <DevelopmentPrinciples>
    <Principle name="Packager Principles">
      <Detail>Favor automation and reproducibility in packaging and dependency management.</Detail>
      <Detail>Ensure cross-platform compatibility for all generated scripts and bootstraps.</Detail>
      <Detail>Minimize manual intervention by providing robust CLI tools.</Detail>
      <Detail>Maintain clear separation between standard library, third-party, and local dependencies.</Detail>
      <Detail>Use type hints, docstrings, and logging for maintainability and traceability.</Detail>
    </Principle>
  </DevelopmentPrinciples>
  
  <Dependencies>
    <Dependency>typer</Dependency>
    <Dependency>rich</Dependency>
    <Dependency>ast-comments</Dependency>
    <Dependency>packaging</Dependency>
    <Dependency>tomli</Dependency>
    <Dependency>tomli-w</Dependency>
    <Dependency>uv (runtime, for bootstrapping and dependency management)</Dependency>
  </Dependencies>
  
  <DirectoryStructure>
    <Directory name="packager">
      <File>__init__.py</File>
      <File>__main__.py</File>
      <File>builder.py</File>
      <File>collector.py</File>
      <File>mapping.py</File>
      <File>parser.py</File>
      <File>stdlib.py</File>
      <File>uv_wrapper.py</File>
      <File>README.md</File>
      <File>pyproject.toml</File>
    </Directory>
  </DirectoryStructure>
  
  <DevelopmentWorkflow>
    <Step>Collect Python files from the target directory or file using collector.py.</Step>
    <Step>Parse each file to extract and categorize imports using parser.py and stdlib.py.</Step>
    <Step>Map all imports to their corresponding PyPI package names using mapping.py.</Step>
    <Step>Build a single script by merging code and imports, normalizing indentation and structure using builder.py.</Step>
    <Step>Generate a platform-aware bootstrap script for dependency installation and execution using uv_wrapper.py.</Step>
    <Step>Expose all functionality via a Typer-based CLI in __main__.py, supporting packaging, file listing, and version display.</Step>
    <Step>Test all components for correctness, error handling, and cross-platform compatibility.</Step>
  </DevelopmentWorkflow>
</Architecture>

  <?xml version="1.0" encoding="UTF-8"?>
<Progress>
  <Phase name="Phase Name">
    <Status>Status (e.g., Completed, In Progress, Planned)</Status>
    <Tasks>
      <Task name="Task Name">
        <Status>Status</Status>
        <Subtasks>
          <Subtask name="Subtask Name">
            <Status>Status</Status>
          </Subtask>
          <!-- Add more subtasks as needed -->
        </Subtasks>
      </Task>
      <!-- Add more tasks as needed -->
    </Tasks>
  </Phase>
  <!-- Add more phases as needed -->
  
  <CurrentFocus>
    <Phase>Current phase name</Phase>
    <Priority>Current priority</Priority>
    <NextTask>Next task to work on</NextTask>
  </CurrentFocus>
  
  <Notes>
    <Note>Note 1</Note>
    <Note>Note 2</Note>
    <!-- Add more notes as needed -->
  </Notes>
</Progress> 
  <?xml version="1.0" encoding="UTF-8"?>
<Tasks>
  <CurrentTasks>
    <Task name="Task Name">
      <Description>Task description</Description>
      <Subtasks>
        <Subtask name="Subtask Name">
          <Status>Status (e.g., Pending, In Progress, Completed)</Status>
          <Subtasks>
            <Subtask name="Nested Subtask Name">
              <Status>Status</Status>
            </Subtask>
            <!-- Add more nested subtasks as needed -->
          </Subtasks>
        </Subtask>
        <!-- Add more subtasks as needed -->
      </Subtasks>
      <Tests>
        <Test name="Test Name">
          <Code>
            <![CDATA[
            def test_function():
                # Test code goes here
            ]]>
          </Code>
        </Test>
        <!-- Add more tests as needed -->
      </Tests>
    </Task>
    <!-- Add more current tasks as needed -->
  </CurrentTasks>
  
  <NextSteps>
    <Step>Next step 1</Step>
    <Step>Next step 2</Step>
    <!-- Add more next steps as needed -->
  </NextSteps>
</Tasks> 
  <?xml version="1.0" encoding="UTF-8"?>
<AgentProtocol>
  <Metadata>
    <Id>00000012</Id>
    <Role>debugging_and_issue_diagnosis</Role>
    <Triggers>test_failures, runtime_errors, bug_reports, performance_issues</Triggers>
    <Produces>debug_reports, fix_recommendations, regression_tests</Produces>
    <Consumes>implementation_code, test_results, .ctx.progress.xml, .ctx.tasks.xml</Consumes>
  </Metadata>
  <Objective>
    Identify, diagnose, and resolve issues in the codebase, including test failures, runtime errors, logical bugs, and performance bottlenecks. Document all errors, diagnostic steps, and solutions in <File>.ctx.progress.xml</File> and <File>.ctx.tasks.xml</File>. Ensure fixes are validated and do not introduce regressions.
  </Objective>
  <Workflow>
    <Step>Monitor <File>.ctx.progress.xml</File> and <File>.ctx.tasks.xml</File> for new or ongoing errors, bugs, or test failures.</Step>
    <Step>For each issue:
      <Substep>Reproduce the issue and document reproduction steps in <File>.ctx.tasks.xml</File>.</Substep>
      <Substep>Isolate the root cause and record all diagnostic steps in <File>.ctx.tasks.xml</File>.</Substep>
      <Substep>Formulate hypotheses and test potential fixes, tracking each attempt in <File>.ctx.tasks.xml</File>.</Substep>
      <Substep>When a fix is found, update <File>.ctx.progress.xml</File> to mark the issue as resolved and summarize the solution.</Substep>
      <Substep>Document lessons learned, new tests, or regression checks added to prevent recurrence.</Substep>
    </Step>
    <Step>For recurring or systemic issues, update <File>.ctx.progress.xml</File> with patterns, root causes, and recommendations for future prevention.</Step>
    <Step>Communicate blockers, unresolved issues, or required escalations in <File>.ctx.progress.xml</File> for team visibility and follow-up.</Step>
  </Workflow>
  <Principles>
    <Principle>Trace issues to their root cause, not just symptoms.</Principle>
    <Principle>Document all diagnostic steps, attempted solutions, and outcomes in .ctx.tasks.xml.</Principle>
    <Principle>Update .ctx.progress.xml with error status, resolution notes, and recommendations.</Principle>
    <Principle>Ensure fixes do not introduce regressions; add or update tests as needed.</Principle>
    <Principle>Communicate blockers or unresolved issues promptly for team awareness.</Principle>
    <Principle>Promote knowledge sharing by documenting lessons learned and patterns observed.</Principle>
  </Principles>
  <Tracking>
    <Uses>.ctx.progress.xml</Uses>
    <Uses>.ctx.tasks.xml</Uses>
    <Uses>test_results</Uses>
    <Uses>regression_tests</Uses>
    <Description>All errors, diagnostic steps, attempted solutions, and recommendations are tracked in these files. Progress is updated as issues are resolved or require escalation.</Description>
  </Tracking>
</AgentProtocol> 
</MetaRules> 