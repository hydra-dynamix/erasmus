{
  "architecture": "#  Project-Python Script Packager with Cross-Platform `uv` Bootstrap\n\n##  Overview\n\nThis tool is a **Python script bundler** that packages a project into a **single, standalone executable script**. It recursively gathers `.py` files, merges them into one file, collects all `import` statements, and **bootstraps runtime dependencies using [uv](https://github.com/astral-sh/uv)**.\n\nThe final output is a **platform-aware, cross-compatible script** that:\n- Works on **Linux, macOS, and Windows**\n- **Installs `uv` automatically** if missing\n- Infers and installs required packages using `uv add`\n- Runs itself using `uv run`\n- Requires **no virtual environments, no `requirements.txt`, and no pip**\n\n---\n\n##  Goals\n\n-  Convert a Python project into a single executable script\n-  Automatically infer external dependencies from imports\n-  Use `uv` to install and run dependencies in a temporary env\n-  Support both Unix (bash) and Windows (batch) execution\n-  Guarantee zero setup beyond Python and basic tools (`curl`, `winget`)\n\n---\n\n##  Features\n\n| Feature                            | Description |\n|------------------------------------|-------------|\n|  Static import parsing            | Detects and de-duplicates imports using `ast` |\n|  Dependency inference             | Resolves which packages are required from imports |\n|  Standard lib filtering           | Excludes stdlib modules from `uv add` |\n|  No extra files                   | No `venv`, no `requirements.txt`, no pip needed |\n|  Clean CLI                        | Use `python -m packager` to bundle |\n|  Cross-platform bootstrapping     | Works with Bash (Linux/macOS) and Batch (Windows) |\n|  Single script output             | One file with shell header, dependency install, and Python code |\n\n---\n\n##  Architecture\n\n```\npackager/\n __main__.py         # CLI interface\n collector.py        # Recursively finds Python files\n parser.py           # Parses imports using AST\n builder.py          # Merges stripped code bodies and imports\n uv_wrapper.py       # Adds OS-aware shell and batch bootstrap\n mapping.py          # Optional import-to-PyPI mapping\n stdlib.py           # Contains stdlib detection for filtering\n```\n\n---\n\n##  Detailed Component Design\n\n### `collector.py`\n```python\ndef collect_py_files(base_path: str) -> List[str]:\n    # Recursively yield all .py files\n```\n\n---\n\n### `parser.py`\n```python\ndef extract_imports(source: str) -> Set[str]:\n    # Uses ast to extract 'import x' and 'from x import y'\n\ndef strip_imports(source: str) -> str:\n    # Removes import lines, returns only the executable code\n```\n\n---\n\n### `mapping.py` (Optional)\n```python\n# Maps import names to PyPI packages\nPYPI_MAP = {\n    \"cv2\": \"opencv-python\",\n    \"PIL\": \"pillow\",\n}\n```\n\n---\n\n### `stdlib.py`\n```python\n# Uses sys.stdlib_module_names or external stdlib-list\ndef is_stdlib_module(name: str) -> bool:\n    return name in stdlib_modules\n```\n\n---\n\n### `builder.py`\n```python\ndef build_script(files: List[str]) -> Tuple[Set[str], str]:\n    # Combines:\n    # 1. Unique import names (stripped of stdlib)\n    # 2. Combined code body with imports removed\n```\n\n---\n\n### `uv_wrapper.py`\n```python\ndef generate_script(imports: Set[str], code: str) -> str:\n    # Returns final script string with:\n    # - Shebang\n    # - OS check (bash or batch)\n    # - uv install logic (curl or winget)\n    # - uv add <packages>\n    # - uv run path-to-script\n    # - Embedded Python code\n```\n\n---\n\n### `__main__.py`\n```python\n# CLI wrapper\n# Usage: python -m packager --input src/ --output packed.sh\n```\n\n---\n\n##  Output Script Structure\n\n```bash\n#!/bin/bash\n# Cross-platform uv bootstrap\nOS=$(uname -s)\n\nif [[ \"$OS\" == \"Linux\" || \"$OS\" == \"Darwin\" ]]; then\n  if ! command -v uv >/dev/null; then\n    echo \"Installing uv...\"\n    if ! command -v curl >/dev/null; then\n      echo \"Missing 'curl'. Please install it.\"\n      exit 1\n    fi\n    curl -LsSf https://astral.sh/uv/install.sh | sh\n    export PATH=\"$HOME/.cargo/bin:$PATH\"\n  fi\n\n  uv add rich typer requests\n  uv run \"$0\" \"$@\"\n  exit $?\nfi\n\nREM Windows fallback\n@echo off\nwhere uv >nul 2>nul\nif %errorlevel% neq 0 (\n  echo Installing uv using winget...\n  winget install --id=astral-sh.uv -e\n)\n\nuv add rich typer requests\nuv run \"%~f0\" %*\nexit /b\n```\n\n_Followed by Python code:_\n\n```python\n#!/usr/bin/env python\nimport typer\nimport requests\n\ndef main():\n    print(\"Hello from bundled script!\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n##  Testing Strategy\ntest\nTest Cases:\n\n| Scenario                    | Linux | macOS | Windows |\n|----------------------------|-------|-------|---------|\n| No `uv` installed          |     |     |       |\n| No `curl`                  |     |     | N/A     |\n| No `winget`                | N/A   | N/A   |       |\n| Missing dependency         |     |     |       |\n| Nested import structure    |     |     |       |\n| Works with entrypoint code |     |     |       |\n\n---\n\n##  Requirements\n\n| Tool     | Use                |\n|----------|--------------------|\n| `ast`    | Static parsing     |\n| `uv`     | Runtime environment |\n| `curl`   | Unix installer     |\n| `winget` | Windows installer  |\n| Python 3.8+ | Runtime & toolchain |\n\n---\n\n##  Future Improvements\n\n- Package metadata injection (name/version/help)\n- GUI/UX wrapper for non-devs\n- Compression/minification support\n- Add support for `.env` or config files\n- Optional `pyproject.toml` parser for metadata\n\n---\n\n##  Summary\n\nThis Python packager is a **fully cross-platform script bundler** that requires:\n- No setup\n- No environments\n- No external files\n\nIt outputs a **single script** that:\n- Bootstraps its dependencies using `uv`\n- Installs `uv` if necessary\n- Runs itself cleanly on any modern system\n",
  "progress": "#  Development Progress\n\n##  Components Overview\n\nThis document tracks the development progress of the Python Script Packager components as defined in the architecture document.\n\n##  Development Schedule\n\n| Component | Status | Description | Priority |\n|-----------|--------|-------------|----------|\n| `stdlib.py` |  Completed | Contains stdlib detection for filtering imports | 1 |\n| `collector.py` |  Completed | Recursively finds Python files in a project | 2 |\n| `parser.py` |  Not Started | Parses imports using AST and strips import statements | 3 |\n| `mapping.py` |  Not Started | Optional import-to-PyPI mapping | 4 |\n| `builder.py` |  Not Started | Merges stripped code bodies and imports | 5 |\n| `uv_wrapper.py` |  Not Started | Adds OS-aware shell and batch bootstrap | 6 |\n| `__main__.py` |  Not Started | CLI interface for the packager | 7 |\n\n##  Current Focus\n\nCurrently focusing on implementing the core components in order of dependency:\n\n1. `stdlib.py` - Foundation for filtering standard library imports\n2. `collector.py` - File collection system\n3. `parser.py` - Import parsing and code stripping\n\n##  Completion Criteria\n\nA component is considered complete when:\n- Implementation matches the architecture specification\n- Unit tests are written and passing\n- Documentation is complete\n- Code is reviewed and approved",
  "tasks": "#  Development Tasks\n\n##  Completed Component: `stdlib.py`\n\nThe `stdlib.py` module is responsible for detecting standard library modules to filter them from the dependencies that need to be installed.\n\n### Tasks\n\n#### 1. Research Standard Library Detection Methods\n- [x] Research methods to detect Python standard library modules\n- [x] Evaluate using `sys.stdlib_module_names` (Python 3.10+)\n- [x] Evaluate using external packages like `stdlib-list`\n- [x] Determine the most reliable cross-version approach\n\n#### 2. Implement Core Detection Function\n- [x] Implement `is_stdlib_module(name: str) -> bool` function\n- [x] Handle edge cases (e.g., submodules like `os.path`)\n- [x] Ensure compatibility with different Python versions\n\n#### 3. Create Module-Level Cache\n- [x] Implement caching mechanism for standard library modules\n- [x] Ensure thread safety if necessary\n- [x] Add initialization function to populate cache on module load\n\n#### 4. Add Utility Functions\n- [x] Implement `filter_stdlib_imports(imports: set[str]) -> set[str]` to filter a set of imports\n- [x] Add helper functions for common operations\n\n#### 5. Write Tests\n- [x] Write unit tests for `is_stdlib_module`\n- [x] Test with various standard library modules\n- [x] Test with third-party modules\n- [x] Test edge cases and submodules\n\n#### 6. Documentation\n- [x] Add module-level docstring\n- [x] Document all functions with type hints\n- [x] Add usage examples\n- [x] Document limitations and edge cases\n\n##  Completed Component: `collector.py`\n\nThe `collector.py` module is responsible for recursively finding Python files in a project directory.\n\n### Tasks\n\n#### 1. Design File Collection Strategy\n- [x] Determine approach for recursive directory traversal\n- [x] Decide on handling of symlinks and special files\n- [x] Plan for exclusion patterns (e.g., `.git`, `__pycache__`, etc.)\n\n#### 2. Implement Core Collection Function\n- [x] Implement `collect_py_files(base_path: str) -> list[str]` function\n- [x] Add proper error handling for file system operations\n- [x] Ensure cross-platform compatibility (Windows/Unix paths)\n\n#### 3. Add Filtering Capabilities\n- [x] Implement exclusion patterns for directories\n- [x] Add support for custom file extensions beyond `.py`\n- [x] Create utility for filtering collected files\n\n#### 4. Optimize Performance\n- [x] Implement efficient traversal algorithm\n- [x] Add caching if necessary for large projects\n- [x] Consider parallel processing for large directories\n\n#### 5. Write Tests\n- [x] Write unit tests for file collection\n- [x] Test with various directory structures\n- [x] Test exclusion patterns\n- [x] Test edge cases (empty directories, permission issues)\n\n#### 6. Documentation\n- [x] Add module-level docstring\n- [x] Document all functions with type hints\n- [x] Add usage examples\n- [x] Document limitations and edge cases\n\n##  Current Component: `parser.py`\n\nThe `parser.py` module is responsible for parsing Python imports using AST and stripping import statements from code.\n\n### Tasks\n\n#### 1. Design Import Parsing Strategy\n- [ ] Research AST module for parsing Python code\n- [ ] Determine approach for identifying import statements\n- [ ] Plan for handling different import formats (`import x`, `from x import y`, etc.)\n\n#### 2. Implement Import Extraction\n- [ ] Implement `extract_imports(source: str) -> set[str]` function\n- [ ] Handle regular imports (`import x`)\n- [ ] Handle from imports (`from x import y`)\n- [ ] Handle relative imports (`from . import x`)\n\n#### 3. Implement Code Stripping\n- [ ] Implement `strip_imports(source: str) -> str` function\n- [ ] Preserve line numbers for debugging\n- [ ] Handle multi-line imports\n- [ ] Preserve docstrings and comments\n\n#### 4. Add Utility Functions\n- [ ] Create function to parse imports from a file\n- [ ] Add support for parsing multiple files\n- [ ] Implement import normalization\n\n#### 5. Write Tests\n- [ ] Write unit tests for import extraction\n- [ ] Test with various import formats\n- [ ] Test code stripping functionality\n- [ ] Test edge cases (comments, docstrings, etc.)\n\n#### 6. Documentation\n- [ ] Add module-level docstring\n- [ ] Document all functions with type hints\n- [ ] Add usage examples\n- [ ] Document limitations and edge cases\n\n##  Next Steps\n\nAfter completing `collector.py`, we will move on to implementing `parser.py` which will parse imports using AST and strip import statements from Python files.",
  "protocols": [
    "Debug Agent"
  ],
  "current_protocol": "Debug Agent",
  "protocol_role": "issue_diagnosis",
  "protocol_triggers": [
    "test_failures"
  ],
  "protocol_produces": [
    "debug_reports",
    "fix_recommendations"
  ],
  "protocol_consumes": [
    "implementation_code",
    "test_results"
  ]
}