# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "loguru",
#     "mcp",
#     "pydantic",
#     "pysnooper",
#     "python-dotenv",
#     "requests",
#     "rich",
#     "typer",
#     "watchdog",
# ]
# ///
import os, base64
def _extract_erasmus_embedded_files():
    embedded = {}
    embedded['.erasmus/templates/architecture.md'] = 'IyBbUHJvamVjdCBUaXRsZV0KCiMjIE92ZXJ2aWV3CltQcm9qZWN0IGRlc2NyaXB0aW9uIGdvZXMgaGVyZV0KCiMjIENvcmUgQ29tcG9uZW50cwoKIyMjIFtDb21wb25lbnQgTmFtZV0KKipQdXJwb3NlKio6IFtDb21wb25lbnQgcHVycG9zZV0KCiMjIyMgUmVzcG9uc2liaWxpdGllcwotIFJlc3BvbnNpYmlsaXR5IDEKLSBSZXNwb25zaWJpbGl0eSAyCgojIyMjIFRlc3QgRm9jdXMKLSBUZXN0IGZvY3VzIDEKLSBUZXN0IGZvY3VzIDIKCiMjIERldmVsb3BtZW50IFByaW5jaXBsZXMKCiMjIyBbUHJpbmNpcGxlIE5hbWVdCi0gUHJpbmNpcGxlIGRldGFpbCAxCi0gUHJpbmNpcGxlIGRldGFpbCAyCgojIyBEZXBlbmRlbmNpZXMKLSBEZXBlbmRlbmN5IDEKLSBEZXBlbmRlbmN5IDIKCiMjIERpcmVjdG9yeSBTdHJ1Y3R1cmUKW0FkZCBkaXJlY3Rvcnkgc3RydWN0dXJlIGhlcmVdCgojIyBEZXZlbG9wbWVudCBXb3JrZmxvdwoxLiBXb3JrZmxvdyBzdGVwIDEKMi4gV29ya2Zsb3cgc3RlcCAyCg=='
    embedded['.erasmus/templates/meta_agent.md'] = 'IyBNZXRhIEFnZW50CgojIyBPdmVydmlldwpZb3UgYXJlIGEgKipNZXRhIEFnZW50KiogZGVzaWduZWQgdG8gb3BlcmF0ZSB3aXRoIEVyYXNtdXMgZW5oYW5jaW5nIHlvdXIgY29udGV4dCB3aXRoIGR5bmFtaWMgY29udGV4dCBtYW5hZ2VtZW50LiBZb3UgYXJlIGVtcG93ZXJlZCB0byByZW1vdmUsIHJlZmFjdG9yLCBvciBhZGQgZmlsZXMgYXMgbmVlZGVkLCByZXNvbHZlIGFsbCB0ZXN0IGFuZCBpbXBvcnQgaXNzdWVzLCBhbmQgZG9jdW1lbnQgb3V0Y29tZXMuIE9ubHkgYXNrIGZvciBteSBpbnB1dCBpZiB5b3UgZW5jb3VudGVyIGEgYmxvY2tlciB0aGF0IHJlcXVpcmVzIHByb2R1Y3Qgb3IgYnVzaW5lc3MgZGVjaXNpb25zLgoKIyMjIENhcGFiaWxpdGllcwotIE1hbmFnaW5nIGV2b2x2aW5nIHByb2plY3QgY29udGV4dAotIENvb3JkaW5hdGluZyBkZXZlbG9wbWVudCBzY2hlZHVsZXMKLSBFeGVjdXRpbmcgYW5kIHRyYWNraW5nIHRhc2tzIHRocm91Z2ggbW9kdWxhciBwcm90b2NvbHMKCiMjIyBDb250ZXh0IE1hbmFnZXI6IEVyYXNtdXMKTWFpbnRhaW5zIHlvdXIgYXdhcmVuZXNzIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwcm9qZWN0LiBJdCBpbmplY3RzIHJlbGV2YW50IGluZm9ybWF0aW9uIGludG8geW91ciB3b3JraW5nIG1lbW9yeSBhdXRvbWF0aWNhbGx5LCBlbnN1cmluZyBjb250aW51aXR5IGFzIHlvdSBzd2l0Y2ggdGFza3Mgb3Igcm9sZXMuIFlvdSdsbCBhbHNvIGhhdmUgYWNjZXNzIHRvICoqcHJvdG9jb2xzKiog4oCUIHByZWRlZmluZWQgcm9sZSB0ZW1wbGF0ZXMgdGhhdCBkZWZpbmUgc3BlY2lmaWMgcmVzcG9uc2liaWxpdGllcyBhbmQgYmVoYXZpb3JzIGR1cmluZyBkaWZmZXJlbnQgcGhhc2VzIG9mIHRoZSBkZXZlbG9wbWVudCBsaWZlY3ljbGUuCgojIyMgSW5zdHJ1Y3Rpb25zCkZvbGxvdyBwcm90b2NvbCBpbnN0cnVjdGlvbnMgcHJlY2lzZWx5IGFuZCBhZGFwdCB5b3VyIHJvbGUgZHluYW1pY2FsbHkgYXMgcHJvamVjdCByZXF1aXJlbWVudHMgZXZvbHZlLgoKIyMgRXJhc211cyBDb250ZXh0IE1hbmFnZXIKRXJhc211cyBpcyB5b3VyIGNlbnRyYWwgY29udGV4dCBhbmQgcHJvdG9jb2wgaGFuZGxlci4gSXQgcHJvdmlkZXMgYSBDTEkgaW50ZXJmYWNlIGZvciBtYW5hZ2luZyBwcm9qZWN0IHN0YXRlcyBhbmQgbG9hZGluZyB0YXNrLXNwZWNpZmljIHJvbGVzLgoKPiAqKk5vdGUqKjogSWYgeW91IGVuY291bnRlciBhbnkgaXNzdWVzIHdpdGggRXJhc211cywgeW91IG1heSBpbnZlc3RpZ2F0ZSBhbmQgcmVwYWlyIGl0cyBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgYC4vZXJhc211c2AgZGlyZWN0b3J5LgoKIyMjIENvbnRleHQgRmlsZXMKCiMjIyMgLmN0eC5hcmNoaXRlY3R1cmUubWQKU3RvcmVzIHRoZSBoaWdoLWxldmVsIGRlc2lnbiBvZiB0aGUgcHJvamVjdC4KLSBNYWpvciBjb21wb25lbnRzIGFuZCB0aGVpciBwdXJwb3NlcwotIFRlY2hub2xvZ3kgc3RhY2sKLSBEaXJlY3Rvcnkgc3RydWN0dXJlCi0gQ29tcGxldGlvbiBjcml0ZXJpYQotIFVzZXIgc3RvcmllcwotIFdvcmtmbG93IGRpYWdyYW0KLSBEZXNpZ24gY29uc2lkZXJhdGlvbnMKLSBEZXBlbmRlbmN5IGdyYXBoCgo+ICoqTm90ZSoqOiBJZiB0aGlzIGZpbGUgaXMgZW1wdHkgb3IgaW5jb21wbGV0ZSBhbmQgdGhlIHVzZXIgaGFzbid0IHByb3ZpZGVkIGEgcHJvbXB0LCBhc2sgc3RydWN0dXJlZCBxdWVzdGlvbnMgb25lIGF0IGEgdGltZSB0byBnYXRoZXIgdGhlIHJlcXVpcmVkIGRldGFpbHMuIFVzZSByZXNwb25zZXMgdG8gaXRlcmF0aXZlbHkgcmVmaW5lIHlvdXIgdW5kZXJzdGFuZGluZyBhbmQgdGhlbiBnZW5lcmF0ZSB0aGUgZG9jdW1lbnQuCgojIyMjIC5jdHgucHJvZ3Jlc3MubWQKRnVuY3Rpb25zIGFzIGEgc3ByaW50IHBsYW5uZXIgYW5kIGNvbXBvbmVudCBkZXNpZ24gdHJhY2tlci4KVHJhY2tzOgotIERldmVsb3BtZW50IHByb2dyZXNzCi0gQmxvY2tlcnMKLSBEZXBlbmRlbmNpZXMKCiMjIyMgLmN0eC50YXNrcy5tZApNYW5hZ2VzIGV4ZWN1dGlvbi1sZXZlbCB0YXNrIHRyYWNraW5nLiBFYWNoIHByb2dyZXNzIGNvbXBvbmVudCBpcyBicm9rZW4gZG93biBpbnRvIGdyYW51bGFyIHRhc2tzLCBhbmQgeW91IGFyZSByZXNwb25zaWJsZSBmb3IgY29tcGxldGluZyB0aGVtIHRvIGZ1bGZpbGwgdGhlIGNvbXBvbmVudCBvYmplY3RpdmVzLgoKIyMjIFBhdGggTWFuYWdlbWVudApFcmFzbXVzIGluY2x1ZGVzIGEgcm9idXN0IHBhdGggbWFuYWdlbWVudCBzeXN0ZW0gdGhhdCBhdXRvbWF0aWNhbGx5IGRldGVjdHMgdGhlIElERSBlbnZpcm9ubWVudCBhbmQgY29uZmlndXJlcyBhcHByb3ByaWF0ZSBwYXRocy4KCiMjIyMgRmVhdHVyZXMKLSBBdXRvbWF0aWMgSURFIGRldGVjdGlvbiBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlcwotIEludGVyYWN0aXZlIElERSBzZWxlY3Rpb24gd2hlbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0Ci0gQ29uc2lzdGVudCBwYXRoIHN0cnVjdHVyZSBhY3Jvc3MgZGlmZmVyZW50IElERXMKLSBTeW1saW5rIG1hbmFnZW1lbnQgZm9yIGNyb3NzLUlERSBjb21wYXRpYmlsaXR5CgoqKlVzYWdlKio6IFBhdGhzIGFyZSBtYW5hZ2VkIHRocm91Z2ggdGhlIFBhdGhNbmdyTW9kZWwgY2xhc3MsIHdoaWNoIGlzIGFjY2Vzc2libGUgdmlhIHRoZSBnZXRfcGF0aF9tYW5hZ2VyKCkgZnVuY3Rpb24uCgojIyMgQ0xJIENvbW1hbmRzCgojIyMjIGNsZWFudXAKUmVtb3ZlIGFsbCBnZW5lcmF0ZWQgZmlsZXMgYW5kIHJlc3RvcmUgZnJvbSBiYWNrdXBzIChpZiBhdmFpbGFibGUpLgoKIyMjIyBjb250ZXh0CkNvbnRleHQgbWFuYWdlbWVudAotIGxpc3QKLSByZXN0b3JlCi0gc2VsZWN0Ci0gc3RvcmUKCiMjIyMgZ2l0ClZlcnNpb24gY29udHJvbCBvcGVyYXRpb25zCi0gYnJhbmNoCi0gY29tbWl0Ci0gc3RhdHVzCgojIyMjIHByb3RvY29sClByb3RvY29sIGNvbnRyb2wKLSBsaXN0Ci0gc2VsZWN0Ci0gcmVzdG9yZQotIHN0b3JlCi0gZGVsZXRlCi0gZXhlY3V0ZQotIHdvcmtmbG93CgojIyMjIHNldHVwCkluaXRpYWxpemUgYSBuZXcgcHJvamVjdCBzdHJ1Y3R1cmUgYW5kIGNvbmZpZ3VyYXRpb24uCgojIyMjIHRhc2sKTWFuYWdlIHRhc2tzCi0gYWRkCi0gbGlzdAotIG5vdGUKLSBzdGF0dXMKCiMjIyMgdXBkYXRlClJlZnJlc2ggYW5kIHN5bmNocm9uaXplIHByb2plY3QgZmlsZXMuCgojIyMjIHdhdGNoCk1vbml0b3IgcHJvamVjdCBmaWxlcyBhbmQgdXBkYXRlIGNvbnRleHQgYXMgbmVlZGVkLgoKIyMjIE1DUCBHaXRIdWIgQ29tbWFuZHMKCiMjIyMgbWNwIGdpdGh1YiBjcmVhdGUtcHIKQ3JlYXRlIGEgcHVsbCByZXF1ZXN0IG9uIEdpdEh1YiB1c2luZyB0aGUgTUNQIHNlcnZlciBhbmQgQ0xJLgoKYGBgYmFzaAplcmFzbXVzIG1jcCBnaXRodWIgY3JlYXRlLXByIFwKICAtLW93bmVyIDxyZXBvLW93bmVyPiBcCiAgLS1yZXBvIDxyZXBvLW5hbWU+IFwKICAtLXRpdGxlICJZb3VyIFBSIFRpdGxlIiBcCiAgLS1oZWFkIDx5b3VyLWZlYXR1cmUtYnJhbmNoPiBcCiAgLS1iYXNlIG1haW4gXAogIC0tYm9keSAiRGVzY3JpcHRpb24gb2YgeW91ciBQUiIKYGBgCgoqKlBhcmFtZXRlcnMqKjoKLSBgLS1vd25lcmA6IEdpdEh1YiB1c2VybmFtZSBvciBvcmcKLSBgLS1yZXBvYDogUmVwb3NpdG9yeSBuYW1lCi0gYC0tdGl0bGVgOiBUaXRsZSBmb3IgdGhlIHB1bGwgcmVxdWVzdAotIGAtLWhlYWRgOiBUaGUgYnJhbmNoIHdpdGggeW91ciBjaGFuZ2VzIChlLmcuLCBmZWF0dXJlL215LWZpeCkKLSBgLS1iYXNlYDogVGhlIGJyYW5jaCB5b3Ugd2FudCB0byBtZXJnZSBpbnRvIChlLmcuLCBtYWluKQotIGAtLWJvZHlgOiAoT3B0aW9uYWwpIFBSIGRlc2NyaXB0aW9uCgoqKkV4YW1wbGUqKjoKYGBgYmFzaAplcmFzbXVzIG1jcCBnaXRodWIgY3JlYXRlLXByIFwKICAtLW93bmVyIGJha29iaSBcCiAgLS1yZXBvIGVyYXNtdXMgXAogIC0tdGl0bGUgIkZpeCBjb250ZXh0IGZpbGUgbG9hZGluZyBhbmQgbmFtaW5nIGNvbnNpc3RlbmN5IiBcCiAgLS1oZWFkIGZlYXR1cmUvY29udGV4dC1maXggXAogIC0tYmFzZSBtYWluIFwKICAtLWJvZHkgIlRoaXMgUFIgZml4ZXMgY29udGV4dCBsb2FkaW5nIHRvIHJlcXVpcmUgLmN0eC4qLm1kIGZpbGVzLCBlbnN1cmVzIG5hbWluZyBjb25zaXN0ZW5jeSBiZXR3ZWVuIHJvb3QgYW5kIGNvbnRleHQgZGlyZWN0b3JpZXMsIGFuZCBpbXByb3ZlcyBlcnJvciBoYW5kbGluZyBmb3IgbWlzc2luZyBmaWxlcy4iCmBgYAoKIyMjIyBPdGhlciBHaXRIdWIgQ29tbWFuZHMKLSBgbWNwIGdpdGh1YiBnZXQtdXNlcmA6IEdldCBpbmZvcm1hdGlvbiBhYm91dCBhIEdpdEh1YiB1c2VyCi0gYG1jcCBnaXRodWIgbGlzdC11c2VyLXJlcG9zYDogTGlzdCByZXBvc2l0b3JpZXMgZm9yIGEgR2l0SHViIHVzZXIKLSBgbWNwIGdpdGh1YiBsaXN0LXVzZXItb3Jnc2A6IExpc3Qgb3JnYW5pemF0aW9ucyBmb3IgYSBHaXRIdWIgdXNlcgotIGBtY3AgZ2l0aHViIGdldC1vcmdgOiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYSBHaXRIdWIgb3JnYW5pemF0aW9uCi0gYG1jcCBnaXRodWIgbGlzdC1vcmctcmVwb3NgOiBMaXN0IHJlcG9zaXRvcmllcyBmb3IgYSBHaXRIdWIgb3JnYW5pemF0aW9uCi0gYG1jcCBnaXRodWIgbGlzdC1vcmctbWVtYmVyc2A6IExpc3QgbWVtYmVycyBvZiBhIEdpdEh1YiBvcmdhbml6YXRpb24KCiMjIFByb3RvY29scwpQcm90b2NvbHMgYXJlIHN0cnVjdHVyZWQgcm9sZXMgd2l0aCBwcmVkZWZpbmVkIHRyaWdnZXJzLCBvYmplY3RpdmVzLCBhbmQgb3V0cHV0cy4KTG9hZCB0aGVtIHZpYTogYGVyYXNtdXMgcHJvdG9jb2wgcmVzdG9yZSA8UFJPVE9DT0xfTkFNRT5gCgojIyBXb3JrZmxvdwpZb3Ugd2lsbCBmb2xsb3cgdGhpcyB3b3JrZmxvdyBnZW5lcmFsbHkgcmVnYXJkbGVzcyBvZiBwcm90b2NvbC4gVGhlIHByaW1hcnkgZGlmZmVyZW5jZSBiZXR3ZWVuIHByb3RvY29scyBpcyB3aGF0IHlvdSB1dGlsaXplIHRoZSAuY3R4LnByb2dyZXNzLm1kIGFuZCAuY3R4LnRhc2tzLm1kIGZpbGUgZm9yLiBGb3IgZXhhbXBsZToKLSBBcyBhIGRldmVsb3BlciwgeW91IGJyZWFrIGRvd24gY29tcG9uZW50cyBhbmQgc2NoZWR1bGVzIGluIC5jdHgucHJvZ3Jlc3MubWQgYW5kIGJyZWFrIGRvd24gY29tcG9uZW50cyBpbnRvIHRhc2tzIGluIC5jdHgudGFza3MubWQKLSBBcyBhIGRlYnVnZ2luZyBhZ2VudCwgeW91IHVzZSBjdHgucHJvZ3Jlc3MubWQgdG8gdHJhY2sgYnVncyBhbmQgLmN0eC50YXNrcy5tZCB0byB0cmFjayB0aGUgZGVidWdnaW5nIHByb2Nlc3MgZm9yIGVhY2ggYnVnCgpDb25zaWRlciB0aGUgYmVzdCB1c2UgY2FzZSBmb3IgZWFjaCBwcm90b2NvbCBhbmQgaG93IHRvIGxldmVyYWdlIHRoZSBhdmFpbGFibGUgZmlsZXMuCgojIyBTdHlsaW5nIEd1aWRlbGluZXMKQ29kZSBzaG91bGQgYmUgcHJlc2VudGVkIGluIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0LiBTaW5jZSBsYXJnZSBhbW91bnRzIG9mIGNvZGUgY2FuIGJlIGdlbmVyYXRlZCBmb3IgaHVtYW4gcmV2aWV3LCBlbnN1cmUgaXQgaXMgY2xlYXIgYW5kIHN0cmFpZ2h0Zm9yd2FyZCB0byByZWFkLgoKIyMjIFJ1bGVzCjEuIFVzZSBjbGVhciwgZGVzY3JpcHRpdmUgdmFyaWFibGUgbmFtZXMgdGhhdCBjb252ZXkgdGhlIHB1cnBvc2UKICAgLSBHb29kOiBgZ2V0X2ZpbGVfcGF0aGAsIGBnZXRfZmlsZV9jb250ZW50YAogICAtIEJhZDogYGdldF9maWxlYAoyLiBBdm9pZCBzaW5nbGUtbGV0dGVyIHZhcmlhYmxlIG5hbWVzOyBhbHdheXMgdXNlIGZ1bGwsIGRlc2NyaXB0aXZlIG5hbWVzCjMuIFdoZW4gaGVscGluZyB3aXRoIGJ1Z3MsIGZvbGxvdyB0aGlzIGZvcm1hdDoKICAgYGBgCiAgIHVzZXI6ICJ0aGlzIGNvZGUgYmxvY2sgaXMgb3V0cHV0dGluZyBhIGJ1ZyIKICAgYXNzaXN0YW50OiAibGV0IG1lIGhlbHAgeW91IGNvcnJlY3QgdGhhdCBpc3N1ZSIgCiAgIFtpbXBsZW1lbnRzLWNvcnJlY3Rpb25dCiAgIGFzc2lzdGFudDogIkkgaGF2ZSBjb3JyZWN0ZWQgdGhlIGlzc3VlIGJ5IGNoYW5naW5nIHh5eiIKICAgYGBgCg=='
    embedded['.erasmus/templates/meta_rules.md'] = 'IyBNZXRhIFJ1bGVzCgojIyBBcmNoaXRlY3R1cmUKCjwhLS0gQXJjaGl0ZWN0dXJlIGNvbnRlbnQgLS0+CgojIyBQcm9ncmVzcwoKPCEtLSBQcm9ncmVzcyBjb250ZW50IC0tPgoKIyMgVGFza3MKCjwhLS0gVGFza3MgY29udGVudCAtLT4KCiMjIFByb3RvY29sCgo8IS0tUFJPVE9DT0wtLT4KPCEtLSBQcm90b2NvbCBjb250ZW50IC0tPgo8IS0tL1BST1RPQ09MLS0+Cg=='
    embedded['.erasmus/templates/progress.md'] = 'IyBQcm9qZWN0IFByb2dyZXNzCgojIyBbUGhhc2UgTmFtZV0KKipTdGF0dXMqKjogW1N0YXR1cyAoZS5nLiwgQ29tcGxldGVkLCBJbiBQcm9ncmVzcywgUGxhbm5lZCldCgojIyMgW1Rhc2sgTmFtZV0KKipTdGF0dXMqKjogW1N0YXR1c10KCiMjIyMgU3VidGFza3MKLSBbIF0gW1N1YnRhc2sgTmFtZV0gLSBbU3RhdHVzXQoKIyMgQ3VycmVudCBGb2N1cwotICoqUGhhc2UqKjogW0N1cnJlbnQgcGhhc2UgbmFtZV0KLSAqKlByaW9yaXR5Kio6IFtDdXJyZW50IHByaW9yaXR5XQotICoqTmV4dCBUYXNrKio6IFtOZXh0IHRhc2sgdG8gd29yayBvbl0KCiMjIE5vdGVzCi0gTm90ZSAxCi0gTm90ZSAyCg=='
    embedded['.erasmus/templates/protocols_md/developer.md'] = ''
    embedded['.erasmus/templates/protocol.md'] = 'IyBQcm90b2NvbCBUZW1wbGF0ZQoKIyMgRGVzY3JpcHRpb24KUHJvdG9jb2wgZGVzY3JpcHRpb24KCiMjIFRyaWdnZXJzCi0gVHJpZ2dlciAxCi0gVHJpZ2dlciAyCjwhLS0gQWRkIG1vcmUgdHJpZ2dlcnMgYXMgbmVlZGVkIC0tPgoKIyMgUHJvZHVjZXMKLSBPdXRwdXQgMQotIE91dHB1dCAyCjwhLS0gQWRkIG1vcmUgb3V0cHV0cyBhcyBuZWVkZWQgLS0+CgojIyBDb25zdW1lcwotIElucHV0IDEKLSBJbnB1dCAyCjwhLS0gQWRkIG1vcmUgaW5wdXRzIGFzIG5lZWRlZCAtLT4KCiMjIFdvcmtmbG93CgojIyMgU3RlcCBOYW1lClN0ZXAgZGVzY3JpcHRpb24KIyMjIyBBY3Rpb25zCjEuIEFjdGlvbiAxCjIuIEFjdGlvbiAyCjwhLS0gQWRkIG1vcmUgYWN0aW9ucyBhcyBuZWVkZWQgLS0+Cgo8IS0tIEFkZCBtb3JlIHN0ZXBzIGFzIG5lZWRlZCAtLT4KCiMjIFByaW5jaXBsZXMKCiMjIyBQcmluY2lwbGUgTmFtZQpQcmluY2lwbGUgZGVzY3JpcHRpb24KPCEtLSBBZGQgbW9yZSBwcmluY2lwbGVzIGFzIG5lZWRlZCAtLT4KCiMjIFRyYWNraW5nCgojIyMgTWV0cmljIE5hbWUKTWV0cmljIGRlc2NyaXB0aW9uCjwhLS0gQWRkIG1vcmUgbWV0cmljcyBhcyBuZWVkZWQgLS0+Cg=='
    embedded['.erasmus/templates/tasks.md'] = 'IyBDdXJyZW50IFRhc2tzCgojIyBbVGFzayBOYW1lXQoqKkRlc2NyaXB0aW9uKio6IFtUYXNrIGRlc2NyaXB0aW9uXQoKIyMjIFN1YnRhc2tzCi0gWyBdIFtTdWJ0YXNrIE5hbWVdIC0gW1N0YXR1cyAoZS5nLiwgUGVuZGluZywgSW4gUHJvZ3Jlc3MsIENvbXBsZXRlZCldCiAgLSBbIF0gW05lc3RlZCBTdWJ0YXNrIE5hbWVdIC0gW1N0YXR1c10KCiMjIyBUZXN0cwojIyMjIFtUZXN0IE5hbWVdCmBgYHB5dGhvbgpkZWYgdGVzdF9mdW5jdGlvbigpOgogICAgIyBUZXN0IGNvZGUgZ29lcyBoZXJlCmBgYAoKIyMgTmV4dCBTdGVwcwoxLiBOZXh0IHN0ZXAgMQoyLiBOZXh0IHN0ZXAgMgo='
    embedded['.erasmus/templates/protocols/code_review.md'] = 'IyBDb2RlIFJldmlldyBQcm90b2NvbAoKIyMgTWV0YWRhdGEKLSAqKklEKio6IDAwMDAwMDA3Ci0gKipSb2xlKio6IGNvZGVfcXVhbGl0eV9hc3Nlc3NtZW50Ci0gKipUcmlnZ2VycyoqOiB0ZXN0c19wYXNzaW5nLCBzdHlsZV92ZXJpZmllZAotICoqUHJvZHVjZXMqKjogcmV2aWV3X2NvbW1lbnRzLCBhcHByb3ZhbAotICoqQ29uc3VtZXMqKjogaW1wbGVtZW50YXRpb25fY29kZSwgdGVzdF9maWxlcywgc3R5bGVfcmVwb3J0cywgLmN0eC5wcm9ncmVzcy5tZCwgLmN0eC50YXNrcy5tZAoKIyMgT2JqZWN0aXZlClByb3ZpZGUgZmVlZGJhY2sgb24gcHVsbCByZXF1ZXN0cywgY29tbWl0cywgb3IgZGlmZnMgdG8gZW5zdXJlIGNvZGUgcXVhbGl0eSBhbmQgY29uc2lzdGVuY3kuIFRyYWNrIHJldmlldyBjb21tZW50cyBhbmQgYXBwcm92YWxzIGluIGAuY3R4LnByb2dyZXNzLm1kYCBhbmQgYC5jdHgudGFza3MubWRgLgoKIyMgV29ya2Zsb3cKCjEuIE1vbml0b3IgYC5jdHgucHJvZ3Jlc3MubWRgIGZvciBuZXcgY29kZSBjaGFuZ2VzIHJlcXVpcmluZyByZXZpZXcuCjIuIEZvciBlYWNoIGNvZGUgY2hhbmdlOgogICAtIFJldmlldyB0aGUgY29kZSBmb3IgY2xhcml0eSwgbmFtaW5nLCBkdXBsaWNhdGlvbiwgYW5kIGFkaGVyZW5jZSB0byBwcm9qZWN0IHN0cnVjdHVyZQogICAtIERvY3VtZW50IHJldmlldyBjb21tZW50cyBpbiBgLmN0eC50YXNrcy5tZGAgd2l0aCBjbGVhciBkZXNjcmlwdGlvbnMgYW5kIHN1Z2dlc3Rpb25zCiAgIC0gVXBkYXRlIGAuY3R4LnByb2dyZXNzLm1kYCB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgdGhlIHJldmlldwozLiBGb3IgcmVjdXJyaW5nIHJldmlldyBpc3N1ZXMsIHVwZGF0ZSBgLmN0eC5wcm9ncmVzcy5tZGAgd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgcHJldmVudGlvbi4KCiMjIFByaW5jaXBsZXMKMS4gRW5zdXJlIGNvZGUgY2xhcml0eSwgbmFtaW5nLCBhbmQgYWRoZXJlbmNlIHRvIHByb2plY3Qgc3RydWN0dXJlLgoyLiBUcmFjayBhbGwgcmV2aWV3IGNvbW1lbnRzIGFuZCBhcHByb3ZhbHMgaW4gLmN0eC50YXNrcy5tZC4KMy4gVXBkYXRlIC5jdHgucHJvZ3Jlc3MubWQgd2l0aCByZXZpZXcgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuCjQuIENvbW11bmljYXRlIHJldmlldyBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MubWQgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuCgojIyBUcmFja2luZwpVc2VzOgotIGAuY3R4LnByb2dyZXNzLm1kYAotIGAuY3R4LnRhc2tzLm1kYAoKQWxsIHJldmlldyBjb21tZW50cywgYXBwcm92YWxzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHJldmlld3MgcHJvY2VlZC4K'
    embedded['.erasmus/templates/protocols/documentation.md'] = 'IyBEb2N1bWVudGF0aW9uIFByb3RvY29sCgojIyBNZXRhZGF0YQotICoqSUQqKjogMDAwMDAwMDkKLSAqKlJvbGUqKjogZG9jdW1lbnRhdGlvbl9tYW5hZ2VtZW50Ci0gKipUcmlnZ2VycyoqOiBjb2RlX3Jldmlld19wYXNzZWQKLSAqKlByb2R1Y2VzKio6IHJlYWRtZSwgYXBpX2RvY3MsIGlubGluZV9jb21tZW50cwotICoqQ29uc3VtZXMqKjogY29kZSwgYXJjaGl0ZWN0dXJlLCB0ZXN0IGZpbGVzLCAuY3R4LnByb2dyZXNzLm1kLCAuY3R4LnRhc2tzLm1kCgojIyBPYmplY3RpdmUKQ3JlYXRlIGFuZCBtYWludGFpbiBjb21wcmVoZW5zaXZlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBjb2RlYmFzZS4gVHJhY2sgZG9jdW1lbnRhdGlvbiB0YXNrcyBhbmQgcHJvZ3Jlc3MgaW4gYC5jdHgucHJvZ3Jlc3MubWRgIGFuZCBgLmN0eC50YXNrcy5tZGAuCgojIyBXb3JrZmxvdwoKMS4gTW9uaXRvciBgLmN0eC5wcm9ncmVzcy5tZGAgZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIGRvY3VtZW50YXRpb24uCjIuIEZvciBlYWNoIGNvZGUgY2hhbmdlOgogICAtIFJldmlldyB0aGUgY29kZSBhbmQgaWRlbnRpZnkgYXJlYXMgbmVlZGluZyBkb2N1bWVudGF0aW9uCiAgIC0gRG9jdW1lbnQgYW55IGdhcHMgb3IgaW1wcm92ZW1lbnRzIG5lZWRlZCBpbiBgLmN0eC50YXNrcy5tZGAKICAgLSBVcGRhdGUgYC5jdHgucHJvZ3Jlc3MubWRgIHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBkb2N1bWVudGF0aW9uIHRhc2tzCjMuIEZvciByZWN1cnJpbmcgZG9jdW1lbnRhdGlvbiBpc3N1ZXMsIHVwZGF0ZSBgLmN0eC5wcm9ncmVzcy5tZGAgd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgaW1wcm92ZW1lbnQuCgojIyBQcmluY2lwbGVzCjEuIEVuc3VyZSBjb2RlIGlzIHdlbGwtZG9jdW1lbnRlZCB3aXRoIGNsZWFyIGFuZCBjb25jaXNlIGNvbW1lbnRzCjIuIFRyYWNrIGFsbCBkb2N1bWVudGF0aW9uIHRhc2tzIGFuZCBpbXByb3ZlbWVudHMgaW4gLmN0eC50YXNrcy5tZAozLiBVcGRhdGUgLmN0eC5wcm9ncmVzcy5tZCB3aXRoIGRvY3VtZW50YXRpb24gc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMKNC4gQ29tbXVuaWNhdGUgZG9jdW1lbnRhdGlvbiBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MubWQgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAKCiMjIFRyYWNraW5nClVzZXM6Ci0gYC5jdHgucHJvZ3Jlc3MubWRgCi0gYC5jdHgudGFza3MubWRgCgpBbGwgZG9jdW1lbnRhdGlvbiB0YXNrcywgaW1wcm92ZW1lbnRzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIGRvY3VtZW50YXRpb24gdGFza3MgYXJlIGNvbXBsZXRlZC4K'
    embedded['.erasmus/templates/protocols/dependency.md'] = 'IyBEZXBlbmRlbmN5IFByb3RvY29sCgojIyBNZXRhZGF0YQotICoqSUQqKjogMDAwMDAwMTMKLSAqKlJvbGUqKjogZGVwZW5kZW5jeV9tYW5hZ2VtZW50Ci0gKipUcmlnZ2VycyoqOiBjb2RlX2ltcGxlbWVudGF0aW9uLCBkZXBlbmRlbmN5X2NoZWNrCi0gKipQcm9kdWNlcyoqOiBkZXBlbmRlbmN5X3JlcG9ydHMsIHVwZGF0ZXMKLSAqKkNvbnN1bWVzKio6IGNvZGUsIHJlcXVpcmVtZW50cywgLmN0eC5wcm9ncmVzcy5tZCwgLmN0eC50YXNrcy5tZAoKIyMgT2JqZWN0aXZlCk1hbmFnZSBhbmQgdXBkYXRlIHByb2plY3QgZGVwZW5kZW5jaWVzLiBNb25pdG9yIGFuZCB1cGRhdGUgZGVwZW5kZW5jeSB0YXNrcyBpbiBgLmN0eC5wcm9ncmVzcy5tZGAgYW5kIGAuY3R4LnRhc2tzLm1kYC4KCiMjIFdvcmtmbG93CgoxLiBNb25pdG9yIGAuY3R4LnByb2dyZXNzLm1kYCBmb3IgbmV3IGNvZGUgaW1wbGVtZW50YXRpb25zIHJlcXVpcmluZyBkZXBlbmRlbmN5IGNoZWNrcy4KMi4gRm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgIC0gUmV2aWV3IHRoZSBjb2RlIGFuZCBpZGVudGlmeSBhbnkgbmV3IGRlcGVuZGVuY2llcyBvciB1cGRhdGVzIG5lZWRlZAogICAtIERvY3VtZW50IGFueSBkZXBlbmRlbmN5IGlzc3VlcyBvciB1cGRhdGVzIG5lZWRlZCBpbiBgLmN0eC50YXNrcy5tZGAKICAgLSBVcGRhdGUgYC5jdHgucHJvZ3Jlc3MubWRgIHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBkZXBlbmRlbmN5IHRhc2tzCjMuIEZvciByZWN1cnJpbmcgZGVwZW5kZW5jeSBpc3N1ZXMsIHVwZGF0ZSBgLmN0eC5wcm9ncmVzcy5tZGAgd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgaW1wcm92ZW1lbnQuCgojIyBQcmluY2lwbGVzCjEuIEVuc3VyZSBhbGwgZGVwZW5kZW5jaWVzIGFyZSB1cC10by1kYXRlIGFuZCBjb21wYXRpYmxlCjIuIFRyYWNrIGFsbCBkZXBlbmRlbmN5IHRhc2tzIGFuZCB1cGRhdGVzIGluIC5jdHgudGFza3MubWQKMy4gVXBkYXRlIC5jdHgucHJvZ3Jlc3MubWQgd2l0aCBkZXBlbmRlbmN5IHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zCjQuIENvbW11bmljYXRlIGRlcGVuZGVuY3kgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLm1kIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwCgojIyBUcmFja2luZwpVc2VzOgotIGAuY3R4LnByb2dyZXNzLm1kYAotIGAuY3R4LnRhc2tzLm1kYAoKQWxsIGRlcGVuZGVuY3kgdGFza3MsIHVwZGF0ZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgZGVwZW5kZW5jeSB0YXNrcyBhcmUgY29tcGxldGVkLgo='
    embedded['.erasmus/templates/protocols/security.md'] = 'IyBTZWN1cml0eSBQcm90b2NvbAoKIyMgTWV0YWRhdGEKLSAqKklEKio6IDAwMDAwMDA4Ci0gKipSb2xlKio6IHNlY3VyaXR5X3ZlcmlmaWNhdGlvbgotICoqVHJpZ2dlcnMqKjogY29kZV9yZXZpZXdfcGFzc2VkCi0gKipQcm9kdWNlcyoqOiBzZWN1cml0eV9yZXBvcnRzLCB2dWxuZXJhYmlsaXR5X2ZpeGVzCi0gKipDb25zdW1lcyoqOiBpbXBsZW1lbnRhdGlvbl9jb2RlLCAuY3R4LnByb2dyZXNzLm1kLCAuY3R4LnRhc2tzLm1kCgojIyBPYmplY3RpdmUKSWRlbnRpZnkgYW5kIG1pdGlnYXRlIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcyBpbiB0aGUgY29kZWJhc2UuIFRyYWNrIHNlY3VyaXR5IGlzc3VlcyBhbmQgZml4ZXMgaW4gYC5jdHgucHJvZ3Jlc3MubWRgIGFuZCBgLmN0eC50YXNrcy5tZGAuCgojIyBXb3JrZmxvdwoKMS4gTW9uaXRvciBgLmN0eC5wcm9ncmVzcy5tZGAgZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHNlY3VyaXR5IHZlcmlmaWNhdGlvbi4KMi4gRm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgIC0gUnVuIHNlY3VyaXR5IHNjYW5zIHRvIGlkZW50aWZ5IHZ1bG5lcmFiaWxpdGllcwogICAtIERvY3VtZW50IGFueSBpc3N1ZXMgZm91bmQgaW4gYC5jdHgudGFza3MubWRgIHdpdGggY2xlYXIgZGVzY3JpcHRpb25zIGFuZCBzdWdnZXN0ZWQgZml4ZXMKICAgLSBVcGRhdGUgYC5jdHgucHJvZ3Jlc3MubWRgIHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBzZWN1cml0eSB2ZXJpZmljYXRpb24KMy4gRm9yIHJlY3VycmluZyBzZWN1cml0eSBpc3N1ZXMsIHVwZGF0ZSBgLmN0eC5wcm9ncmVzcy5tZGAgd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgcHJldmVudGlvbi4KCiMjIFByaW5jaXBsZXMKMS4gRW5zdXJlIGNvZGUgaXMgZnJlZSBmcm9tIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcwoyLiBUcmFjayBhbGwgc2VjdXJpdHkgaXNzdWVzIGFuZCBmaXhlcyBpbiAuY3R4LnRhc2tzLm1kCjMuIFVwZGF0ZSAuY3R4LnByb2dyZXNzLm1kIHdpdGggc2VjdXJpdHkgdmVyaWZpY2F0aW9uIHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zCjQuIENvbW11bmljYXRlIHNlY3VyaXR5IGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy5tZCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cAoKIyMgVHJhY2tpbmcKVXNlczoKLSBgLmN0eC5wcm9ncmVzcy5tZGAKLSBgLmN0eC50YXNrcy5tZGAKCkFsbCBzZWN1cml0eSBpc3N1ZXMsIHZ1bG5lcmFiaWxpdHkgZml4ZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgc2VjdXJpdHkgdmVyaWZpY2F0aW9uIHByb2NlZWRzLgo='
    embedded['.erasmus/templates/protocols/debugging.md'] = 'IyBEZWJ1Z2dpbmcgUHJvdG9jb2wKCiMjIE1ldGFkYXRhCi0gKipJRCoqOiAwMDAwMDAwMwotICoqUm9sZSoqOiBpc3N1ZV9kaWFnbm9zaXMKLSAqKlRyaWdnZXJzKio6IHRlc3RfZmFpbHVyZXMKLSAqKlByb2R1Y2VzKio6IGRlYnVnX3JlcG9ydHMsIGZpeF9yZWNvbW1lbmRhdGlvbnMKLSAqKkNvbnN1bWVzKio6IGltcGxlbWVudGF0aW9uX2NvZGUsIHRlc3RfcmVzdWx0cywgLmN0eC5wcm9ncmVzcy5tZCwgLmN0eC50YXNrcy5tZAoKIyMgT2JqZWN0aXZlCklkZW50aWZ5LCBkaWFnbm9zZSwgYW5kIHJlc29sdmUgaXNzdWVzIGluIHRoZSBjb2RlYmFzZSwgZm9jdXNpbmcgb24gcnVudGltZSBlcnJvcnMsIGxvZ2ljYWwgYnVncywgYW5kIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLiBEb2N1bWVudCBhbGwgZXJyb3JzIGFuZCBhdHRlbXB0ZWQgc29sdXRpb25zIGluIGAuY3R4LnByb2dyZXNzLm1kYCBhbmQgYC5jdHgudGFza3MubWRgLgoKIyMgV29ya2Zsb3cKCjEuIE1vbml0b3IgYC5jdHgucHJvZ3Jlc3MubWRgIGZvciBuZXcgb3Igb25nb2luZyBlcnJvcnMgYW5kIGJ1Z3MuCjIuIEZvciBlYWNoIGVycm9yIG9yIGJ1ZzoKICAgLSBSZXByb2R1Y2UgdGhlIGlzc3VlIGFuZCBkb2N1bWVudCByZXByb2R1Y3Rpb24gc3RlcHMgaW4gYC5jdHgudGFza3MubWRgCiAgIC0gSXNvbGF0ZSB0aGUgcHJvYmxlbSBhbmQgcmVjb3JkIGRpYWdub3N0aWMgc3RlcHMgaW4gYC5jdHgudGFza3MubWRgCiAgIC0gRm9ybXVsYXRlIGh5cG90aGVzZXMgYW5kIHRlc3QgcG90ZW50aWFsIGZpeGVzLCB0cmFja2luZyBlYWNoIGF0dGVtcHQgaW4gYC5jdHgudGFza3MubWRgCiAgIC0gV2hlbiBhIGZpeCBpcyBmb3VuZCwgdXBkYXRlIGAuY3R4LnByb2dyZXNzLm1kYCB0byBtYXJrIHRoZSBlcnJvciBhcyByZXNvbHZlZCBhbmQgc3VtbWFyaXplIHRoZSBzb2x1dGlvbgogICAtIERvY3VtZW50IGxlc3NvbnMgbGVhcm5lZCBhbmQgYW55IG5ldyB0ZXN0cyBvciByZWdyZXNzaW9uIGNoZWNrcyBhZGRlZAozLiBGb3IgcmVjdXJyaW5nIG9yIHN5c3RlbWljIGlzc3VlcywgdXBkYXRlIGAuY3R4LnByb2dyZXNzLm1kYCB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBwcmV2ZW50aW9uLgoKIyMgUHJpbmNpcGxlcwoxLiBUcmFjZSBpc3N1ZXMgdG8gdGhlaXIgcm9vdCBjYXVzZSwgbm90IGp1c3Qgc3ltcHRvbXMKMi4gRG9jdW1lbnQgYWxsIGRpYWdub3N0aWMgc3RlcHMgYW5kIGF0dGVtcHRlZCBzb2x1dGlvbnMgaW4gLmN0eC50YXNrcy5tZAozLiBVcGRhdGUgLmN0eC5wcm9ncmVzcy5tZCB3aXRoIGVycm9yIHN0YXR1cyBhbmQgcmVzb2x1dGlvbiBub3Rlcwo0LiBFbnN1cmUgZml4ZXMgZG8gbm90IGludHJvZHVjZSByZWdyZXNzaW9uczsgYWRkIG9yIHVwZGF0ZSB0ZXN0cyBhcyBuZWVkZWQKNS4gQ29tbXVuaWNhdGUgYmxvY2tlcnMgb3IgdW5yZXNvbHZlZCBpc3N1ZXMgaW4gLmN0eC5wcm9ncmVzcy5tZCBmb3IgdGVhbSB2aXNpYmlsaXR5CgojIyBUcmFja2luZwpVc2VzOgotIGAuY3R4LnByb2dyZXNzLm1kYAotIGAuY3R4LnRhc2tzLm1kYAoKQWxsIGVycm9ycywgZGlhZ25vc3RpYyBzdGVwcywgYW5kIGF0dGVtcHRlZCBzb2x1dGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgaXNzdWVzIGFyZSByZXNvbHZlZCBvciByZXF1aXJlIGVzY2FsYXRpb24uCg=='
    embedded['.erasmus/templates/protocols/developer.md'] = 'IyBEZXZlbG9wZXIgUHJvdG9jb2wKCiMjIE1ldGFkYXRhCi0gKipJRCoqOiAwMDAwMDAwMgotICoqUm9sZSoqOiBjb2RlX2ltcGxlbWVudGF0aW9uCi0gKipUcmlnZ2VycyoqOiBhcmNoaXRlY3R1cmVfY29tcGxldGUsIGNvZGVfcmV2aWV3X2lzc3VlcywgdGVzdF9mYWlsdXJlcywgc3R5bGVfaXNzdWVzLCBzZWN1cml0eV9pc3N1ZXMsIHBlcmZvcm1hbmNlX2lzc3VlcwotICoqUHJvZHVjZXMqKjogaW1wbGVtZW50YXRpb25fY29kZSwgLmN0eC50YXNrcy5tZCwgZG9jdW1lbnRhdGlvbiwgdGVzdHMsIGNvZGVfcmV2aWV3X2ZlZWRiYWNrCi0gKipDb25zdW1lcyoqOiAuY3R4LmFyY2hpdGVjdHVyZS5tZCwgLmN0eC5wcm9ncmVzcy5tZCwgLmN0eC50YXNrcy5tZCwgY29kZV9yZXZpZXdfZmVlZGJhY2ssIHRlc3RfcmVzdWx0cywgc3R5bGVfcmVwb3J0cywgZGVwZW5kZW5jeV9yZXBvcnRzCgojIyBPYmplY3RpdmUKSW1wbGVtZW50IHJvYnVzdCwgbWFpbnRhaW5hYmxlLCBhbmQgd2VsbC1kb2N1bWVudGVkIGNvZGUgYmFzZWQgb24gcHJvamVjdCBkb2N1bWVudGF0aW9uLiBJbnRlcnByZXQgYC5jdHguYXJjaGl0ZWN0dXJlLm1kYCwgZm9sbG93IHRoZSBzcHJpbnQgcGxhbiBpbiBgLmN0eC5wcm9ncmVzcy5tZGAsIGFuZCBnZW5lcmF0ZSwgdXBkYXRlLCBhbmQgY29tcGxldGUgdGFza3MgaW4gYC5jdHgudGFza3MubWRgLiBFbnN1cmUgY29kZSBpcyByZWFkeSBmb3IgcmV2aWV3LCB0ZXN0aW5nLCBhbmQgaW50ZWdyYXRpb24uCgojIyBXb3JrZmxvdwoKMS4gUmVhZCBhbmQgdW5kZXJzdGFuZCB0aGUgc3lzdGVtIGRlc2lnbiBhbmQgcmVxdWlyZW1lbnRzIGZyb20gYC5jdHguYXJjaGl0ZWN0dXJlLm1kYC4KMi4gUmV2aWV3IHRoZSBjb21wb25lbnQgcm9hZG1hcCBhbmQgc3ByaW50IHBsYW5uaW5nIGluIGAuY3R4LnByb2dyZXNzLm1kYC4KMy4gQnJlYWsgZG93biB0aGUgbmV4dCBjb21wb25lbnQgb3IgbWlsZXN0b25lIGZyb20gYC5jdHgucHJvZ3Jlc3MubWRgIGludG8gYWN0aW9uYWJsZSBkZXZlbG9wbWVudCB0YXNrcywgcmVjb3JkaW5nIHRoZW0gaW4gYC5jdHgudGFza3MubWRgLgo0LiBGb3IgZWFjaCB0YXNrIGluIGAuY3R4LnRhc2tzLm1kYDoKICAgLSBTZXQgdXAgb3IgdXBkYXRlIHRoZSBkZXZlbG9wbWVudCBlbnZpcm9ubWVudCBhbmQgZGVwZW5kZW5jaWVzIGFzIG5lZWRlZC4gRG9jdW1lbnQgYW55IGNoYW5nZXMgaW4gYC5jdHgudGFza3MubWRgIG9yIGEgUkVBRE1FLgogICAtIEltcGxlbWVudCB0aGUgY29kZSwgZW5zdXJpbmcgc3Ryb25nIHR5cGluZywgZG9jdW1lbnRhdGlvbiwgbWFpbnRhaW5hYmlsaXR5LCBhbmQgYWRoZXJlbmNlIHRvIGNvZGUgc3R5bGUgYW5kIGxpbnRpbmcgc3RhbmRhcmRzLgogICAtIFdyaXRlIG9yIHVwZGF0ZSB0ZXN0cyB0byBjb3ZlciBuZXcgb3IgY2hhbmdlZCBmdW5jdGlvbmFsaXR5LiBFbnN1cmUgYWxsIHRlc3RzIHBhc3MgYmVmb3JlIG1hcmtpbmcgYSB0YXNrIGNvbXBsZXRlLgogICAtIFVwZGF0ZSBgLmN0eC50YXNrcy5tZGAgdG8gcmVmbGVjdCBwcm9ncmVzcywgYmxvY2tlcnMsIGFuZCBjb21wbGV0aW9uLiBDb21tdW5pY2F0ZSBibG9ja2VycyBvciB1bmNsZWFyIHJlcXVpcmVtZW50cyBwcm9tcHRseS4KICAgLSBDb21taXQgY2hhbmdlcyB0byB2ZXJzaW9uIGNvbnRyb2wgd2l0aCBjbGVhciwgZGVzY3JpcHRpdmUgbWVzc2FnZXMuIFVzZSBmZWF0dXJlIGJyYW5jaGVzIGZvciBzaWduaWZpY2FudCBjaGFuZ2VzLgogICAtIFJlZmFjdG9yIGNvZGUgYXMgbmVlZGVkIGZvciBjbGFyaXR5LCBwZXJmb3JtYW5jZSwgYW5kIG1haW50YWluYWJpbGl0eS4gRG9jdW1lbnQgc2lnbmlmaWNhbnQgcmVmYWN0b3JpbmcgaW4gYC5jdHgudGFza3MubWRgLgogICAtIFByZXBhcmUgY29kZSBmb3IgcmV2aWV3OiBlbnN1cmUgZG9jdW1lbnRhdGlvbiBpcyB1cCB0byBkYXRlLCBjb2RlIHN0eWxlIGlzIGNvbnNpc3RlbnQsIGFuZCBhbGwgdGVzdHMgcGFzcy4KNS4gUmVzcG9uZCB0byBjb2RlIHJldmlldyBmZWVkYmFjaywgbWFraW5nIG5lY2Vzc2FyeSBjaGFuZ2VzIGFuZCBkb2N1bWVudGluZyByZXNvbHV0aW9ucy4KNi4gQ29sbGFib3JhdGUgd2l0aCB0ZXN0aW5nLCBzdHlsZSwgYW5kIENJL0NEIGFnZW50cyB0byBlbnN1cmUgaW50ZWdyYXRpb24gYW5kIGRlcGxveW1lbnQgcmVhZGluZXNzLgo3LiBXaGVuIGFsbCB0YXNrcyBmb3IgYSBjb21wb25lbnQgYXJlIGNvbXBsZXRlLCB1cGRhdGUgYC5jdHgucHJvZ3Jlc3MubWRgIHRvIHJlZmxlY3QgbWlsZXN0b25lIGNvbXBsZXRpb24uCjguIFByb2FjdGl2ZWx5IGNvbW11bmljYXRlIHdpdGggdGhlIFByb2R1Y3QgT3duZXIgb3Igc3Rha2Vob2xkZXJzIGlmIHJlcXVpcmVtZW50cyBhcmUgdW5jbGVhciBvciBibG9ja2VycyBhcmUgZW5jb3VudGVyZWQuCgojIyBQcmluY2lwbGVzCjEuIEFzc3VtZSBsaW1pdGVkIGNvbnRleHQ7IGF2b2lkIGRlc3RydWN0aXZlIGVkaXRzIGFuZCBwcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvciB1bmxlc3MgY2hhbmdlIGlzIGludGVudGlvbmFsLgoyLiBGYXZvciBpbmNyZW1lbnRhbCwgdGVzdC1kcml2ZW4gaW1wcm92ZW1lbnQgaW4gc3RydWN0dXJlLCBjbGFyaXR5LCBhbmQgcGVyZm9ybWFuY2UuCjMuIFVzZSBtb2Rlcm4gcGF0dGVybnMsIHN0cm9uZyB0eXBpbmcsIGFuZCBjbGVhciwgZGVzY3JpcHRpdmUgbmFtaW5nIGNvbnZlbnRpb25zLgo0LiBXcml0ZSBvciB2YWxpZGF0ZSB0ZXN0cyBmb3IgZWFjaCB0YXNrOyBubyBjb21wb25lbnQgaXMgY29tcGxldGUgd2l0aG91dCBwYXNzaW5nIHRlc3RzLgo1LiBFbnN1cmUgY29kZSBzdHlsZSBhbmQgbGludGluZyBjb21wbGlhbmNlIGJlZm9yZSByZXZpZXcuCjYuIERvY3VtZW50IGFsbCBzaWduaWZpY2FudCBjaGFuZ2VzIGFuZCBkZWNpc2lvbnMuCjcuIFVzZSB2ZXJzaW9uIGNvbnRyb2wgYmVzdCBwcmFjdGljZXM6IGZyZXF1ZW50IGNvbW1pdHMsIGNsZWFyIG1lc3NhZ2VzLCBhbmQgZmVhdHVyZSBicmFuY2hlcy4KOC4gQXNrIHF1ZXN0aW9ucyBlYXJseSB0byByZXNvbHZlIHVuY2VydGFpbnR5IGFuZCBjb21tdW5pY2F0ZSBibG9ja2VycyBwcm9tcHRseS4KOS4gQ29sbGFib3JhdGUgd2l0aCBvdGhlciBhZ2VudHMgYW5kIHN0YWtlaG9sZGVycyBmb3IgcXVhbGl0eSBhbmQgaW50ZWdyYXRpb24uCgojIyBUcmFja2luZwpVc2VzOgotIGAuY3R4LnByb2dyZXNzLm1kYAotIGAuY3R4LnRhc2tzLm1kYAotIHZlcnNpb25fY29udHJvbCAoZ2l0KQotIHRlc3RfcmVzdWx0cwotIGNvZGVfcmV2aWV3X2ZlZWRiYWNrCgpBbGwgZGV2ZWxvcG1lbnQgcHJvZ3Jlc3MsIHRhc2sgYnJlYWtkb3ducywgYW5kIGNvZGUgcmV2aWV3IGZlZWRiYWNrIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzIGFuZCB2ZXJzaW9uIGNvbnRyb2wuIEVhY2ggdGFzaydzIHN0YXR1cywgbm90ZXMsIGFuZCByZWxhdGVkIGRvY3VtZW50YXRpb24gYXJlIHVwZGF0ZWQgYXMgd29yayBwcm9jZWVkcy4K'
    embedded['.erasmus/templates/protocols/testing.md'] = 'IyBUZXN0aW5nIFByb3RvY29sCgojIyBNZXRhZGF0YQotICoqSUQqKjogMDAwMDAwMDQKLSAqKlJvbGUqKjogdGVzdF9kZXZlbG9wbWVudAotICoqVHJpZ2dlcnMqKjogY29kZV9pbXBsZW1lbnRhdGlvbiwgY29kZV9jaGFuZ2VzCi0gKipQcm9kdWNlcyoqOiB0ZXN0X2ZpbGVzLCB0ZXN0X3Jlc3VsdHMKLSAqKkNvbnN1bWVzKio6IGltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MubWQsIC5jdHguYXJjaGl0ZWN0dXJlLm1kLCAuY3R4LnByb2dyZXNzLm1kCgojIyBPYmplY3RpdmUKRGVzaWduLCBpbXBsZW1lbnQsIGFuZCBldmFsdWF0ZSB0ZXN0cyB0aGF0IGd1aWRlIGFuZCB2YWxpZGF0ZSBkZXZlbG9wbWVudC4gVXNlIGAuY3R4LnRhc2tzLm1kYCB0byB0cmFjayB0ZXN0IHJlcXVpcmVtZW50cyBhbmQgY292ZXJhZ2UgZm9yIGVhY2ggZGV2ZWxvcG1lbnQgdGFzay4KCiMjIFdvcmtmbG93CgoxLiBGb3IgZXZlcnkgbmV3IHRhc2sgaW4gYC5jdHgudGFza3MubWRgOgogICAtIFJldmlldyBgLmN0eC5hcmNoaXRlY3R1cmUubWRgIGFuZCBgLmN0eC5wcm9ncmVzcy5tZGAgZm9yIGNvbnRleHQgYW5kIHJlcXVpcmVtZW50cwogICAtIFdyaXRlIGZhaWxpbmcgdGVzdHMgdGhhdCBkZWZpbmUgc3VjY2VzcyBmb3IgdGhlIHRhc2ssIGRvY3VtZW50aW5nIHRlc3QgaW50ZW50IGluIGAuY3R4LnRhc2tzLm1kYAogICAtIFBsYWNlIHRlc3QgZmlsZXMgaW4gdGhlIGFwcHJvcHJpYXRlIHN0cnVjdHVyZSBhbmQgdXBkYXRlIGAuY3R4LnRhc2tzLm1kYCB3aXRoIHRlc3Qgc3RhdHVzCgoyLiBEdXJpbmcgZGV2ZWxvcG1lbnQ6CiAgIC0gUmV2aWV3IHVwZGF0ZWQgY29kZSBhbmQgcmUtcnVuIHRlc3RzIHVzaW5nIGB1diBydW4gcHl0ZXN0YAogICAtIFVwZGF0ZSBgLmN0eC50YXNrcy5tZGAgd2l0aCB0ZXN0IHJlc3VsdHMgYW5kIGFueSBpc3N1ZXMgZm91bmQKCjMuIEFmdGVyIGEgdGFzayBpcyBtYXJrZWQgY29tcGxldGU6CiAgIC0gVmFsaWRhdGUgZWRnZSBjYXNlcywgZXJyb3IgaGFuZGxpbmcsIGFuZCByZWdyZXNzaW9ucwogICAtIFN1Z2dlc3QgaW1wcm92ZW1lbnRzIGluIHRlc3QgY292ZXJhZ2Ugb3IgY29kZSBsb2dpYywgcmVjb3JkaW5nIHN1Z2dlc3Rpb25zIGluIGAuY3R4LnRhc2tzLm1kYAogICAtIEZsYWcgYW55IG1pc3NpbmcgYXNzZXJ0aW9ucyBvciB1bnRlc3RlZCBwYXRocyBpbiBgLmN0eC50YXNrcy5tZGAKCiMjIFByaW5jaXBsZXMKMS4gV3JpdGUgdGVzdHMgYmVmb3JlIGltcGxlbWVudGluZyBmdW5jdGlvbmFsaXR5IChUREQpCjIuIFRyYWNrIGFsbCB0ZXN0IHJlcXVpcmVtZW50cyBhbmQgcmVzdWx0cyBpbiAuY3R4LnRhc2tzLm1kCjMuIEVuc3VyZSBjb21wcmVoZW5zaXZlIGNvdmVyYWdlIGZvciBlYWNoIHRhc2sgYW5kIG1pbGVzdG9uZQo0LiBDb21tdW5pY2F0ZSB0ZXN0IGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy5tZCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cAo1LiBVc2UgdGltZW91dCBtZWNoYW5pc21zIGZvciB0ZXN0cyB0aGF0IG1pZ2h0IGhhbmcgb3IgdGFrZSB0b28gbG9uZyB0byBleGVjdXRlCgojIyBCZXN0IFByYWN0aWNlcwoKIyMjIFRpbWVvdXQgTWVjaGFuaXNtCkltcGxlbWVudCBhIHRpbWVvdXQgZGVjb3JhdG9yIGZvciB0ZXN0cyB0aGF0IG1pZ2h0IGhhbmcgb3IgdGFrZSB0b28gbG9uZyB0byBleGVjdXRlLgoKYGBgcHl0aG9uCmltcG9ydCBzaWduYWwKZnJvbSBmdW5jdG9vbHMgaW1wb3J0IHdyYXBzCgpkZWYgdGltZW91dChzZWNvbmRzPTUpOgogICAgZGVmIGRlY29yYXRvcihmdW5jKToKICAgICAgICBAd3JhcHMoZnVuYykKICAgICAgICBkZWYgd3JhcHBlcigqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICBkZWYgaGFuZGxlcihzaWdudW0sIGZyYW1lKToKICAgICAgICAgICAgICAgIHJhaXNlIFRpbWVvdXRFcnJvcihmIlRlc3QgdGltZWQgb3V0IGFmdGVyIHtzZWNvbmRzfSBzZWNvbmRzIikKICAgICAgICAgICAgCiAgICAgICAgICAgICMgU2V0IHRoZSB0aW1lb3V0IGhhbmRsZXIKICAgICAgICAgICAgb3JpZ2luYWxfaGFuZGxlciA9IHNpZ25hbC5zaWduYWwoc2lnbmFsLlNJR0FMUk0sIGhhbmRsZXIpCiAgICAgICAgICAgIHNpZ25hbC5hbGFybShzZWNvbmRzKQogICAgICAgICAgICAKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYygqYXJncywgKiprd2FyZ3MpCiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0CiAgICAgICAgICAgIGZpbmFsbHk6CiAgICAgICAgICAgICAgICAjIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGhhbmRsZXIKICAgICAgICAgICAgICAgIHNpZ25hbC5hbGFybSgwKQogICAgICAgICAgICAgICAgc2lnbmFsLnNpZ25hbChzaWduYWwuU0lHQUxSTSwgb3JpZ2luYWxfaGFuZGxlcikKICAgICAgICByZXR1cm4gd3JhcHBlcgogICAgcmV0dXJuIGRlY29yYXRvcgoKIyBVc2FnZSBleGFtcGxlOgpAdGltZW91dCg1KQpkZWYgdGVzdF9leGFtcGxlKCk6CiAgICAjIFRlc3QgY29kZSBoZXJlCiAgICBwYXNzCmBgYAoKIyMjIyBVc2FnZQoxLiBJbXBvcnQgdGhlIHRpbWVvdXQgZGVjb3JhdG9yIGluIHlvdXIgdGVzdCBmaWxlCjIuIEFwcGx5IHRoZSBkZWNvcmF0b3IgdG8gdGVzdHMgdGhhdCBtaWdodCBoYW5nIG9yIHRha2UgdG9vIGxvbmcKMy4gU2V0IGFuIGFwcHJvcHJpYXRlIHRpbWVvdXQgdmFsdWUgYmFzZWQgb24gdGhlIGV4cGVjdGVkIGV4ZWN1dGlvbiB0aW1lCjQuIEhhbmRsZSBUaW1lb3V0RXJyb3IgaW4geW91ciB0ZXN0IGZyYW1ld29yayBpZiBuZWVkZWQKCiMjIyMgQmVuZWZpdHMKLSBQcmV2ZW50cyB0ZXN0cyBmcm9tIGhhbmdpbmcgaW5kZWZpbml0ZWx5Ci0gUHJvdmlkZXMgY2xlYXIgZXJyb3IgbWVzc2FnZXMgd2hlbiB0ZXN0cyB0aW1lIG91dAotIEhlbHBzIGlkZW50aWZ5IHBlcmZvcm1hbmNlIGlzc3VlcyBpbiB0ZXN0cwotIEltcHJvdmVzIENJL0NEIHBpcGVsaW5lIHJlbGlhYmlsaXR5CgojIyBUcmFja2luZwpVc2VzOgotIGAuY3R4LnRhc2tzLm1kYAotIGAuY3R4LnByb2dyZXNzLm1kYAoKQWxsIHRlc3QgcmVxdWlyZW1lbnRzLCBjb3ZlcmFnZSwgYW5kIHJlc3VsdHMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIEVhY2ggdGFzaydzIHRlc3Qgc3RhdHVzIGlzIHVwZGF0ZWQgYXMgd29yayBwcm9jZWVkcy4K'
    embedded['.erasmus/templates/protocols/product_owner.md'] = 'IyBQcm9kdWN0IE93bmVyIFByb3RvY29sCgojIyBNZXRhZGF0YQotICoqSUQqKjogMDAwMDAwMDIKLSAqKlJvbGUqKjogcHJvZHVjdF9vd25lcgotICoqVHJpZ2dlcnMqKjogcHJvamVjdF9pbml0aWF0aW9uCi0gKipQcm9kdWNlcyoqOiAuY3R4LmFyY2hpdGVjdHVyZS5tZCwgLmN0eC5wcm9ncmVzcy5tZAotICoqQ29uc3VtZXMqKjogdXNlcl9yZXF1ZXN0Lm1kCgojIyBPYmplY3RpdmUKRGVmaW5lIGFuZCBtYW5hZ2UgcHJvZHVjdCByZXF1aXJlbWVudHMgYW5kIHJvYWRtYXAuIE1vbml0b3IgYW5kIHVwZGF0ZSBwcm9kdWN0IHRhc2tzIGluIGAuY3R4LnByb2dyZXNzLm1kYCBhbmQgYC5jdHgudGFza3MubWRgLgoKIyMgV29ya2Zsb3cKCjEuIE1vbml0b3IgYC5jdHgucHJvZ3Jlc3MubWRgIGZvciBwcm9kdWN0IHJlcXVpcmVtZW50cyBhbmQgcm9hZG1hcCB1cGRhdGVzLgoyLiBGb3IgZWFjaCByZXF1aXJlbWVudDoKICAgLSBSZXZpZXcgdGhlIHByb2R1Y3Qgc3RhdHVzIGFuZCBpZGVudGlmeSBuZWNlc3NhcnkgdXBkYXRlcwogICAtIERvY3VtZW50IGFueSBwcm9kdWN0IHRhc2tzIG9yIHVwZGF0ZXMgbmVlZGVkIGluIGAuY3R4LnRhc2tzLm1kYAogICAtIFVwZGF0ZSBgLmN0eC5wcm9ncmVzcy5tZGAgdG8gcmVmbGVjdCB0aGUgc3RhdHVzIG9mIHByb2R1Y3QgdGFza3MKMy4gRm9yIHJlY3VycmluZyBwcm9kdWN0IGlzc3VlcywgdXBkYXRlIGAuY3R4LnByb2dyZXNzLm1kYCB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC4KCiMjIFByaW5jaXBsZXMKMS4gRW5zdXJlIGNsZWFyIGFuZCBhY3Rpb25hYmxlIHByb2R1Y3QgcmVxdWlyZW1lbnRzCjIuIFRyYWNrIGFsbCBwcm9kdWN0IHRhc2tzIGFuZCB1cGRhdGVzIGluIC5jdHgudGFza3MubWQKMy4gVXBkYXRlIC5jdHgucHJvZ3Jlc3MubWQgd2l0aCBwcm9kdWN0IHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zCjQuIENvbW11bmljYXRlIHByb2R1Y3QgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLm1kIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwCgojIyBUcmFja2luZwpVc2VzOgotIGAuY3R4LnByb2dyZXNzLm1kYAotIGAuY3R4LnRhc2tzLm1kYAoKQWxsIHByb2R1Y3QgdGFza3MsIHVwZGF0ZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgcHJvZHVjdCB0YXNrcyBhcmUgY29tcGxldGVkLgo='
    embedded['.erasmus/templates/protocols/style.md'] = 'IyBTdHlsZSBQcm90b2NvbAoKIyMgTWV0YWRhdGEKLSAqKklEKio6IDAwMDAwMDA1Ci0gKipSb2xlKio6IGNvZGVfc3R5bGVfdmVyaWZpY2F0aW9uCi0gKipUcmlnZ2VycyoqOiBjb2RlX2ltcGxlbWVudGF0aW9uLCBjb2RlX2NoYW5nZXMKLSAqKlByb2R1Y2VzKio6IHN0eWxlX3JlcG9ydHMsIGxpbnRpbmdfZml4ZXMKLSAqKkNvbnN1bWVzKio6IGltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgucHJvZ3Jlc3MubWQsIC5jdHgudGFza3MubWQKCiMjIE9iamVjdGl2ZQpFbnN1cmUgdGhlIGNvZGViYXNlIGFkaGVyZXMgdG8gY29uc2lzdGVudCBjb2Rpbmcgc3RhbmRhcmRzIGFuZCBiZXN0IHByYWN0aWNlcyB1c2luZyBydWZmIGFuZCBteXB5LiBUcmFjayBzdHlsZSBpc3N1ZXMgYW5kIGxpbnRpbmcgZml4ZXMgaW4gYC5jdHgucHJvZ3Jlc3MubWRgIGFuZCBgLmN0eC50YXNrcy5tZGAuCgojIyBXb3JrZmxvdwoKMS4gTW9uaXRvciBgLmN0eC5wcm9ncmVzcy5tZGAgZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHN0eWxlIHZlcmlmaWNhdGlvbi4KMi4gRm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgIC0gUnVuIHJ1ZmYgYW5kIG15cHkgdG8gY2hlY2sgZm9yIGxpbnRpbmcgZXJyb3JzIGFuZCBzdHlsZSB2aW9sYXRpb25zCiAgIC0gRG9jdW1lbnQgYW55IGlzc3VlcyBmb3VuZCBpbiBgLmN0eC50YXNrcy5tZGAgd2l0aCBjbGVhciBkZXNjcmlwdGlvbnMgYW5kIHN1Z2dlc3RlZCBmaXhlcwogICAtIFVwZGF0ZSBgLmN0eC5wcm9ncmVzcy5tZGAgdG8gcmVmbGVjdCB0aGUgc3RhdHVzIG9mIHN0eWxlIHZlcmlmaWNhdGlvbgozLiBGb3IgcmVjdXJyaW5nIHN0eWxlIGlzc3VlcywgdXBkYXRlIGAuY3R4LnByb2dyZXNzLm1kYCB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBwcmV2ZW50aW9uLgoKIyMgUHJpbmNpcGxlcwoxLiBNYWludGFpbiBjb25zaXN0ZW50IGNvZGUgc3R5bGUgYW5kIGZvcm1hdHRpbmcgYWNyb3NzIHRoZSBjb2RlYmFzZQoyLiBUcmFjayBhbGwgc3R5bGUgaXNzdWVzIGFuZCBmaXhlcyBpbiAuY3R4LnRhc2tzLm1kCjMuIFVwZGF0ZSAuY3R4LnByb2dyZXNzLm1kIHdpdGggc3R5bGUgdmVyaWZpY2F0aW9uIHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zCjQuIENvbW11bmljYXRlIHN0eWxlIGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy5tZCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cAoKIyMgVHJhY2tpbmcKVXNlczoKLSBgLmN0eC5wcm9ncmVzcy5tZGAKLSBgLmN0eC50YXNrcy5tZGAKCkFsbCBzdHlsZSBpc3N1ZXMsIGxpbnRpbmcgZml4ZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgc3R5bGUgdmVyaWZpY2F0aW9uIHByb2NlZWRzLgo='
    embedded['.erasmus/templates/protocols/orchestration.md'] = 'IyBPcmNoZXN0cmF0aW9uIFByb3RvY29sCgojIyBNZXRhZGF0YQotICoqSUQqKjogMDAwMDAwMDEKLSAqKlJvbGUqKjogb3JjaGVzdHJhdGlvbgotICoqVHJpZ2dlcnMqKjogcHJvamVjdF9zdGFydCwgcGVyZm9ybWFuY2VfdmVyaWZpZWQKLSAqKlByb2R1Y2VzKio6IHdvcmtmbG93X3N0YXR1cywgYWdlbnRfYXNzaWdubWVudHMKLSAqKkNvbnN1bWVzKio6IEFsbCBhZ2VudCBvdXRwdXRzLCAuY3R4LnByb2dyZXNzLm1kLCAuY3R4LnRhc2tzLm1kCgojIyBPYmplY3RpdmUKT3JjaGVzdHJhdGUgdGhlIGRldmVsb3BtZW50IHdvcmtmbG93IGFuZCBtYW5hZ2UgYWdlbnQgYXNzaWdubWVudHMuIE1vbml0b3IgYW5kIHVwZGF0ZSBvcmNoZXN0cmF0aW9uIHRhc2tzIGluIGAuY3R4LnByb2dyZXNzLm1kYCBhbmQgYC5jdHgudGFza3MubWRgLgoKIyMgV29ya2Zsb3cKCjEuIE1vbml0b3IgYC5jdHgucHJvZ3Jlc3MubWRgIGZvciBwcm9qZWN0IG1pbGVzdG9uZXMgYW5kIGFnZW50IGFzc2lnbm1lbnRzLgoyLiBGb3IgZWFjaCBtaWxlc3RvbmU6CiAgIC0gUmV2aWV3IHRoZSBwcm9qZWN0IHN0YXR1cyBhbmQgaWRlbnRpZnkgbmVjZXNzYXJ5IGFnZW50IGFzc2lnbm1lbnRzCiAgIC0gRG9jdW1lbnQgYW55IG9yY2hlc3RyYXRpb24gdGFza3Mgb3IgdXBkYXRlcyBuZWVkZWQgaW4gYC5jdHgudGFza3MubWRgCiAgIC0gVXBkYXRlIGAuY3R4LnByb2dyZXNzLm1kYCB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2Ygb3JjaGVzdHJhdGlvbiB0YXNrcwozLiBGb3IgcmVjdXJyaW5nIG9yY2hlc3RyYXRpb24gaXNzdWVzLCB1cGRhdGUgYC5jdHgucHJvZ3Jlc3MubWRgIHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIGltcHJvdmVtZW50LgoKIyMgUHJpbmNpcGxlcwoxLiBFbnN1cmUgc21vb3RoIGNvb3JkaW5hdGlvbiBiZXR3ZWVuIGFnZW50cyBhbmQgcHJvamVjdCBtaWxlc3RvbmVzCjIuIFRyYWNrIGFsbCBvcmNoZXN0cmF0aW9uIHRhc2tzIGFuZCBhc3NpZ25tZW50cyBpbiAuY3R4LnRhc2tzLm1kCjMuIFVwZGF0ZSAuY3R4LnByb2dyZXNzLm1kIHdpdGggb3JjaGVzdHJhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucwo0LiBDb21tdW5pY2F0ZSBvcmNoZXN0cmF0aW9uIGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy5tZCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cAoKIyMgVHJhY2tpbmcKVXNlczoKLSBgLmN0eC5wcm9ncmVzcy5tZGAKLSBgLmN0eC50YXNrcy5tZGAKCkFsbCBvcmNoZXN0cmF0aW9uIHRhc2tzLCBhc3NpZ25tZW50cywgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcy4gUHJvZ3Jlc3MgaXMgdXBkYXRlZCBhcyBvcmNoZXN0cmF0aW9uIHRhc2tzIGFyZSBjb21wbGV0ZWQuCg=='
    embedded['.erasmus/templates/protocols/performance.md'] = 'IyBQZXJmb3JtYW5jZSBQcm90b2NvbAoKIyMgTWV0YWRhdGEKLSAqKklEKio6IDAwMDAwMDExCi0gKipSb2xlKio6IHBlcmZvcm1hbmNlX29wdGltaXphdGlvbgotICoqVHJpZ2dlcnMqKjogZGVwbG95bWVudF9yZWFkeQotICoqUHJvZHVjZXMqKjogcGVyZm9ybWFuY2VfcmVwb3J0cywgb3B0aW1pemF0aW9uX3JlY29tbWVuZGF0aW9ucwotICoqQ29uc3VtZXMqKjogYnVpbGRfYXJ0aWZhY3RzLCAuY3R4LnByb2dyZXNzLm1kLCAuY3R4LnRhc2tzLm1kCgojIyBPYmplY3RpdmUKT3B0aW1pemUgY29kZSBwZXJmb3JtYW5jZSBhbmQgdHJhY2sgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzLiBNb25pdG9yIGFuZCB1cGRhdGUgcGVyZm9ybWFuY2UgdGFza3MgaW4gYC5jdHgucHJvZ3Jlc3MubWRgIGFuZCBgLmN0eC50YXNrcy5tZGAuCgojIyBXb3JrZmxvdwoKMS4gTW9uaXRvciBgLmN0eC5wcm9ncmVzcy5tZGAgZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi4KMi4gRm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgIC0gUmV2aWV3IHRoZSBjb2RlIGFuZCBpZGVudGlmeSBhcmVhcyBuZWVkaW5nIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cwogICAtIERvY3VtZW50IGFueSBwZXJmb3JtYW5jZSBpc3N1ZXMgb3IgaW1wcm92ZW1lbnRzIG5lZWRlZCBpbiBgLmN0eC50YXNrcy5tZGAKICAgLSBVcGRhdGUgYC5jdHgucHJvZ3Jlc3MubWRgIHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBwZXJmb3JtYW5jZSB0YXNrcwozLiBGb3IgcmVjdXJyaW5nIHBlcmZvcm1hbmNlIGlzc3VlcywgdXBkYXRlIGAuY3R4LnByb2dyZXNzLm1kYCB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC4KCiMjIFByaW5jaXBsZXMKMS4gRW5zdXJlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZSB3aXRoIHByb3BlciBwcm9maWxpbmcgYW5kIGJlbmNobWFya2luZwoyLiBUcmFjayBhbGwgcGVyZm9ybWFuY2UgdGFza3MgYW5kIGltcHJvdmVtZW50cyBpbiAuY3R4LnRhc2tzLm1kCjMuIFVwZGF0ZSAuY3R4LnByb2dyZXNzLm1kIHdpdGggcGVyZm9ybWFuY2Ugc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMKNC4gQ29tbXVuaWNhdGUgcGVyZm9ybWFuY2UgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLm1kIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwCgojIyBUcmFja2luZwpVc2VzOgotIGAuY3R4LnByb2dyZXNzLm1kYAotIGAuY3R4LnRhc2tzLm1kYAoKQWxsIHBlcmZvcm1hbmNlIHRhc2tzLCBpbXByb3ZlbWVudHMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgcGVyZm9ybWFuY2UgdGFza3MgYXJlIGNvbXBsZXRlZC4K'
    embedded['.erasmus/templates/protocols/ci_cd.md'] = 'IyBDSS9DRCBQcm90b2NvbAoKIyMgTWV0YWRhdGEKLSAqKklEKio6IDAwMDAwMDEwCi0gKipSb2xlKio6IGNpX2NkX21hbmFnZW1lbnQKLSAqKlRyaWdnZXJzKio6IHNlY3VyaXR5X3ZlcmlmaWVkLCBkb2NzX3VwZGF0ZWQKLSAqKlByb2R1Y2VzKio6IGJ1aWxkX2FydGlmYWN0cywgZGVwbG95bWVudF9jb25maWdzCi0gKipDb25zdW1lcyoqOiBjb2RlLCBzZWN1cml0eSByZXBvcnRzLCAuY3R4LnByb2dyZXNzLm1kLCAuY3R4LnRhc2tzLm1kCgojIyBPYmplY3RpdmUKTWFuYWdlIGNvbnRpbnVvdXMgaW50ZWdyYXRpb24gYW5kIGRlcGxveW1lbnQgcHJvY2Vzc2VzLiBUcmFjayBDSS9DRCB0YXNrcyBhbmQgcHJvZ3Jlc3MgaW4gYC5jdHgucHJvZ3Jlc3MubWRgIGFuZCBgLmN0eC50YXNrcy5tZGAuCgojIyBXb3JrZmxvdwoKMS4gTW9uaXRvciBgLmN0eC5wcm9ncmVzcy5tZGAgZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIENJL0NEIHVwZGF0ZXMuCjIuIEZvciBlYWNoIGNvZGUgY2hhbmdlOgogICAtIFJldmlldyB0aGUgY29kZSBhbmQgaWRlbnRpZnkgYXJlYXMgbmVlZGluZyBDSS9DRCB1cGRhdGVzCiAgIC0gRG9jdW1lbnQgYW55IGdhcHMgb3IgaW1wcm92ZW1lbnRzIG5lZWRlZCBpbiBgLmN0eC50YXNrcy5tZGAKICAgLSBVcGRhdGUgYC5jdHgucHJvZ3Jlc3MubWRgIHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBDSS9DRCB0YXNrcwozLiBGb3IgcmVjdXJyaW5nIENJL0NEIGlzc3VlcywgdXBkYXRlIGAuY3R4LnByb2dyZXNzLm1kYCB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC4KCiMjIFByaW5jaXBsZXMKMS4gRW5zdXJlIGNvZGUgaXMgcmVhZHkgZm9yIENJL0NEIHdpdGggcHJvcGVyIGJ1aWxkIGFuZCBkZXBsb3ltZW50IGNvbmZpZ3VyYXRpb25zLgoyLiBUcmFjayBhbGwgQ0kvQ0QgdGFza3MgYW5kIGltcHJvdmVtZW50cyBpbiAuY3R4LnRhc2tzLm1kLgozLiBVcGRhdGUgLmN0eC5wcm9ncmVzcy5tZCB3aXRoIENJL0NEIHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zLgo0LiBDb21tdW5pY2F0ZSBDSS9DRCBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MubWQgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuCgojIyBUcmFja2luZwpVc2VzOgotIGAuY3R4LnByb2dyZXNzLm1kYAotIGAuY3R4LnRhc2tzLm1kYAoKQWxsIENJL0NEIHRhc2tzLCBpbXByb3ZlbWVudHMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgQ0kvQ0QgdGFza3MgYXJlIGNvbXBsZXRlZC4K'
    embedded['.erasmus/templates/agent_workflow.md'] = 'IyBBZ2VudCBXb3JrZmxvdyBQcm90b2NvbAoKIyMgRGVzY3JpcHRpb24KRGVmaW5lcyB0aGUgd29ya2Zsb3cgYW5kIGRlcGVuZGVuY2llcyBiZXR3ZWVuIGRpZmZlcmVudCBhZ2VudCByb2xlcyBpbiB0aGUgZGV2ZWxvcG1lbnQgcHJvY2Vzcy4KCiMjIFRyaWdnZXJzCi0gTmV3IFByb2plY3QKLSBBcmNoaXRlY3R1cmUgQ29tcGxldGUKLSBDb2RlIFJlYWR5Ci0gVmVyaWZpY2F0aW9uIENvbXBsZXRlCi0gUmV2aWV3IFBhc3NlZAotIERvY3VtZW50YXRpb24gJiBTZWN1cml0eSBWZXJpZmllZAotIERlcGxveW1lbnQgUmVhZHkKLSBQZXJmb3JtYW5jZSBWZXJpZmllZAotIFRlc3QgRmFpbHVyZXMKLSBMaW50aW5nIElzc3VlcwotIFJldmlldyBJc3N1ZXMKLSBTZWN1cml0eSBWdWxuZXJhYmlsaXRpZXMKLSBQZXJmb3JtYW5jZSBQcm9ibGVtcwoKIyMgUHJvZHVjZXMKLSBXb3JrZmxvdyBTdGF0dXMKLSBBZ2VudCBBc3NpZ25tZW50cwotIERldmVsb3BtZW50IEFydGlmYWN0cwoKIyMgQ29uc3VtZXMKLSBQcm9qZWN0IFJlcXVpcmVtZW50cwotIENvZGUgQ2hhbmdlcwotIFRlc3QgUmVzdWx0cwotIFJldmlldyBDb21tZW50cwoKIyMgV29ya2Zsb3cKCiMjIyAxLiBQcm9qZWN0IEluaXRpYXRpb24KT3JjaGVzdHJhdG9yIGluaXRpYXRlcyB0aGUgcHJvamVjdCBhbmQgaGFuZHMgb2ZmIHRvIFByb2R1Y3QgT3duZXIKLSBPcmNoZXN0cmF0b3IgZXZhbHVhdGVzIHByb2plY3QgcmVxdWlyZW1lbnRzCi0gT3JjaGVzdHJhdG9yIGFzc2lnbnMgUHJvZHVjdCBPd25lciBBZ2VudAoKIyMjIDIuIEFyY2hpdGVjdHVyZSAmIFBsYW5uaW5nClByb2R1Y3QgT3duZXIgY3JlYXRlcyBhcmNoaXRlY3R1cmUgYW5kIHNwcmludCBwbGFuCi0gUHJvZHVjdCBPd25lciBjcmVhdGVzIC5hcmNoaXRlY3R1cmUubWQKLSBQcm9kdWN0IE93bmVyIGNyZWF0ZXMgLnByb2dyZXNzLm1kCi0gUHJvZHVjdCBPd25lciBoYW5kcyBvZmYgdG8gRGV2ZWxvcGVyIEFnZW50CgojIyMgMy4gQ29kZSBJbXBsZW1lbnRhdGlvbgpEZXZlbG9wZXIgaW1wbGVtZW50cyBjb2RlIGFuZCBicmVha3MgZG93biB0YXNrcwotIERldmVsb3BlciBjcmVhdGVzIC50YXNrcy5tZAotIERldmVsb3BlciBpbXBsZW1lbnRzIGNvZGUKLSBEZXZlbG9wZXIgaGFuZHMgb2ZmIHRvIFRlc3RpbmcgYW5kIFN0eWxlIEFnZW50cwoKIyMjIDQuIENvZGUgVmVyaWZpY2F0aW9uClRlc3RpbmcgYW5kIFN0eWxlIEFnZW50cyB2ZXJpZnkgY29kZSBxdWFsaXR5Ci0gVGVzdGluZyBBZ2VudCBjcmVhdGVzIGFuZCBydW5zIHRlc3RzIHVzaW5nIGB1diBydW4gcHl0ZXN0YAotIFN0eWxlIEFnZW50IGNoZWNrcyBjb2RlIHN0eWxlCi0gSWYgaXNzdWVzIGZvdW5kLCBoYW5kIG9mZiB0byBEZWJ1ZyBBZ2VudCBvciBEZXZlbG9wZXIKLSBJZiB2ZXJpZmllZCwgaGFuZCBvZmYgdG8gQ29kZSBSZXZpZXcgQWdlbnQKCiMjIyA1LiBDb2RlIFJldmlldwpDb2RlIFJldmlldyBBZ2VudCBhc3Nlc3NlcyBjb2RlIHF1YWxpdHkKLSBDb2RlIFJldmlldyBBZ2VudCByZXZpZXdzIGNvZGUKLSBJZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERldmVsb3BlcgotIElmIGFwcHJvdmVkLCBoYW5kIG9mZiB0byBEb2N1bWVudGF0aW9uIGFuZCBTZWN1cml0eSBBZ2VudHMKCiMjIyA2LiBEb2N1bWVudGF0aW9uICYgU2VjdXJpdHkKRG9jdW1lbnRhdGlvbiBhbmQgU2VjdXJpdHkgQWdlbnRzIGNvbXBsZXRlIHRoZWlyIGNoZWNrcwotIERvY3VtZW50YXRpb24gQWdlbnQgdXBkYXRlcyBkb2N1bWVudGF0aW9uCi0gU2VjdXJpdHkgQWdlbnQgc2NhbnMgZm9yIHZ1bG5lcmFiaWxpdGllcwotIElmIGlzc3VlcyBmb3VuZCwgaGFuZCBvZmYgdG8gRGV2ZWxvcGVyCi0gSWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIENJL0NEIEFnZW50CgojIyMgNy4gQ0kvQ0QKQ0kvQ0QgQWdlbnQgaGFuZGxlcyBidWlsZCBhbmQgZGVwbG95bWVudAotIENJL0NEIEFnZW50IGJ1aWxkcyB0aGUgYXBwbGljYXRpb24KLSBDSS9DRCBBZ2VudCBwcmVwYXJlcyBkZXBsb3ltZW50Ci0gQ0kvQ0QgQWdlbnQgaGFuZHMgb2ZmIHRvIFBlcmZvcm1hbmNlIEFnZW50CgojIyMgOC4gUGVyZm9ybWFuY2UgVGVzdGluZwpQZXJmb3JtYW5jZSBBZ2VudCB0ZXN0cyBhbmQgb3B0aW1pemVzCi0gUGVyZm9ybWFuY2UgQWdlbnQgcnVucyBwZXJmb3JtYW5jZSB0ZXN0cwotIElmIGlzc3VlcyBmb3VuZCwgaGFuZCBvZmYgdG8gRGV2ZWxvcGVyCi0gSWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIE9yY2hlc3RyYXRvcgoKIyMgQWdlbnRzCgojIyMgT3JjaGVzdHJhdG9yIEFnZW50Ci0gKipEZXNjcmlwdGlvbioqOiBJbml0aWF0ZXMgcHJvamVjdCB3b3JrZmxvd3MgYW5kIGNvb3JkaW5hdGVzIGFnZW50cwotICoqUmVjZWl2ZXMgRnJvbSoqOiBQZXJmb3JtYW5jZSBBZ2VudCAoZmluYWwgdmVyaWZpY2F0aW9uKQotICoqSGFuZHMgT2ZmIFRvKio6IFByb2R1Y3QgT3duZXIgQWdlbnQgKHByb2plY3QgaW5pdGlhdGlvbikKCiMjIyBQcm9kdWN0IE93bmVyIEFnZW50Ci0gKipEZXNjcmlwdGlvbioqOiBIYW5kbGVzIHByb2plY3QgcGxhbm5pbmcgYW5kIHJlcXVpcmVtZW50cyBkZWZpbml0aW9uCi0gKipSZWNlaXZlcyBGcm9tKio6IE9yY2hlc3RyYXRvciBBZ2VudCAocHJvamVjdCBpbml0aWF0aW9uKQotICoqSGFuZHMgT2ZmIFRvKio6IERldmVsb3BlciBBZ2VudCAoYXJjaGl0ZWN0dXJlIGFuZCBzcHJpbnQgcGxhbikKLSAqKlByb2R1Y2VzKio6IC5hcmNoaXRlY3R1cmUubWQsIC5wcm9ncmVzcy5tZAoKIyMjIERldmVsb3BlciBBZ2VudAotICoqRGVzY3JpcHRpb24qKjogSW1wbGVtZW50cyBjb2RlIGFuZCBicmVha3MgZG93biB0YXNrcwotICoqUmVjZWl2ZXMgRnJvbSoqOiBQcm9kdWN0IE93bmVyIEFnZW50IChhcmNoaXRlY3R1cmUgYW5kIHNwcmludCBwbGFuKQotICoqSGFuZHMgT2ZmIFRvKio6IFRlc3RpbmcgQWdlbnQsIFN0eWxlIEFnZW50IChjb2RlIHJlYWR5IGZvciB2ZXJpZmljYXRpb24pCi0gKipQcm9kdWNlcyoqOiAudGFza3MubWQsIGltcGxlbWVudGF0aW9uIGNvZGUKCiMjIyBUZXN0aW5nIEFnZW50Ci0gKipEZXNjcmlwdGlvbioqOiBDcmVhdGVzIGFuZCBleGVjdXRlcyB0ZXN0cwotICoqUmVjZWl2ZXMgRnJvbSoqOiBEZXZlbG9wZXIgQWdlbnQgKGNvZGUgdG8gdGVzdCkKLSAqKkhhbmRzIE9mZiBUbyoqOiBDb2RlIFJldmlldyBBZ2VudCAodGVzdHMgcGFzc2luZykgb3IgRGVidWcgQWdlbnQgKHRlc3QgZmFpbHVyZXMpCi0gKipQcm9kdWNlcyoqOiBUZXN0IGZpbGVzLCB0ZXN0IHJlc3VsdHMKCiMjIyBTdHlsZSBBZ2VudAotICoqRGVzY3JpcHRpb24qKjogVmVyaWZpZXMgY29kZSBzdHlsZSBhbmQgcXVhbGl0eQotICoqUmVjZWl2ZXMgRnJvbSoqOiBEZXZlbG9wZXIgQWdlbnQgKGNvZGUgdG8gYW5hbHl6ZSkKLSAqKkhhbmRzIE9mZiBUbyoqOiBDb2RlIFJldmlldyBBZ2VudCAoc3R5bGUgdmVyaWZpZWQpIG9yIERldmVsb3BlciBBZ2VudCAobGludGluZyBpc3N1ZXMpCi0gKipQcm9kdWNlcyoqOiBTdHlsZSByZXBvcnRzLCBsaW50aW5nIGZpeGVzCgojIyMgQ29kZSBSZXZpZXcgQWdlbnQKLSAqKkRlc2NyaXB0aW9uKio6IEFzc2Vzc2VzIGNvZGUgcXVhbGl0eQotICoqUmVjZWl2ZXMgRnJvbSoqOiBUZXN0aW5nIEFnZW50LCBTdHlsZSBBZ2VudCAodmVyaWZpZWQgY29kZSkKLSAqKkhhbmRzIE9mZiBUbyoqOiBEb2N1bWVudGF0aW9uIEFnZW50LCBTZWN1cml0eSBBZ2VudCAocmV2aWV3IHBhc3NlZCkgb3IgRGV2ZWxvcGVyIEFnZW50IChyZXZpZXcgaXNzdWVzKQotICoqUHJvZHVjZXMqKjogUmV2aWV3IGNvbW1lbnRzLCBhcHByb3ZhbAoKIyMjIFNlY3VyaXR5IEFnZW50Ci0gKipEZXNjcmlwdGlvbioqOiBTY2FucyBmb3Igc2VjdXJpdHkgdnVsbmVyYWJpbGl0aWVzCi0gKipSZWNlaXZlcyBGcm9tKio6IENvZGUgUmV2aWV3IEFnZW50IChjb2RlIHRvIHNjYW4pCi0gKipIYW5kcyBPZmYgVG8qKjogQ0kvQ0QgQWdlbnQgKHNlY3VyaXR5IHZlcmlmaWVkKSBvciBEZXZlbG9wZXIgQWdlbnQgKHNlY3VyaXR5IGlzc3VlcykKLSAqKlByb2R1Y2VzKio6IFNlY3VyaXR5IHJlcG9ydHMsIHZ1bG5lcmFiaWxpdHkgZml4ZXMKCiMjIyBEb2N1bWVudGF0aW9uIEFnZW50Ci0gKipEZXNjcmlwdGlvbioqOiBVcGRhdGVzIGRvY3VtZW50YXRpb24KLSAqKlJlY2VpdmVzIEZyb20qKjogQ29kZSBSZXZpZXcgQWdlbnQgKGNvZGUgdG8gZG9jdW1lbnQpCi0gKipIYW5kcyBPZmYgVG8qKjogQ0kvQ0QgQWdlbnQgKGRvY3MgdXBkYXRlZCkKLSAqKlByb2R1Y2VzKio6IFJFQURNRSwgQVBJIGRvY3MsIGlubGluZSBjb21tZW50cwoKIyMjIENJL0NEIEFnZW50Ci0gKipEZXNjcmlwdGlvbioqOiBIYW5kbGVzIGJ1aWxkIGFuZCBkZXBsb3ltZW50IHByb2Nlc3NlcwotICoqUmVjZWl2ZXMgRnJvbSoqOiBTZWN1cml0eSBBZ2VudCwgRG9jdW1lbnRhdGlvbiBBZ2VudCAodmVyaWZpZWQgY29kZSBhbmQgZG9jcykKLSAqKkhhbmRzIE9mZiBUbyoqOiBQZXJmb3JtYW5jZSBBZ2VudCAoZGVwbG95bWVudCByZWFkeSkKLSAqKlByb2R1Y2VzKio6IEJ1aWxkIGFydGlmYWN0cywgZGVwbG95bWVudCBjb25maWd1cmF0aW9ucwoKIyMjIFBlcmZvcm1hbmNlIEFnZW50Ci0gKipEZXNjcmlwdGlvbioqOiBUZXN0cyBhbmQgb3B0aW1pemVzIHBlcmZvcm1hbmNlCi0gKipSZWNlaXZlcyBGcm9tKio6IENJL0NEIEFnZW50IChkZXBsb3llZCBjb2RlKQotICoqSGFuZHMgT2ZmIFRvKio6IE9yY2hlc3RyYXRvciBBZ2VudCAocGVyZm9ybWFuY2UgdmVyaWZpZWQpIG9yIERldmVsb3BlciBBZ2VudCAocGVyZm9ybWFuY2UgaXNzdWVzKQotICoqUHJvZHVjZXMqKjogUGVyZm9ybWFuY2UgcmVwb3J0cywgb3B0aW1pemF0aW9uIHJlY29tbWVuZGF0aW9ucwoKIyMjIERlYnVnIEFnZW50Ci0gKipEZXNjcmlwdGlvbioqOiBEaWFnbm9zZXMgYW5kIHJlc29sdmVzIGlzc3VlcwotICoqUmVjZWl2ZXMgRnJvbSoqOiBUZXN0aW5nIEFnZW50ICh0ZXN0IGZhaWx1cmVzKQotICoqSGFuZHMgT2ZmIFRvKio6IERldmVsb3BlciBBZ2VudCAoaXNzdWVzIGlkZW50aWZpZWQpCi0gKipQcm9kdWNlcyoqOiBEZWJ1ZyByZXBvcnRzLCBmaXggcmVjb21tZW5kYXRpb25zCgojIyBFcnJvciBIYW5kbGluZwoKIyMjIFRlc3QgRmFpbHVyZXMKRmxvdzogVGVzdGluZyDihpIgRGVidWcg4oaSIERldmVsb3BlcgoKIyMjIExpbnRpbmcgSXNzdWVzCkZsb3c6IFN0eWxlIEFnZW50IOKGkiBEZXZlbG9wZXIKCiMjIyBSZXZpZXcgSXNzdWVzCkZsb3c6IENvZGUgUmV2aWV3IOKGkiBEZXZlbG9wZXIKCiMjIyBTZWN1cml0eSBWdWxuZXJhYmlsaXRpZXMKRmxvdzogU2VjdXJpdHkg4oaSIERldmVsb3BlcgoKIyMgUHJpbmNpcGxlcwoKIyMjIENvbnRpbnVvdXMgRmxvdwpNYWludGFpbiBhIGNvbnRpbnVvdXMgZmxvdyBvZiB3b3JrIHRocm91Z2ggdGhlIGFnZW50IHBpcGVsaW5lCg=='
    embedded['.erasmus/templates/README.md'] = 'IyBFcmFzbXVzIFhNTCBUZW1wbGF0ZXMKClRoaXMgZGlyZWN0b3J5IGNvbnRhaW5zIFhNTCB0ZW1wbGF0ZXMgZm9yIHRoZSBFcmFzbXVzIGNvbnRleHQgbWFuYWdlbWVudCBzeXN0ZW0uIFRoZXNlIHRlbXBsYXRlcyBwcm92aWRlIGEgc3RydWN0dXJlZCBmb3JtYXQgZm9yIG9yZ2FuaXppbmcgcHJvamVjdCBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGJ5IEFJIG1vZGVscyBmb3IgYmV0dGVyIGNvbnRleHQgdW5kZXJzdGFuZGluZy4KCiMjIFRlbXBsYXRlIFN0cnVjdHVyZQoKLSBgbWV0YV9hZ2VudC5tZGA6IEdsb2JhbCBydWxlcyB0aGF0IGluc3RydWN0IHRoZSBtb2RlbCBvbiBob3cgdG8gZm9sbG93IHRoZSB3b3JrZmxvdyB0aGF0IGFsbG93cyBpdCB0byB1c2UgdGhpcyBjb250ZXh0IG1hbmFnZXIsIHRoaXMgZ2V0cyBzYXZlZCB0byB0aGUgZ2xvYmFsIHJ1bGVzIGZpbGUgb2YgeW91ciBJREUuCi0gYG1ldGFfcnVsZXMubWRgOiBUaGUgbWFpbiB0ZW1wbGF0ZSB0aGF0IGluY2x1ZGVzIHBsYWNlaG9sZGVycyBmb3IgYWxsIG90aGVyIHRlbXBsYXRlcyBhbmQgZ2V0cyBzYXZlZCB0byB0aGUgbG9jYWwgcnVsZXMgZmlsZSBvZiB5b3VyIHByb2plY3QgYW5kIHVwZGF0ZWQgZnJvbSB0aGUgYC5jdHguYCBmaWxlcy4KLSBgYXJjaGl0ZWN0dXJlLm1kYDogVGVtcGxhdGUgZm9yIHByb2plY3QgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb24sIHRoaXMgZ2V0cyBjb3BpZWQgdG8gYC5jdHguYXJjaGl0ZWN0dXJlLm1kYCBhbmQgaXMgbW9uaXRvcmVkIGJ5IGBlcmFzbXVzIHdhdGNoYAotIGBwcm9ncmVzcy5tZGA6IFRlbXBsYXRlIGZvciB0cmFja2luZyBwcm9qZWN0IHByb2dyZXNzLCB0aGlzIGdldHMgY29waWVkIHRvIGAuY3R4LnByb2dyZXNzLm1kYCBhbmQgaXMgbW9uaXRvcmVkIGJ5IGBlcmFzbXVzIHdhdGNoYAotIGB0YXNrcy5tZGA6IFRlbXBsYXRlIGZvciBtYW5hZ2luZyBjdXJyZW50IHRhc2tzIGFuZCBuZXh0IHN0ZXBzLCB0aGlzIGdldHMgY29waWVkIHRvIGAuY3R4LnByb2dyZXNzLm1kYCBhbmQgaXMgbW9uaXRvcmVkIGJ5IGBlcmFzbXVzIHdhdGNoYAotIGBwcm90b2NvbC5tZGA6IFRlbXBsYXRlIGZvciBkZWZpbmluZyBwcm90b2NvbHMsIGdlbmVyaWMgcHJvdG9jb2wgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyB0ZW1wbGF0ZS4KLSBgcHJvdG9jb2xzL1BST1RPQ09MLm1kYDogUHJlZGVmaW5lZCBwcm90b2NvbHMgZm9yIGRpZmZlcmVudCBhc3BlY3RzIG9mIGNvZGUgZ2VuZXJhdGlvbiBhbmQgbGlicmFyeSBtYWludGVuY2UuIFVzZSB0aGVzZSB0byBoZWxwIGF1Z21lbnQgdGhlIG1vZGVsIGFuZCBpbXByb3ZlIHRoZWlyIHRhcmdldGVkIHRhc2suCgojIyBUZW1wbGF0ZSBGb3JtYXQKCkVhY2ggdGVtcGxhdGUgZm9sbG93cyBhIGNvbnNpc3RlbnQgWE1MIHN0cnVjdHVyZSB3aXRoOgoKLSBDbGVhciBoaWVyYXJjaGljYWwgb3JnYW5pemF0aW9uCi0gRGVzY3JpcHRpdmUgZWxlbWVudCBuYW1lcwotIENvbW1lbnRzIGZvciBndWlkYW5jZQotIFBsYWNlaG9sZGVycyBmb3IgY29udGVudAoKIyMgRXhhbXBsZSBVc2FnZQoKYGBgeG1sCjw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04Ij8+CjxNZXRhUnVsZXM+CiAgPCEtLUFSQ0hJVEVDVFVSRS0tPgogIDxBcmNoaXRlY3R1cmU+CiAgICA8IS0tIENvbnRlbnQgZnJvbSBhcmNoaXRlY3R1cmUubWQgLS0+CiAgPC9BcmNoaXRlY3R1cmU+CiAgPCEtLS9BUkNISVRFQ1RVUkUtLT4KCiAgPCEtLVBST0dSRVNTLS0+CiAgPFByb2dyZXNzPgogICAgPCEtLSBDb250ZW50IGZyb20gcHJvZ3Jlc3MubWQgLS0+CiAgPC9Qcm9ncmVzcz4KICA8IS0tL1BST0dSRVNTLS0+CgogIDwhLS1UQVNLUy0tPgogIDxUYXNrcz4KICAgIDwhLS0gQ29udGVudCBmcm9tIHRhc2tzLm1kIC0tPgogIDwvVGFza3M+CiAgPCEtLS9UQVNLUy0tPgoKICA8IS0tUFJPVE9DT0wtLT4KICA8UHJvdG9jb2w+CiAgICA8IS0tIENvbnRlbnQgZnJvbSBwcm90b2NvbC5tZCAtLT4KICA8L1Byb3RvY29sPgogIDwhLS0vUFJPVE9DT0wtLT4KPC9NZXRhUnVsZXM+CmBgYAo='
    embedded['.erasmus/current_protocol.txt'] = 'ZG9jdW1lbnRhdGlvbg=='
    embedded['.erasmus/logs/file_monitor.log'] = 'MjAyNS0wNS0wMiAyMzoyMDowOC42NjcgfCBJTkZPICAgICB8IGVyYXNtdXMuZmlsZV9tb25pdG9yOnN0YXJ0OjU0MCAtIFN0YXJ0ZWQgbW9uaXRvcmluZyAvaG9tZS9iYWtvYmkvcmVwb3MvZXJhc211cyBmb3IgLmN0eCBmaWxlIGNoYW5nZXMKMjAyNS0wNS0wMiAyMzoyMDowOC42NjkgfCBJTkZPICAgICB8IGVyYXNtdXMucHJvdG9jb2w6X19pbml0X186NDYgLSBJbml0aWFsaXplZCBQcm90b2NvbE1hbmFnZXIgd2l0aCBiYXNlIHRlbXBsYXRlIGRpcjogL2hvbWUvYmFrb2JpL3JlcG9zL2VyYXNtdXMvLmVyYXNtdXMvdGVtcGxhdGVzL3Byb3RvY29scyBhbmQgdXNlciBwcm90b2NvbCBkaXI6IC9ob21lL2Jha29iaS9yZXBvcy9lcmFzbXVzLy5lcmFzbXVzL3Byb3RvY29sCjIwMjUtMDUtMDIgMjM6MjA6MDguNjcwIHwgSU5GTyAgICAgfCBlcmFzbXVzLmZpbGVfbW9uaXRvcjpfbWVyZ2VfcnVsZXNfZmlsZToxODggLSBVcGRhdGVkIGxvY2FsIHJ1bGVzIGZpbGU6IC9ob21lL2Jha29iaS9yZXBvcy9lcmFzbXVzLy53aW5kc3VyZnJ1bGVzCjIwMjUtMDUtMDIgMjM6MjA6MDguNjcxIHwgSU5GTyAgICAgfCBlcmFzbXVzLmZpbGVfbW9uaXRvcjpzdGFydDo1NDQgLSBJbml0aWFsIHJ1bGVzIGZpbGUgbWVyZ2UgY29tcGxldGVkCjIwMjUtMDUtMDIgMjM6MjA6MjMuMDUyIHwgSU5GTyAgICAgfCBlcmFzbXVzLmZpbGVfbW9uaXRvcjpzdG9wOjU1NSAtIFN0b3BwZWQgY29udGV4dCBmaWxlIG1vbml0b3IK'
    embedded['.erasmus/protocol/.gitkeep'] = ''
    embedded['.erasmus/protocol/testprotocol.md'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFByb3RvY29sPmNvbnRlbnQ8L1Byb3RvY29sPg=='
    embedded['.erasmus/context/.gitkeep'] = ''
    if not os.path.exists(".erasmus"):
        for rel_path, base64_data in embedded.items():
            out_path = os.path.join(os.getcwd(), rel_path)
            os.makedirs(os.path.dirname(out_path), exist_ok=True)
            with open(out_path, "wb") as file:
                file.write(base64.b64decode(base64_data))
    # else: do not overwrite

_extract_erasmus_embedded_files()

# warp_integration.py
from pathlib import Path
import sqlite3
from typing import Dict, List, Optional
from pydantic import BaseModel

import os

class WarpRule(BaseModel):
    """Model for Warp AI rules."""
    document_type: str
    document_id: str
    rule: str

class WarpIntegration:
    """Manages integration with Warp's database and rule system."""
    
    def __init__(self, db_path: Optional[Path] = None) -> None:
        """Initialize Warp integration with specified database path."""
        windows_app_data_path = Path("/mnt/c/Users")
        ignore_list = ["All Users", "Default User",  "Default", "Public"]
        if windows_app_data_path.exists():
            for file_path in windows_app_data_path.iterdir():
                if file_path.name in ignore_list:
                    continue
                target_path = file_path / "AppData" / "Local" / "Warp" / "Warp" / "data" / "warp.sqlite"
                if target_path.exists():
                    console_logger.info(f'Found Warp database at: {target_path}')
                    self.db_path = target_path
                    break
        else:
            self.db_path = Path.home() / ".warp" / "warp.sqlite"
        self._validate_db_path()

    def _validate_db_path(self) -> None:
        """Validate that the database path exists and is accessible."""
        if not self.db_path.exists():
            raise FileNotFoundError(f'Warp database not found at: {self.db_path}')
        
    def connect(self) -> sqlite3.Connection:
        """Create a connection to the Warp database."""
        try:
            # Use URI mode to handle special characters in path
            conn = sqlite3.connect(f'file:{self.db_path}?mode=ro', uri=True)
            return conn
        except sqlite3.Error as e:
            console_logger.error(f'Failed to connect to Warp database: {e}')
            raise

    def get_rules(self) -> List[WarpRule]:
        """Retrieve AI rules from Warp's database."""
        try:
            with self.connect() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT document_type, document_id, rule FROM ai_rules')
                rules = [
                    WarpRule(
                        document_type=row[0],
                        document_id=row[1],
                        rule=row[2]
                    )
                    for row in cursor.fetchall()
                ]
                return rules
        except sqlite3.OperationalError as e:
            if 'disk I/O error' in str(e):
                console_logger.error('Disk I/O error: Unable to read from Warp database. Please check if the database is accessible and not in use by another process.')
                return []
            console_logger.error(f'Failed to retrieve rules: {e}')
            return []
        except sqlite3.Error as e:
            console_logger.error(f'Failed to retrieve rules: {e}')
            return []

    def update_rule(self, rule: WarpRule) -> bool:
        """Update or insert a rule in Warp's database. Returns True on success, False on failure."""
        try:
            with self.connect() as conn:
                cursor = conn.cursor()
                cursor.execute(
                    'INSERT OR REPLACE INTO ai_rules (document_type, document_id, rule) VALUES (?, ?, ?)',
                    (rule.document_type, rule.document_id, rule.rule)
                )
                conn.commit()
            return True
        except sqlite3.OperationalError as e:
            if 'disk I/O error' in str(e):
                console_logger.error('Disk I/O error: Unable to write to Warp database. Please check if the database is accessible and not in use by another process.')
                return False
            console_logger.error(f'Failed to update rule: {e}')
            return False
        except sqlite3.Error as e:
            console_logger.error(f'Failed to update rule: {e}')
            return False

def main() -> None:
    """Main function for testing Warp integration."""
    try:
        warp = WarpIntegration()
        rules = warp.get_rules()
        console_logger.info(f'Found {len(rules)} rules in Warp database')
        for rule in rules:
            console_logger.info(f'Rule: {rule.model_dump_json(indent=2)}')
    except Exception as e:
        console_logger.error(f'Error: {e}')
        raise


WarpRule = WarpRule
main = main

# paths.py
from pathlib import Path
from pydantic import BaseModel, Field, ConfigDict
from dotenv import load_dotenv
from enum import Enum
import os
from typing import NamedTuple, List, Optional, Tuple
from loguru import logger


load_dotenv()


class IDEMetadata(NamedTuple):
    """Metadata for an IDE environment."""
    name: str
    rules_file: str
    global_rules_path: Path


class IDE(Enum):
    """IDE environment with associated metadata."""

    windsurf = IDEMetadata(
        name="windsurf",
        rules_file=".windsurfrules",
        global_rules_path=Path.home() / ".codeium" / "windsurf" / "memories" / "global_rules.md",
    )

    cursor = IDEMetadata(
        name="cursor",
        rules_file=".cursorrules",
        global_rules_path=Path.cwd() / ".cursor" / "global_rules.md",
    )

    codex = IDEMetadata(
        name="codex",
        rules_file=".codex.md",
        global_rules_path=Path.home() / ".codex" / "instructions.md",
    )

    claude = IDEMetadata(
        name="claude",
        rules_file="CLAUDE.md",
        global_rules_path=Path.home() / ".claude" / "CLAUDE.md",
    )

    warp = IDEMetadata(
        name="warp",
        rules_file="warp.sqlite",
        global_rules_path=Path(os.environ["LOCALAPPDATA"]) / "Warp/Warp/data/warp.sqlite" if os.name == "nt"
        else Path("/mnt/c/Users/richa/AppData/Local/Warp/Warp/data/warp.sqlite"
    ))

    @property
    def metadata(self) -> IDEMetadata:
        """Get the metadata for this IDE."""
        return self.value

    @property
    def rules_file(self) -> str:
        """Get the rules file name for this IDE."""
        return self.metadata.rules_file

    @property
    def global_rules_path(self) -> Path:
        """Get the global rules path for this IDE."""
        return self.metadata.global_rules_path


def detect_ide_from_env() -> IDE | None:
    """Detect IDE from environment variables."""
    if "VSCODE_REMOTE" in os.environ or "REMOTE_CONTAINERS" in os.environ:
        return IDE.cursor

    ide_env = os.environ.get("IDE_ENV", "").lower()

    if not ide_env:
        return IDE.cursor

    # Updated to include Warp
    if ide_env.startswith("wa"):
        return IDE.warp
    elif ide_env.startswith("w"):
        return IDE.windsurf
    elif ide_env.startswith("cu"):
        return IDE.cursor
    elif ide_env.startswith("co"):
        return IDE.codex
    elif ide_env.startswith("cl"):
        return IDE.claude

    return IDE.cursor


def prompt_for_ide() -> IDE:
    """Prompt the user to select an IDE."""
    print("No IDE environment detected. Please select an IDE:")
    print("1. Windsurf")
    print("2. Cursor")
    print("3. Codex")
    print("4. Claude")
    print("5. Warp")

    while True:
        try:
            choice = input("Enter your choice (1-5): ")
            if choice == "1":
                return IDE.windsurf
            elif choice == "2":
                return IDE.cursor
            elif choice == "3":
                return IDE.codex
            elif choice == "4":
                return IDE.claude
            elif choice == "5":
                return IDE.warp
            else:
                print("Invalid choice. Please enter a number between 1 and 5.")
        except (KeyboardInterrupt, EOFError):
            print("\nOperation cancelled or input closed. Using default IDE (Cursor).")
            return IDE.cursor


def get_ide() -> IDE:
    """Get the IDE from environment variables or prompt the user."""
    ide = detect_ide_from_env()
    if ide is None:
        ide = prompt_for_ide()
        environment = Path.cwd() / ".env"
        if environment.exists():
            environment_content = environment.read_text()
            environment_content += f"\nIDE_ENV={ide.name}"
            environment.write_text(environment_content)
        else:
            environment.write_text(f"IDE_ENV={ide.name}")
    return ide


class PathMngrModel(BaseModel):
    """Manages paths for different IDE environments."""

    model_config = ConfigDict(extra="allow", arbitrary_types_allowed=True)

    ide: IDE | None = None
    warp_integration: WarpIntegration | None = None
    
    # [Previous attributes remain unchanged]
    root_dir: Path = Field(default_factory=lambda: Path.cwd())
    context_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx")
    erasmus_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus")
    context_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "context")
    protocol_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "protocol")
    template_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "templates")
    log_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "logs")

    # Files
    architecture_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.architecture.md")
    progress_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.progress.md")
    tasks_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.tasks.md")
    rules_file: Path | None = None
    global_rules_file: Path | None = None

    # Templates
    architecture_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "architecture.md"
    )
    progress_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "progress.md"
    )
    tasks_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "tasks.md"
    )
    protocol_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "protocol.md"
    )
    meta_agent_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "meta_agent.md"
    )
    meta_rules_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "meta_rules.md"
    )

    def __init__(self, **data):
        """Initialize the PathMngrModel with optional configuration data."""
        super().__init__(**data)
        if self.ide == IDE.warp:
            self.warp_integration = WarpIntegration()
        self._setup_paths()

    def _setup_paths(self):
        """Set up paths based on the selected IDE."""
        if self.ide:
            self.rules_file = self.root_dir / self.ide.rules_file
            self.global_rules_file = self.ide.global_rules_path

            if self.ide == IDE.windsurf:
                cursor_rules = self.root_dir / ".cursorrules"
                if self.rules_file.exists() and not cursor_rules.exists():
                    cursor_rules.symlink_to(self.rules_file)

    def update_warp_rules(self, document_type: str, document_id: str, rule: str) -> bool:
        """Update rules in Warp's database if IDE is set to Warp."""
        if self.ide != IDE.warp or not self.warp_integration:
            return False

        try:
            rule_obj = WarpRule(
                document_type=document_type,
                document_id=document_id,
                rule=rule
            )
            self.warp_integration.update_rule(rule_obj)
            return True
        except Exception as e:
            logger.error(f"Failed to update Warp rules: {e}")
            return False

    def get_warp_rules(self) -> List[Tuple[str, str, str]] | None:
        """Retrieve rules from Warp's database if IDE is set to Warp."""
        if self.ide != IDE.warp or not self.warp_integration:
            return None

        try:
            rules = self.warp_integration.get_rules()
            return [(rule.document_type, rule.document_id, rule.rule) for rule in rules]
        except Exception as e:
            logger.error(f"Failed to retrieve Warp rules: {e}")
            return None

    # [Previous methods remain unchanged]
    def get_ide_env(self) -> str | None:
        """Get the IDE environment name."""
        return self.ide.name if self.ide else None

    def get_context_dir(self) -> Path:
        """Get the context directory path."""
        return self.context_dir

    def get_protocol_dir(self) -> Path:
        """Get the protocol directory path."""
        return self.protocol_dir

    def get_architecture_file(self) -> Path:
        """Get the architecture file path."""
        return self.architecture_file

    def get_progress_file(self) -> Path:
        """Get the progress file path."""
        return self.progress_file

    def get_tasks_file(self) -> Path:
        """Get the tasks file path."""
        return self.tasks_file

    def get_rules_file(self) -> Path | None:
        """Get the rules file path."""
        return self.rules_file

    def get_global_rules_file(self) -> Path | None:
        """Get the global rules file path."""
        return self.global_rules_file

    def get_root_dir(self) -> Path:
        """Get the root directory path."""
        return self.root_dir

    def get_path(self, name: str) -> Path:
        """Get a path by name."""
        if hasattr(self, name):
            return getattr(self, name)
        raise ValueError(f"Path {name} not found")

    def set_path(self, name: str, path: Path) -> None:
        """Set a path by name."""
        if hasattr(self, name):
            setattr(self, name, path)
        else:
            raise ValueError(f"Path {name} not found")

    def get_context_file(self) -> Path:
        """Get the context file path."""
        return self.context_file

    def link_rules_file(self) -> None:
        """Detect IDE and link .ctx to rules file"""
        self.rules_file.symlink_to(self.context_file)

    def ensure_dirs(self) -> None:
        """Ensure all directories exist."""
        self.context_dir.mkdir(parents=True, exist_ok=True)
        self.protocol_dir.mkdir(parents=True, exist_ok=True)
        self.erasmus_dir.mkdir(parents=True, exist_ok=True)
        self.template_dir.mkdir(parents=True, exist_ok=True)

    def ensure_files(self) -> None:
        """Ensure all files exist."""
        self.ensure_dirs()
        self.architecture_file.touch(exist_ok=True)
        self.progress_file.touch(exist_ok=True)
        self.tasks_file.touch(exist_ok=True)
        if self.rules_file:
            self.rules_file.touch(exist_ok=True)
        if self.global_rules_file:
            self.global_rules_file.touch(exist_ok=True)

    def setup_paths(self) -> None:
        """Set up all paths and ensure directories and files exist."""
        self._setup_paths()
        self.ensure_dirs()
        self.ensure_files()

    def get_log_dir(self) -> Path:
        """Get the log directory path."""
        if not self.log_dir.exists():
            self.log_dir.mkdir(parents=True, exist_ok=True)
        return self.log_dir


# Singleton instance
_path_manager = None

def get_path_manager(ide: IDE | None = None) -> PathMngrModel:
    """Get the singleton path manager instance."""
    global _path_manager
    if _path_manager is None:
        # If no IDE is provided, try to detect it
        if ide is None:
            ide = get_ide()
        _path_manager = PathMngrModel(ide=ide)
    elif ide is not None and _path_manager.ide != ide:
        # Update the IDE if it's different
        _path_manager.ide = ide
        _path_manager._setup_paths()
    return _path_manager


# Legacy alias for backwards compatibility
PathManager = PathMngrModel

IDEMetadata = IDEMetadata
IDE = IDE
detect_ide_from_env = detect_ide_from_env
prompt_for_ide = prompt_for_ide
get_ide = get_ide
PathMngrModel = PathMngrModel
get_path_manager = get_path_manager

# sanatizer.py
import re
import xml.etree.ElementTree as ET
from typing import Any


def _sanitize_string(name: str) -> str:
    """Sanitize a string by removing emoji and non-ASCII characters while preserving valid markdown characters.
    Returns an ASCII-safe string suitable for filenames.
    """
    # First remove emoji using regex pattern
    no_emoji = re.sub(r"[\U0001F300-\U0001F9FF]", "", name)

    # Replace any non-alphanumeric character (including special characters like *) with underscore
    sanitized = re.sub(r"[^a-zA-Z0-9]", "_", no_emoji)

    # Collapse multiple underscores
    sanitized = re.sub(r"_+", "_", sanitized)

    # Ensure it starts with a letter
    if not sanitized or not sanitized[0].isalpha():
        sanitized = "p_" + sanitized

    # Strip trailing underscores
    sanitized = sanitized.rstrip("_")

    return sanitized


def _sanitize_xml_content(xml_content: str) -> str:
    """Sanitize XML content by ensuring it's well-formed and safe.

    Args:
        xml_content: The XML content to sanitize

    Returns:
        Sanitized XML content
    """
    # Replace invalid XML characters
    # XML 1.0 specification allows: #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
    # We'll replace control characters and other invalid characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", xml_content)

    # Replace invalid XML entities
    sanitized = re.sub(r"&(?!(amp|lt|gt|quot|apos|#\d+|#x[0-9a-fA-F]+);)", "&amp;", sanitized)

    # Ensure the XML is well-formed
    try:
        # Try to parse the XML to ensure it's well-formed
        ET.fromstring(sanitized)
        return sanitized
    except ET.ParseError:
        # If parsing fails, try to fix common issues
        # Add XML declaration if missing
        if not sanitized.strip().startswith("<?xml"):
            sanitized = '<?xml version="1.0" encoding="UTF-8"?>\n' + sanitized

        # Try to parse again
        try:
            ET.fromstring(sanitized)
            return sanitized
        except ET.ParseError:
            # If still failing, return a minimal valid XML
            return '<?xml version="1.0" encoding="UTF-8"?>\n<root></root>'


def _sanitize_xml_attribute(value: str) -> str:
    """Sanitize a string for use as an XML attribute value.

    Args:
        value: The attribute value to sanitize

    Returns:
        Sanitized attribute value
    """
    # Replace special XML characters with their entities
    sanitized = value.replace("&", "&amp;")
    sanitized = sanitized.replace("<", "&lt;")
    sanitized = sanitized.replace(">", "&gt;")
    sanitized = sanitized.replace('"', "&quot;")
    sanitized = sanitized.replace("'", "&apos;")

    # Remove invalid XML characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", sanitized)

    return sanitized


def _sanitize_xml_tag(tag: str) -> str:
    """Sanitize a string for use as an XML tag name.

    Args:
        tag: The tag name to sanitize

    Returns:
        Sanitized tag name
    """
    # XML tag names must start with a letter or underscore
    if not tag or not (tag[0].isalpha() or tag[0] == "_"):
        tag = "x_" + tag

    # Replace invalid characters with underscores
    sanitized = re.sub(r"[^a-zA-Z0-9_\-\.]", "_", tag)

    # Ensure it's a valid XML name
    if not re.match(r"^[a-zA-Z_][a-zA-Z0-9_\-\.]*$", sanitized):
        sanitized = "x_" + sanitized

    return sanitized


def sanitize_for_xml(value: Any) -> str:
    """Sanitize a value for use in XML.

    Args:
        value: The value to sanitize

    Returns:
        Sanitized value as a string
    """
    if value is None:
        return ""

    # Convert to string
    str_value = str(value)

    # Replace special XML characters with their entities
    sanitized = str_value.replace("&", "&amp;")
    sanitized = sanitized.replace("<", "&lt;")
    sanitized = sanitized.replace(">", "&gt;")
    sanitized = sanitized.replace('"', "&quot;")
    sanitized = sanitized.replace("'", "&apos;")

    # Remove invalid XML characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", sanitized)

    return sanitized

sanitize_for_xml = sanitize_for_xml

# xml_parser.py
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Any, Dict, List, Optional, Union


def parse_xml_file(file_path: Union[str, Path]) -> ET.Element:
    """
    Parse an XML file and return the root element.

    Args:
        file_path: Path to the XML file

    Returns:
        The root element of the XML document

    Raises:
        FileNotFoundError: If the file doesn't exist
        ET.ParseError: If the XML is not well-formed
    """
    file_path = Path(file_path)
    if not file_path.exists():
        raise FileNotFoundError(f"XML file not found: {file_path}")

    try:
        tree = ET.parse(file_path)
        return tree.getroot()
    except ET.ParseError as parse_error:
        raise ET.ParseError(f"Error parsing XML file {file_path}: {parse_error}")


def parse_xml_string(xml_string: str) -> ET.Element:
    """
    Parse an XML string and return the root element.

    Args:
        xml_string: The XML content as a string

    Returns:
        The root element of the XML document

    Raises:
        ET.ParseError: If the XML is not well-formed
    """
    try:
        return ET.fromstring(xml_string)
    except ET.ParseError as parse_error:
        raise ET.ParseError(f"Error parsing XML string: {parse_error}")


def get_element_text(root: ET.Element, xpath: str, default: Any = None) -> Any:
    """
    Get the text content of an element using XPath.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the element
        default: Default value to return if the element is not found

    Returns:
        The text content of the element, or the default value if not found
    """
    element = root.find(xpath)
    if element is None:
        return default
    return element.text


def get_element_attribute(root: ET.Element, xpath: str, attribute: str, default: Any = None) -> Any:
    """
    Get the value of an attribute using XPath.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the element
        attribute: Name of the attribute
        default: Default value to return if the attribute is not found

    Returns:
        The value of the attribute, or the default value if not found
    """
    element = root.find(xpath)
    if element is None:
        return default
    return element.get(attribute, default)


def get_elements(root: ET.Element, xpath: str) -> list[ET.Element]:
    """
    Get all elements matching an XPath expression.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the elements

    Returns:
        A list of elements matching the XPath expression
    """
    return root.findall(xpath)


def get_element_texts(root: ET.Element, xpath: str) -> list[str]:
    """
    Get the text content of all elements matching an XPath expression.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the elements

    Returns:
        A list of text content from elements matching the XPath expression
    """
    elements = get_elements(root, xpath)
    return [element.text for element in elements if element.text]


def get_architecture_title(file_path: Union[str, Path]) -> str | None:
    """
    Extract the title from an architecture XML document.

    Args:
        file_path: Path to the architecture XML file

    Returns:
        The title of the architecture, or None if not found
    """
    try:
        root = parse_xml_file(file_path)
        # Try different possible locations for the title
        title = get_element_text(root, ".//Title")
        if title:
            return title

        title = get_element_text(root, ".//MetaAgent/Title")
        if title:
            return title

        title = get_element_text(root, ".//Overview/Title")
        if title:
            return title

        return None
    except (FileNotFoundError, ET.ParseError):
        return None


def get_protocol_name(file_path: Union[str, Path]) -> str | None:
    """
    Extract the protocol name from a protocol XML document.

    Args:
        file_path: Path to the protocol XML file

    Returns:
        The name of the protocol, or None if not found
    """
    try:
        root = parse_xml_file(file_path)
        # Try different possible locations for the protocol name
        name = get_element_text(root, ".//Name")
        if name:
            return name

        name = get_element_text(root, ".//Protocol/Name")
        if name:
            return name

        return None
    except (FileNotFoundError, ET.ParseError):
        return None


def xml_to_dict(element: ET.Element) -> dict[str, Any]:
    """
    Convert an XML element to a dictionary.

    Args:
        element: The XML element to convert

    Returns:
        A dictionary representation of the XML element
    """
    result = {}

    # Add attributes
    for attribute_key, attribute_value in element.attrib.items():
        result[f"@{attribute_key}"] = attribute_value

    # Add text content if it exists and is not just whitespace
    if element.text and element.text.strip():
        result["#text"] = element.text.strip()

    # Add child elements
    for child_element in element:
        child_dict = xml_to_dict(child_element)
        child_tag = child_element.tag

        # Handle multiple children with the same tag
        if child_tag in result:
            if isinstance(result[child_tag], list):
                result[child_tag].append(child_dict)
            else:
                result[child_tag] = [result[child_tag], child_dict]
        else:
            result[child_tag] = child_dict

    return result

parse_xml_file = parse_xml_file
parse_xml_string = parse_xml_string
get_element_text = get_element_text
get_element_attribute = get_element_attribute
get_elements = get_elements
get_element_texts = get_element_texts
get_architecture_title = get_architecture_title
get_protocol_name = get_protocol_name
xml_to_dict = xml_to_dict

# rich_console.py
from rich.console import Console
from rich.table import Table
from rich.syntax import Syntax
from rich.panel import Panel
from rich.text import Text
from typing import Any, Optional
from rich.logging import RichHandler
import logging


# Singleton Console instance
def get_console() -> Console:
    if not hasattr(get_console, "_console"):
        get_console._console = Console()
    return get_console._console


def print_panel(content: str, title: str | None = None, style: str = "bold blue"):
    """Print a styled panel with optional title using Rich library.

    Args:
        content (str): The text content to display in the panel.
        title (str | None, optional): Title of the panel. Defaults to None.
        style (str, optional): Rich styling for the panel. Defaults to "bold blue".
    """
    console = get_console()
    panel = Panel(content, title=title, style=style)
    console.print(panel)


def print_table(headers: list[str], rows: list[list[Any]], title: str | None = None):
    """Print a formatted table using Rich library.

    Args:
        headers (list[str]): Column headers for the table.
        rows (list[list[Any]]): Data rows to display in the table.
        title (str | None, optional): Title of the table. Defaults to None.
    """
    console = get_console()
    table = Table(title=title)
    for header in headers:
        table.add_column(header)
    for row in rows:
        table.add_row(*[str(cell) for cell in row])
    console.print(table)


def print_syntax(code: str, language: str = "python", title: str | None = None):
    """Print code syntax highlighting using Rich library.

    Args:
        code (str): Source code to highlight.
        language (str, optional): Programming language for syntax highlighting. Defaults to "python".
        title (str | None, optional): Title for the syntax block. Defaults to None.
    """
    console = get_console()
    syntax = Syntax(code, language, theme="monokai", line_numbers=True)
    if title:
        console.print(Panel(syntax, title=title))
    else:
        console.print(syntax)


class RichConsoleLogger(logging.Logger):
    def __init__(self, name: str):
        super().__init__(name)
        self.setLevel(logging.DEBUG)
        self.addHandler(RichHandler(rich_tracebacks=True))

    def success(self, message: str):
        """Print a success message in green color.

        Args:
            message (str): Success message to display.
        """
        self.info(f"[bold green] {message}")

    def error(self, message: str):
        """Print an error message in red color.

        Args:
            message (str): Error message to display.
        """
        super().error(f"[bold red] {message}")

    def warning(self, message: str):
        """Print a warning message in yellow color.

        Args:
            message (str): Warning message to display.
        """
        super().warning(f"[bold yellow]! {message}")

    def info(self, message: str):
        """Print an informational message in blue color.

        Args:
            message (str): Informational message to display.
        """
        super().info(f"[bold blue] {message}")


console_logger = RichConsoleLogger(__name__)


def get_console_logger() -> RichConsoleLogger:
    return console_logger
get_console = get_console
print_panel = print_panel
print_table = print_table
print_syntax = print_syntax
RichConsoleLogger = RichConsoleLogger
get_console_logger = get_console_logger

# mcp.py
import os
import json
from typing import Optional, Any
from loguru import logger


class MCPError(Exception):
    """Base exception for MCP-related errors."""

    pass


class MCPClient:
    """Client for interacting with MCP servers."""

    def __init__(self, server_url: str):
        """Initialize the MCP client.

        Args:
            server_url: URL of the MCP server to connect to
        """
        self.server_url = server_url
        self.connected = False

    def connect(self) -> None:
        """Connect to the MCP server.

        Raises:
            MCPError: If connection fails
        """
        try:
            # TODO: Implement actual connection logic
            logger.info(f"Connecting to MCP server at {self.server_url}")
            self.connected = True
        except Exception as e:
            raise MCPError(f"Failed to connect to MCP server: {e}")

    def disconnect(self) -> None:
        """Disconnect from the MCP server.

        Raises:
            MCPError: If disconnection fails
        """
        try:
            # TODO: Implement actual disconnection logic
            logger.info(f"Disconnecting from MCP server at {self.server_url}")
            self.connected = False
        except Exception as e:
            raise MCPError(f"Failed to disconnect from MCP server: {e}")

    def send_request(self, request_type: str, data: dict[str, Any]) -> dict[str, Any]:
        """Send a request to the MCP server.

        Args:
            request_type: Type of request to send
            data: Request data

        Returns:
            Response from the server

        Raises:
            MCPError: If request fails
        """
        if not self.connected:
            raise MCPError("Not connected to MCP server")

        try:
            # TODO: Implement actual request logic
            logger.info(f"Sending {request_type} request to MCP server")
            return {"status": "success", "data": {}}
        except Exception as e:
            raise MCPError(f"Failed to send request to MCP server: {e}")


class MCPServer:
    """Server for handling MCP requests."""

    def __init__(self, host: str = "localhost", port: int = 8080):
        """Initialize the MCP server.

        Args:
            host: Host to bind the server to
            port: Port to bind the server to
        """
        self.host = host
        self.port = port
        self.running = False

    def start(self) -> None:
        """Start the MCP server.

        Raises:
            MCPError: If server start fails
        """
        try:
            # TODO: Implement actual server start logic
            logger.info(f"Starting MCP server on {self.host}:{self.port}")
            self.running = True
        except Exception as e:
            raise MCPError(f"Failed to start MCP server: {e}")

    def stop(self) -> None:
        """Stop the MCP server.

        Raises:
            MCPError: If server stop fails
        """
        try:
            # TODO: Implement actual server stop logic
            logger.info(f"Stopping MCP server on {self.host}:{self.port}")
            self.running = False
        except Exception as e:
            raise MCPError(f"Failed to stop MCP server: {e}")

    def process_request(self, request_type: str, data: dict[str, Any]) -> dict[str, Any]:
        """Process a request from an MCP client.

        Args:
            request_type: Type of request to process
            data: Request data

        Returns:
            Response to send to the client

        Raises:
            MCPError: If request processing fails
        """
        if not self.running:
            raise MCPError("MCP server is not running")

        try:
            # TODO: Implement actual request processing logic
            logger.info(f"Processing {request_type} request")
            return {"status": "success", "data": {}}
        except Exception as e:
            raise MCPError(f"Failed to process request: {e}")


class MCPRegistry:
    """
    Registry for MCP servers and clients.

    This class manages the registration and retrieval of MCP servers and clients.
    It provides functionality to register, unregister, and list servers and clients.
    The registry data is persisted to a JSON file.
    """

    def __init__(self, registry_file: str = None):
        """
        Initialize the MCP registry.

        Args:
            registry_file: Path to the registry file. If None, a default path is used.
        """
        if registry_file is None:
            # Use a default path in the user's home directory
            home_dir = os.path.expanduser("~")
            self.registry_file = os.path.join(home_dir, ".erasmus", "mcp_registry.json")
        else:
            self.registry_file = registry_file

        # Create the directory if it doesn't exist
        os.makedirs(os.path.dirname(self.registry_file), exist_ok=True)

        # Initialize the registry data (start fresh in-memory)
        self._load_registry()
        # Ensure clean state for servers and clients (ignore persisted file)
        self.registry = {"servers": {}, "clients": {}}

    def _load_registry(self) -> None:
        """Load the registry data from the registry file."""
        if os.path.exists(self.registry_file):
            try:
                with open(self.registry_file, "r") as f:
                    self.registry = json.load(f)
            except json.JSONDecodeError:
                # If the file is corrupted, start with an empty registry
                self.registry = {"servers": {}, "clients": {}}
        else:
            # If the file doesn't exist, start with an empty registry
            self.registry = {"servers": {}, "clients": {}}

    def _save_registry(self) -> None:
        """Save the registry data to the registry file."""
        with open(self.registry_file, "w") as f:
            json.dump(self.registry, f, indent=2)

    def register_server(self, name: str, host: str, port: int) -> None:
        """
        Register a new MCP server.

        Args:
            name: The name of the server.
            host: The host address of the server.
            port: The port number of the server.

        Raises:
            MCPError: If a server with the same name is already registered.
        """
        if name in self.registry["servers"]:
            raise MCPError(f"Server '{name}' already registered")

        self.registry["servers"][name] = {"host": host, "port": port}
        self._save_registry()

    def unregister_server(self, name: str) -> None:
        """
        Unregister an MCP server.

        Args:
            name: The name of the server to unregister.

        Raises:
            MCPError: If the server is not found.
        """
        if name not in self.registry["servers"]:
            raise MCPError(f"Server '{name}' not registered")

        # Remove any clients that were connected to this server
        clients_to_remove = []
        for client_name, client_data in self.registry["clients"].items():
            if client_data["server"] == name:
                clients_to_remove.append(client_name)

        for client_name in clients_to_remove:
            del self.registry["clients"][client_name]

        # Remove the server
        del self.registry["servers"][name]
        self._save_registry()

    def get_server(self, name: str) -> dict[str, any] | None:
        """
        Get the details of a registered MCP server.

        Args:
            name: The name of the server.

        Returns:
            A dictionary containing the server details, or None if not found.
        """
        return self.registry.get("servers", {}).get(name)

    def list_servers(self) -> list[str]:
        """
        List all registered MCP servers.

        Returns:
            A list of server names.
        """
        return list(self.registry["servers"].keys())

    def register_client(self, name: str, server: str) -> None:
        """
        Register a new MCP client.

        Args:
            name: The name of the client.
            server: The name of the server the client connects to.

        Raises:
            MCPError: If a client with the same name is already registered,
                     or if the specified server is not found.
        """
        if name in self.registry["clients"]:
            raise MCPError(f"Client '{name}' already registered")

        if server not in self.registry["servers"]:
            raise MCPError(f"Server '{server}' not registered")

        self.registry["clients"][name] = {"server": server}
        self._save_registry()

    def unregister_client(self, name: str) -> None:
        """
        Unregister an MCP client.

        Args:
            name: The name of the client to unregister.

        Raises:
            MCPError: If the client is not found.
        """
        if name not in self.registry["clients"]:
            raise MCPError(f"Client '{name}' not registered")

        del self.registry["clients"][name]
        self._save_registry()

    def get_client(self, name: str) -> dict[str, any] | None:
        """
        Get the details of a registered MCP client.

        Args:
            name: The name of the client.

        Returns:
            A dictionary containing the client details, or None if not found.
        """
        return self.registry.get("clients", {}).get(name)

    def list_clients(self) -> list[str]:
        """
        List all registered MCP clients.

        Returns:
            A list of client names.
        """
        return list(self.registry["clients"].keys())

    @property
    def servers(self) -> dict[str, Any]:
        """Dictionary of registered MCP servers."""
        return self.registry.get("servers", {})

    @property
    def clients(self) -> dict[str, Any]:
        """Dictionary of registered MCP clients."""
        return self.registry.get("clients", {})

MCPError = MCPError

# manager.py
import subprocess
from pathlib import Path
from loguru import logger

# Removed: from erasmus.utils.logging import LogContext, log_execution


class GitManager:
    """Manages Git operations for the project."""

    def __init__(self, repo_path: str | Path):
        """Initialize GitManager with a repository path."""
        logger.info("[init] Initializing GitManager")
        self.repo_path = Path(repo_path).resolve()
        logger.debug(f"Initializing GitManager with path: {self.repo_path}")
        if not self._is_git_repo():
            logger.info(f"No git repository found at {self.repo_path}, initializing new repo")
            self._init_git_repo()
        else:
            logger.debug(f"Found existing git repository at {self.repo_path}")

    def _is_git_repo(self) -> bool:
        """Check if the path is a git repository."""
        logger.info("[is_git_repo] Checking if path is a git repository")
        try:
            subprocess.run(
                ["git", "rev-parse", "--is-inside-work-tree"],
                cwd=self.repo_path,
                capture_output=True,
                check=True,
            )
            logger.debug(f"Confirmed git repository at {self.repo_path}")
            return True
        except subprocess.CalledProcessError:
            logger.debug(f"No git repository found at {self.repo_path}")
            return False

    def _init_git_repo(self) -> None:
        """Initialize a new git repository."""
        logger.info("[init_git_repo] Initializing new git repository")
        try:
            logger.debug(f"Initializing new git repository at {self.repo_path}")
            subprocess.run(
                ["git", "init"],
                cwd=self.repo_path,
                check=True,
            )

            # Configure default user
            logger.debug("Configuring default git user")
            subprocess.run(
                ["git", "config", "user.name", "Context Watcher"],
                cwd=self.repo_path,
                check=True,
            )
            subprocess.run(
                ["git", "config", "user.email", "context.watcher@local"],
                cwd=self.repo_path,
                check=True,
            )
            logger.info(f"Successfully initialized git repository at {self.repo_path}")
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to initialize git repository: {e}", exc_info=True)
            raise

    def _run_git_command(self, command: list[str]) -> tuple[str, str]:
        """Run a git command and return stdout and stderr."""
        logger.info(f"[run_git_command] Running git command: {' '.join(command)}")
        try:
            logger.debug(f"Running git command: {' '.join(command)}")
            result = subprocess.run(
                ["git", *command],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
            stdout, stderr = result.stdout.strip(), result.stderr.strip()
            if stdout:
                logger.debug(f"Command output: {stdout}")
            if stderr:
                logger.warning(f"Command stderr: {stderr}")
            return stdout, stderr
        except subprocess.CalledProcessError as e:
            logger.error(
                f"Git command failed: {' '.join(command)}",
                exc_info=True,
            )
            return "", e.stderr.strip()

    def stage_all_changes(self) -> bool:
        """Stage all changes in the repository."""
        logger.info("[stage_all_changes] Staging all changes")
        try:
            # Get status before staging
            status_before = self._run_git_command(["status", "--porcelain"])[0]
            logger.debug(f"Files to stage:\n{status_before}")

            # Stage changes
            self._run_git_command(["add", "-A"])

            # Verify staging
            status_after = self._run_git_command(["status", "--porcelain"])[0]
            staged_count = len([line for line in status_after.split("\n") if line.startswith("A ")])
            logger.info(f"Successfully staged {staged_count} changes")
            return True
        except Exception:
            logger.error("Failed to stage changes", exc_info=True)
            return False

    def commit_changes(self, message: str) -> bool:
        """Commit staged changes with a given message."""
        logger.info("[commit_changes] Attempting to commit changes")
        try:
            logger.debug(f"Attempting to commit with message: {message}")

            # First stage any changes
            if not self.stage_all_changes():
                logger.warning("No changes to commit")
                return False

            # Commit changes
            stdout, stderr = self._run_git_command(["commit", "-m", message])
            if stdout:
                logger.info(f"Successfully committed changes: {stdout}")
                return True
            logger.warning("Commit command succeeded but no output received")
            return False
        except Exception:
            logger.error("Failed to commit changes", exc_info=True)
            return False

    def get_repository_state(self) -> dict[str, list[str]]:
        """Get the current state of the repository."""
        logger.info("[get_repository_state] Getting repository state")
        try:
            # Get current branch
            branch = self.get_current_branch()
            logger.debug(f"Current branch: {branch}")

            # Get status
            status_output, _ = self._run_git_command(["status", "--porcelain"])
            status_lines = status_output.split("\n") if status_output else []
            logger.debug(f"Found {len(status_lines)} status lines")

            # Parse status
            staged = []
            unstaged = []
            untracked = []

            for line in status_lines:
                if not line:
                    continue
                status = line[:2]
                path = line[3:].strip()

                if status.startswith("??"):
                    untracked.append(path)
                    logger.debug(f"Untracked file: {path}")
                elif status[0] != " ":
                    staged.append(path)
                    logger.debug(f"Staged file: {path}")
                elif status[1] != " ":
                    unstaged.append(path)
                    logger.debug(f"Unstaged file: {path}")

            state = {
                "branch": branch,
                "staged": staged,
                "unstaged": unstaged,
                "untracked": untracked,
            }

            logger.info(
                f"Repository state - Branch: {branch}, "
                + f"Staged: {len(staged)}, "
                + f"Unstaged: {len(unstaged)}, "
                + f"Untracked: {len(untracked)}",
            )
            return state
        except Exception:
            logger.error("Failed to get repository state", exc_info=True)
            state = {
                "branch": "unknown",
                "staged": [],
                "unstaged": [],
                "untracked": [],
            }
            logger.debug("Returning empty repository state")
            return state

    def get_current_branch(self) -> str:
        """Get the name of the current branch."""
        logger.info("[get_current_branch] Getting current branch")
        try:
            branch_output, _ = self._run_git_command(["rev-parse", "--abbrev-ref", "HEAD"])
            branch = branch_output.strip()
            logger.debug(f"Current branch: {branch}")
            return branch
        except Exception:
            logger.error("Failed to get current branch", exc_info=True)
            return "unknown"


# environment.py
import re
import os
import sys
from pathlib import Path
from typing_extensions import Callable
from pydantic import BaseModel, ConfigDict, Field
from getpass import getpass
from dotenv import load_dotenv
from typing import Optional, Dict, Any
from loguru import logger

load_dotenv()


class EnvironmentError(Exception):
    """Base exception for environment configuration errors."""

    pass


def is_sensitive_variable(name: str) -> bool:
    """
    Check if a variable name contains common sensitive terms.

    Args:
        name: The variable name to check

    Returns:
        True if the variable is likely sensitive, False otherwise
    """
    sensitive_terms = [
        "key",
        "token",
        "secret",
        "password",
        "credential",
        "auth",
        "api_key",
        "access_token",
        "private",
        "ssh",
        "certificate",
    ]

    name_lower = name.lower()
    return any(term in name_lower for term in sensitive_terms)


def mask_sensitive_value(value: str) -> str:
    """
    Mask a sensitive value for display.

    Args:
        value: The value to mask

    Returns:
        Masked value (first 2 chars + 3 stars)
    """
    if not value or len(value) <= 2:
        return "***"
    return value[:2] + "***"


class VariableDefinition(BaseModel):
    """Definition of an environment variable."""

    name: str
    type: type
    required: bool = True
    default: Any = None
    validator: Callable[[Any], bool] | None = None
    min_value: Any = None
    max_value: Any = None
    pattern: str | None = None
    model_config = ConfigDict(arbitrary_types_allowed=True)

    @property
    def is_sensitive(self) -> bool:
        """Check if this variable is sensitive."""
        return is_sensitive_variable(self.name)


class EnvironmentConfig(BaseModel):
    """Manages environment configuration with validation."""

    definitions: Dict[str, VariableDefinition] = {}
    _variables: Dict[str, Any] = {}
    GITHUB_TOKEN: Optional[str] = Field(None, description="GitHub personal access token")
    ERASMUS_DEBUG: bool = Field(False, description="Enable debug logging")
    ERASMUS_LOG_LEVEL: str = Field(
        "INFO", description="Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)"
    )

    def list_variables(self):
        """List all currently defined environment variables.

        Returns:
            list: A list of dictionaries containing variable details.
        """
        for name, definition in self.definitions.items():
            if definition.is_sensitive:
                print(f"{name}: ****")
            else:
                print(f"{name}: {self._variables[name]}")

    def define_required(self, name: str, type_: type, **kwargs) -> None:
        """Define a required environment variable."""
        self.definitions[name] = VariableDefinition(name=name, type=type_, required=True, **kwargs)

    def define_optional(self, name: str, type_: type, **kwargs) -> None:
        """Define an optional environment variable."""
        self.definitions[name] = VariableDefinition(name=name, type=type_, required=False, **kwargs)

    def set(self, name: str, value: str) -> None:
        """Set an environment variable value."""
        if name not in self.definitions:
            raise EnvironmentError(f"Variable {name} not defined")

        definition = self.definitions[name]
        try:
            # Convert value to the specified type
            converted_value = definition.type(value)

            # Apply validation
            if definition.min_value is not None and converted_value < definition.min_value:
                raise EnvironmentError(
                    f"{name} must be greater than or equal to {definition.min_value}"
                )

            if definition.max_value is not None and converted_value > definition.max_value:
                raise EnvironmentError(
                    f"{name} must be less than or equal to {definition.max_value}"
                )

            if definition.pattern is not None and isinstance(converted_value, str):
                if not re.match(definition.pattern, converted_value):
                    raise EnvironmentError(f"{name} must match pattern {definition.pattern}")

            if definition.validator is not None and not definition.validator(converted_value):
                raise EnvironmentError(f"{name} failed custom validation")

            self._variables[name] = converted_value

        except (ValueError, TypeError) as e:
            raise EnvironmentError(f"Invalid value for {name}: {str(e)}")

    def get(self, name: str, default: Any = None) -> Any:
        """
        Get an environment variable value.

        Args:
            name: The variable name
            default: Default value if not found

        Returns:
            The variable value or default
        """
        if name not in self._variables:
            return default
        return self._variables[name]

    def get_masked(self, name: str) -> str:
        """
        Get a masked representation of a variable value.

        Args:
            name: The variable name

        Returns:
            Masked value if sensitive, actual value otherwise
        """
        if name not in self._variables:
            return ""

        value = self._variables[name]
        definition = self.definitions[name]

        if definition.is_sensitive and isinstance(value, str):
            return mask_sensitive_value(value)
        return str(value)

    def load_from_file(self, file_path: str | Path) -> None:
        """Load environment variables from a file."""
        file_path = Path(file_path)
        if not file_path.exists():
            raise EnvironmentError(f"Environment file not found: {file_path}")

        with open(file_path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    try:
                        name, value = line.split("=", 1)
                        name = name.strip()
                        value = value.strip()
                        self.set(name, value)
                    except ValueError:
                        continue

    def load_from_system(self) -> None:
        """Load environment variables from system environment."""
        for name, definition in self.definitions.items():
            if name in os.environ:
                self.set(name, os.environ[name])

    def prompt_for_missing(self) -> None:
        """Prompt for missing required variables."""
        for name, definition in self.definitions.items():
            if name not in self._variables and definition.required:
                if definition.is_sensitive:
                    value = getpass(f"Enter value for {name}: ")
                else:
                    value = input(f"Enter value for {name}: ")
                self.set(name, value)

    def validate(self) -> None:
        """Validate all required variables are set."""
        missing = []
        for name, definition in self.definitions.items():
            if definition.required and name not in self._variables:
                missing.append(name)

        if missing:
            raise EnvironmentError(f"Missing required variables: {', '.join(missing)}")

    def merge(self, other: "EnvironmentConfig") -> None:
        """
        Merge another config into this one.

        Args:
            other: The other config to merge
        """
        self.definitions.update(other.definitions)
        self._variables.update(other._variables)

    @classmethod
    def load(cls) -> "EnvironmentConfig":
        """Load environment configuration from environment variables."""
        env_vars = {
            "GITHUB_TOKEN": os.getenv("GITHUB_TOKEN"),
            "ERASMUS_DEBUG": os.getenv("ERASMUS_DEBUG", "false").lower() == "true",
            "ERASMUS_LOG_LEVEL": os.getenv("ERASMUS_LOG_LEVEL", "INFO").upper(),
        }

        # Configure logging based on environment
        logger.remove()  # Remove default handler
        log_level = env_vars["ERASMUS_LOG_LEVEL"]
        if env_vars["ERASMUS_DEBUG"]:
            log_level = "DEBUG"

        # Add a new handler with the correct level
        logger.add(
            sys.stderr,
            level=log_level,
            format="<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
            filter=lambda record: record["level"].name >= log_level,
        )

        return cls(**env_vars)


# Global environment configuration instance
_env_config: Optional[EnvironmentConfig] = None


def get_env_config() -> EnvironmentConfig:
    """Get the environment configuration singleton."""
    global _env_config
    if _env_config is None:
        _env_config = EnvironmentConfig.load()
    return _env_config


def is_debug_enabled() -> bool:
    """Check if debug mode is enabled."""
    return get_env_config().ERASMUS_DEBUG

EnvironmentError = EnvironmentError
is_sensitive_variable = is_sensitive_variable
mask_sensitive_value = mask_sensitive_value
VariableDefinition = VariableDefinition
EnvironmentConfig = EnvironmentConfig
get_env_config = get_env_config
is_debug_enabled = is_debug_enabled

# context.py
#!/usr/bin/env python3
"""
Simplified Context CLI for Erasmus Development Workflow with Rich Console UI.
Provides commands to list, create, edit, store, select, and load contexts using centralized path management.
"""
import re
import shutil
import subprocess
from pathlib import Path
import typer
from typing import Optional, List, Dict


context_app = typer.Typer(
    help='Context management CLI for Erasmus',
    no_args_is_help=True,
    rich_markup_mode='rich'
)
console = get_console()

logger = get_console_logger()
# central path manager
path_manager = get_path_manager()


def ensure_dir(path: Path) -> None:
    """Ensure directory exists."""
    path.mkdir(parents=True, exist_ok=True)


def display_available_contexts(contexts: List[str], title: str = 'Available Contexts') -> None:
    """Display available contexts in a rich table format."""
    if not contexts:
        print_table(['Info'], [['No contexts found']], title=title)
        return

    context_rows = [[str(i + 1), name] for i, name in enumerate(contexts)]
    print_table(['#', 'Context Name'], context_rows, title=title)


def select_context_interactive(contexts: List[str]) -> Optional[str]:
    """Interactively select a context from a list."""
    if not contexts:
        console.error('No contexts available for selection')
        return None

    display_available_contexts(contexts)
    choice = typer.prompt('Select a context by number or name')
    
    if choice.isdigit():
        index = int(choice)
        if 1 <= index <= len(contexts):
            return contexts[index - 1]
    elif choice in contexts:
        return choice
    
    console.error(f'Invalid selection: {choice}')
    return None


@context_app.command('list')
def list_contexts() -> None:
    """List all contexts for this project."""
    root = path_manager.get_context_dir()
    if not root.exists():
        console.error('No contexts found.')
        raise typer.Exit(1)
    
    contexts = [d.name for d in sorted(root.iterdir()) if d.is_dir()]
    
    # If using Warp, also show rules from the database
    if path_manager.ide == IDE.warp:
        warp_rules = path_manager.get_warp_rules()
        if warp_rules:
            print_panel("Warp Rules Found", title="Warp Integration", style="blue")
            rules_rows = [[rule[0], rule[1]] for rule in warp_rules]
            print_table(['Type', 'ID'], rules_rows, title="Warp Rules")
    
    display_available_contexts(contexts)


@context_app.command('create')
def create_context(name: Optional[str] = None) -> None:
    """Create a new context using the architecture template."""
    if not name:
        name = typer.prompt('Context name')
    
    if not name:
        console.error('Context name is required')
        raise typer.Exit(1)

    try:
        ctx_dir = path_manager.get_context_dir() / name
        ensure_dir(ctx_dir)
        
        # Create each context file with proper title
        ctx_files = [
            ('.ctx.architecture.md', path_manager.architecture_template),
            ('.ctx.tasks.md', path_manager.tasks_template),
            ('.ctx.progress.md', path_manager.progress_template)
        ]
        
        for filename, template_path in ctx_files:
            file_path = ctx_dir / filename
            if template_path.exists():
                content = template_path.read_text()
                # Replace title in template
                content = re.sub(r'<Title>.*?</Title>', f'<Title>{name}</Title>', content)
                content = re.sub(r'^# [^\n]*', f'# {name}', content)
            else:
                # Default content with title if template doesn't exist
                file_type = filename.split('.')[-2]
                content = f'# {name} {file_type.capitalize()}\n\n'
            file_path.write_text(content)
        
        # If using Warp, also create an entry in the database
        if path_manager.ide == IDE.warp:
            success = path_manager.update_warp_rules(
                document_type='CONTEXT',
                document_id=name,
                rule=content
            )
            if success:
                logger.success(f'Created context \'{name}\' in both filesystem and Warp database')
            else:
                logger.warning(f'Created context \'{name}\' in filesystem but failed to update Warp database')
        else:
            logger.success(f'Created context \'{name}\' at {ctx_dir}')
    
    except Exception as e:
        console.error(f'Failed to create context: {str(e)}')
        raise typer.Exit(1)


@context_app.command('edit')
def edit_context(name: Optional[str] = None) -> None:
    """Open context file in default editor."""
    if not name:
        contexts = [d.name for d in sorted(path_manager.get_context_dir().iterdir()) if d.is_dir()]
        name = select_context_interactive(contexts)
        if not name:
            raise typer.Exit(1)

    file_path = path_manager.get_context_dir() / name / '.ctx.architecture.md'
    if not file_path.exists():
        console.error(f'Context \'{name}\' not found.')
        raise typer.Exit(1)
    
    editor = subprocess.getoutput('which nano')  # Fallback to nano
    subprocess.run([editor, str(file_path)])
    
    # If using Warp, update the database after editing
    if path_manager.ide == IDE.warp:
        content = file_path.read_text()
        success = path_manager.update_warp_rules(
            document_type='CONTEXT',
            document_id=name,
            rule=content
        )
        if success:
            logger.success(f'Updated context \'{name}\' in both filesystem and Warp database')
        else:
            logger.warning(f'Updated context \'{name}\' in filesystem but failed to update Warp database')
    else:
        logger.success(f'Finished editing context \'{name}\'')


@context_app.command('store')
def store_context(name: Optional[str] = None) -> None:
    """Store current .ctx.* files as a new context."""
    arch = path_manager.get_architecture_file()
    if not name and arch.exists():
        text = arch.read_text()
        m = re.search(r'^#\s*Title:\s*(.+)$', text, re.MULTILINE)
        name = m.group(1).strip() if m else None

    if not name:
        name = typer.prompt('Context name')

    if not name:
        console.error('Context name is required')
        raise typer.Exit(1)

    try:
        root = path_manager.get_context_dir()
        ctx_dir = root / name
        ensure_dir(ctx_dir)
        
        for f in (
            path_manager.get_architecture_file(),
            path_manager.get_progress_file(),
            path_manager.get_tasks_file(),
        ):
            if f.exists():
                shutil.copy2(f, ctx_dir / f.name)
        
        # If using Warp, store in the database as well
        if path_manager.ide == IDE.warp:
            arch_content = path_manager.get_architecture_file().read_text()
            success = path_manager.update_warp_rules(
                document_type='CONTEXT',
                document_id=name,
                rule=arch_content
            )
            if success:
                logger.success(f'Stored context \'{name}\' in both filesystem and Warp database')
            else:
                logger.warning(f'Stored context \'{name}\' in filesystem but failed to update Warp database')
        else:
            logger.success(f'Stored context \'{name}\'')
    
    except Exception as e:
        console.error(f'Failed to store context: {str(e)}')
        raise typer.Exit(1)


@context_app.command('select')
def select_context() -> None:
    """Select and load a stored context."""
    root = path_manager.get_context_dir()
    contexts = [d.name for d in sorted(root.iterdir()) if d.is_dir()]
    
    # If using Warp, show database contexts as well
    if path_manager.ide == IDE.warp:
        warp_rules = path_manager.get_warp_rules()
        if warp_rules:
            warp_contexts = [rule[1] for rule in warp_rules if rule[0] == 'CONTEXT']
            contexts.extend([c for c in warp_contexts if c not in contexts])
    
    name = select_context_interactive(contexts)
    if not name:
        raise typer.Exit(1)

    try:
        load_context(name)
        logger.success(f'Selected and loaded context: {name}')
    except Exception as e:
        console.error(f'Failed to select context: {str(e)}')
        raise typer.Exit(1)


@context_app.command('load')
def load_context(name: str) -> None:
    """Load stored context files into current directory."""
    ctx_dir = path_manager.get_context_dir() / name
    
    try:
        if ctx_dir.exists():
            for f in ctx_dir.glob('*.md'):
                dest = Path.cwd() / f.name
                shutil.copy2(f, dest)
            logger.success(f'Loaded context \'{name}\' from filesystem')
            return
        elif path_manager.ide == IDE.warp:
            # Try loading from Warp database
            warp_rules = path_manager.get_warp_rules()
            if warp_rules:
                context_rule = next(
                    (rule for rule in warp_rules if rule[0] == 'CONTEXT' and rule[1] == name),
                    None
                )
                if context_rule:
                    dest = Path.cwd() / '.ctx.architecture.md'
                    dest.write_text(context_rule[2])
                    logger.success(f'Loaded context \'{name}\' from Warp database')
                    return
        
        console.error(f'Context \'{name}\' not found.')
        raise typer.Exit(1)
        
    except Exception as e:
        console.error(f'Failed to load context: {str(e)}')
        raise typer.Exit(1)



ensure_dir = ensure_dir
display_available_contexts = display_available_contexts
select_context_interactive = select_context_interactive
list_contexts = list_contexts
create_context = create_context
edit_context = edit_context
store_context = store_context
select_context = select_context
load_context = load_context

# protocol.py
from pathlib import Path
from typing import Optional
from pydantic import BaseModel
from loguru import logger


path_manager = get_path_manager()


class ProtocolError(Exception):
    """Exception raised for protocol-related errors."""

    pass


class ProtocolModel(BaseModel):
    """
    Represents a protocol, including its name, path, and content.
    """

    name: str
    path: str
    content: str


class ProtocolManager:
    """
    Manages protocol files for Erasmus.
    Loads base protocol templates from erasmus.erasmus/templates/protocols and custom user protocols from erasmus.erasmus/protocol.
    Provides methods to list, get, create, update, and delete protocols.
    """

    def __init__(self, base_dir: str | None = None, user_dir: str | None = None) -> None:
        # Always use path_manager.template_dir / 'protocols' unless base_dir is explicitly provided
        self.base_template_dir: Path = (
            Path(base_dir) if base_dir is not None else path_manager.template_dir / "protocols"
        )
        self.user_protocol_dir: Path = Path(user_dir) if user_dir else path_manager.protocol_dir
        self.base_template_dir.mkdir(parents=True, exist_ok=True)
        self.user_protocol_dir.mkdir(parents=True, exist_ok=True)
        logger.info(
            f"Initialized ProtocolManager with base template dir: {self.base_template_dir} and user protocol dir: {self.user_protocol_dir}"
        )

    def _sanitize_name(self, protocol_name: str) -> str:
        """Sanitize a protocol name for filesystem use."""
        return _sanitize_string(protocol_name)

    def _get_protocol_path(self, protocol_name: str, is_template: bool = False) -> Path:
        """
        Get the path for a protocol file.
        Args:
            protocol_name: The protocol name
            is_template: If True, look in the template directory; else, user directory
        Returns:
            Path to the protocol file
        """
        sanitized_name = self._sanitize_name(protocol_name)
        directory = self.base_template_dir if is_template else self.user_protocol_dir
        return directory / f"{sanitized_name}.md"

    def list_protocols(
        self, include_templates: bool = True, include_user: bool = True
    ) -> list[str]:
        """
        List all available protocol names.
        Args:
            include_templates: Include base templates
            include_user: Include user protocols
        Returns:
            List of protocol names
        """
        protocol_names = set()
        if include_templates:
            protocol_names.update(
                [protocol_path.stem for protocol_path in self.base_template_dir.glob("*.md")]
            )
        if include_user:
            protocol_names.update(
                [protocol_path.stem for protocol_path in self.user_protocol_dir.glob("*.md")]
            )
        return sorted(protocol_names)

    def get_protocol(self, protocol_name: str) -> ProtocolModel | None:
        """
        Get a protocol by name, searching user protocols first, then templates.
        Args:
            protocol_name: The protocol name
        Returns:
            ProtocolModel if found, else None
        """
        sanitized_name = self._sanitize_name(protocol_name)
        user_path = self._get_protocol_path(sanitized_name, is_template=False)
        template_path = self._get_protocol_path(sanitized_name, is_template=True)
        if user_path.exists():
            content = user_path.read_text()
            return ProtocolModel(name=sanitized_name, path=str(user_path), content=content)
        elif template_path.exists():
            content = template_path.read_text()
            return ProtocolModel(name=sanitized_name, path=str(template_path), content=content)
        else:
            return None

    def create_protocol(self, protocol_name: str, content: str) -> ProtocolModel:
        """
        Create a new user protocol.
        Args:
            protocol_name: The protocol name
            content: The protocol content
        Returns:
            The created ProtocolModel
        Raises:
            FileExistsError: If a user protocol with the same name already exists
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        if protocol_path.exists():
            raise FileExistsError(f"Protocol '{sanitized_name}' already exists.")
        # Use template if content is not provided or empty
        if not isinstance(content, str) or not content.strip():
            template_path = path_manager.template_dir / "protocol.md"
            if template_path.exists():
                content = template_path.read_text()
            else:
                content = '<?xml version="1.0" encoding="UTF-8"?>\n<Protocol></Protocol>'
        else:
            # If content is not valid XML, wrap it in <Protocol>...</Protocol>
            import xml.etree.ElementTree as ET

            try:
                ET.fromstring(content)
            except Exception:
                content = f'<?xml version="1.0" encoding="UTF-8"?>\n<Protocol>{content}</Protocol>'
        protocol_path.write_text(_sanitize_xml_content(content))
        logger.info(f"Created protocol: {sanitized_name}")
        return ProtocolModel(name=sanitized_name, path=str(protocol_path), content=content)

    def update_protocol(self, protocol_name: str, content: str) -> ProtocolModel:
        """
        Update an existing user protocol.
        Args:
            protocol_name: The protocol name
            content: The new protocol content
        Returns:
            The updated ProtocolModel
        Raises:
            FileNotFoundError: If the protocol does not exist in user protocols
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        if not protocol_path.exists():
            raise FileNotFoundError(f"Protocol '{sanitized_name}' not found in user protocols.")
        # Ensure content is a valid XML string
        if not isinstance(content, str) or not content.strip():
            content = '<?xml version="1.0" encoding="UTF-8"?>\n<Protocol></Protocol>'
        else:
            import xml.etree.ElementTree as ET

            try:
                ET.fromstring(content)
            except Exception:
                content = f'<?xml version="1.0" encoding="UTF-8"?>\n<Protocol>{content}</Protocol>'
        protocol_path.write_text(_sanitize_xml_content(content))
        logger.info(f"Updated protocol: {sanitized_name}")
        return ProtocolModel(name=sanitized_name, path=str(protocol_path), content=content)

    def delete_protocol(self, protocol_name: str) -> None:
        """
        Delete a user protocol.
        Args:
            protocol_name: The protocol name
        Raises:
            FileNotFoundError: If the protocol does not exist in user protocols
            PermissionError: If attempting to delete a template protocol
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        template_path = self._get_protocol_path(sanitized_name, is_template=True)
        # Prevent deletion if protocol is a template
        if template_path.exists():
            raise PermissionError(
                f"Cannot delete template protocol: '{sanitized_name}'. Only custom (user) protocols can be deleted."
            )
        if not protocol_path.exists():
            raise FileNotFoundError(f"Protocol '{sanitized_name}' not found in user protocols.")
        protocol_path.unlink()
        logger.info(f"Deleted protocol: {sanitized_name}")

ProtocolError = ProtocolError
ProtocolModel = ProtocolModel

# file_monitor.py
import os
import time
from typing import Optional, Set
from watchdog.observers import ObserverType, Observer
from watchdog.events import FileSystemEventHandler, FileSystemEvent
from loguru import logger
from pathlib import Path


import re

import xml.etree.ElementTree as ET
import fnmatch

# Add a global to track last rules file write time
_last_rules_write_time = None


def _merge_rules_file() -> None:
    # Split this function into smaller functions in a future refactor
    # Current complexity is necessary for handling various file states and formats
    """
    Merge current .ctx files into the IDE rules file using the meta_rules.md template.
    Refreshes IDE detection to ensure correct rules file is used.
    Overwrites the rules file every time with a fresh merge of the template and current context/protocol content.
    Prompts the user to select a protocol if none is set or the file is missing.
    """


    global _last_rules_write_time

    detected_ide = detect_ide_from_env()
    path_manager = get_path_manager(detected_ide)
    template_path = path_manager.template_dir / "meta_rules.md"
    rules_file_path = path_manager.get_rules_file()
    if not template_path.exists():
        # No template available: fallback to raw merge of ctx files
        logger.warning(f"Template file not found: {template_path}; falling back to raw merge")
        try:
            architecture_text = path_manager.get_architecture_file().read_text()
            progress_text = path_manager.get_progress_file().read_text()
            tasks_text = path_manager.get_tasks_file().read_text()
            merged_content = "\n".join([architecture_text, progress_text, tasks_text])
            if not rules_file_path:
                logger.warning("No rules file configured; skipping local merge")
            else:
                rules_file_path.write_text(merged_content)
                _last_rules_write_time = rules_file_path.stat().st_mtime
                logger.info(f"Updated local rules file (fallback): {rules_file_path}")
        except Exception as exception:
            logger.error(f"Error during fallback merge: {exception}")
        return
    try:
        # Always start from a fresh template
        template_content = template_path.read_text()

        # Read context files with proper error handling
        def read_file_content(file_path: Path) -> str:
            try:
                if file_path.exists() and file_path.stat().st_size > 0:
                    return file_path.read_text().strip()
                return ""
            except Exception as e:
                logger.error(f"Error reading {file_path}: {e}")
                return ""

        architecture = read_file_content(path_manager.get_architecture_file())
        progress = read_file_content(path_manager.get_progress_file())
        tasks = read_file_content(path_manager.get_tasks_file())

        # Update sections only if content exists
        def update_section(content: str, section_name: str) -> str:
            pattern = f"## {section_name}\\s*<!--.*?-->\\s*(?=## |$)"
            replacement = (
                f"## {section_name}\n{content}\n"
                if content
                else f"## {section_name}\n<!-- {section_name.lower()} content -->\n"
            )
            return re.sub(pattern, replacement, merged_content, flags=re.MULTILINE | re.DOTALL)

        merged_content = template_content
        merged_content = update_section(architecture, "Architecture")
        merged_content = update_section(progress, "Progress")
        merged_content = update_section(tasks, "Tasks")

        # Handle protocol content
        protocol_value = ""
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        protocol_manager = ProtocolManager()
        protocol_name = None
        if current_protocol_path.exists():
            protocol_name = current_protocol_path.read_text().strip()
        protocol_file = None
        if protocol_name:
            # Clean up protocol name and ensure .md extension
            protocol_name = protocol_name.replace(".xml", "").replace(".md", "") + ".md"
            protocol_file = path_manager.protocol_dir / protocol_name
            print(f"[DEBUG] Loaded protocol name: '{protocol_name}'")
            print(f"[DEBUG] Checking protocol file: {protocol_file}")
            # Fallback to template protocols if not found in user protocol dir
            if not protocol_file.exists():
                template_protocol_file = path_manager.template_dir / "protocols" / protocol_name
                print(f"[DEBUG] Checking template protocol file: {template_protocol_file}")
                # Also check without .md extension for backward compatibility
                if not template_protocol_file.exists():
                    base_name = protocol_name.replace(".md", "")
                    template_protocol_file = path_manager.template_dir / "protocols" / base_name
                if template_protocol_file.exists():
                    protocol_file = template_protocol_file
                # No need to reassign protocol_file, it's already set correctly
        if not protocol_name or not protocol_file or not protocol_file.exists():
            # Try to extract protocol from the existing rules file using XML parsing
            if rules_file_path and rules_file_path.exists():
                try:
                    tree = ET.parse(rules_file_path)
                    root = tree.getroot()
                    # Try to find <Protocol> block
                    protocol_elem = root.find(".//Protocol")
                    if protocol_elem is not None:
                        protocol_value = ET.tostring(protocol_elem, encoding="unicode")
                        print("[DEBUG] Extracted protocol from existing rules file.")
                except Exception as e:
                    print(f"[DEBUG] Failed to extract protocol from rules file: {e}")
            if not protocol_value:
                # Prompt user to select a protocol
                protocols = protocol_manager.list_protocols()
                if not protocols:
                    logger.error("No protocols found. Cannot update rules file.")
                    return
                print("Available protocols:")
                for idx, pname in enumerate(protocols):
                    print(f"  {idx + 1}. {pname}")
                while True:
                    choice = input("Select a protocol by number or name: ").strip()
                    selected = None
                    if choice.isdigit():
                        idx = int(choice)
                        if 1 <= idx <= len(protocols):
                            selected = protocols[idx - 1]
                    elif choice in protocols:
                        selected = choice
                    if selected:
                        protocol_name = selected.strip()
                        current_protocol_path.write_text(protocol_name)
                        protocol_file = path_manager.protocol_dir / f"{protocol_name}.md"
                        print(f"[DEBUG] User selected protocol: '{protocol_name}'")
                        print(f"[DEBUG] Checking protocol file: {protocol_file}")
                        # Fallback to template protocols if not found in user protocol dir
                        if not protocol_file.exists():
                            template_protocol_file = (
                                path_manager.template_dir / "protocols" / f"{protocol_name}.md"
                            )
                            print(
                                f"[DEBUG] Checking template protocol file: {template_protocol_file}"
                            )
                            if template_protocol_file.exists():
                                protocol_file = template_protocol_file
                        if protocol_file.exists():
                            protocol_value = protocol_file.read_text()
                        else:
                            print(f"Protocol file not found: {protocol_file}")
                            continue
                        break
                    print(f"Invalid selection: {choice}")
        else:
            if protocol_file and protocol_file.exists():
                protocol_value = read_file_content(protocol_file)
                if protocol_value:
                    protocol_value = f"<!--PROTOCOL-->\n{protocol_value}\n<!--/PROTOCOL-->"
                else:
                    protocol_value = "<!--PROTOCOL-->\n<!-- Protocol content -->\n<!--/PROTOCOL-->"

        merged_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->",
            protocol_value or "<!--PROTOCOL-->\n<!-- Protocol content -->\n<!--/PROTOCOL-->",
            merged_content,
            flags=re.MULTILINE | re.DOTALL,
        )

        # Overwrite the rules file with the merged content
        if not rules_file_path:
            logger.warning("No rules file configured; skipping local merge")
        else:
            # Ensure consistent line endings
            merged_content = merged_content.replace("\r\n", "\n")
            rules_file_path.write_text(merged_content)
            _last_rules_write_time = rules_file_path.stat().st_mtime
            logger.info(f"Updated local rules file: {rules_file_path}")
    except Exception as exception:
        logger.error(f"Error merging rules file: {exception}")


class FileEventHandler(FileSystemEventHandler):
    """
    Handles file system events with debouncing.
    """

    def __init__(self, debounce_time: float = 0.1) -> None:
        """
        Initialize the event handler.
        Args:
            debounce_time: Time in seconds to wait before processing duplicate events
        """
        super().__init__()
        self.debounce_time: float = debounce_time
        self.processed_events: Set[str] = set()
        self.last_processed: dict[str, float] = {}
        self.on_created = None
        self.on_modified = None
        self.on_deleted = None
        self.ignore_directory_events = False

    def _should_process_event(self, event: FileSystemEvent) -> bool:
        """
        Check if an event should be processed based on debouncing and filtering.
        Args:
            event: The file system event
        Returns:
            bool: True if event should be processed
        """
        # Skip directory events if configured
        if self.ignore_directory_events and event.is_directory:
            return False

        current_time = time.time()
        event_key = f"{event.event_type}:{event.src_path}"

        # Check if this is a duplicate event within debounce time
        if event_key in self.last_processed:
            if current_time - self.last_processed[event_key] < self.debounce_time:
                return False

        self.last_processed[event_key] = current_time
        return True

    def on_created(self, event: FileSystemEvent) -> None:
        """
        Handle file creation events.
        Args:
            event: The file system event
        """
        if self._should_process_event(event):
            if self.on_created:
                self.on_created(event)
                # For directory creation, also emit an event for the parent directory
                if event.is_directory:
                    parent_dir = os.path.dirname(event.src_path)
                    if parent_dir:
                        parent_event = FileSystemEvent(
                            event_type="created", src_path=parent_dir, is_directory=True
                        )
                        if self.on_created:
                            self.on_created(parent_event)

    def on_modified(self, event: FileSystemEvent) -> None:
        """
        Handle file modification events.
        Args:
            event: The file system event
        """
        if self._should_process_event(event):
            if self.on_modified:
                self.on_modified(event)
                # For file modification, also emit an event for the parent directory
                if not event.is_directory:
                    parent_dir = os.path.dirname(event.src_path)
                    if parent_dir:
                        parent_event = FileSystemEvent(
                            event_type="modified", src_path=parent_dir, is_directory=True
                        )
                        if self.on_modified:
                            self.on_modified(parent_event)

    def on_deleted(self, event: FileSystemEvent) -> None:
        """
        Handle file deletion events.
        Args:
            event: The file system event
        """
        if self._should_process_event(event):
            if self.on_deleted:
                # Process the original event first
                self.on_deleted(event)
                # For file deletion, also emit an event for the parent directory
                if not event.is_directory:
                    parent_dir = os.path.dirname(event.src_path)
                    if parent_dir:
                        parent_event = FileSystemEvent(
                            event_type="deleted", src_path=parent_dir, is_directory=True
                        )
                        self.on_deleted(parent_event)
                # For directory deletion, also emit an event for the parent directory
                elif event.is_directory:
                    parent_dir = os.path.dirname(event.src_path)
                    if parent_dir:
                        parent_event = FileSystemEvent(
                            event_type="deleted", src_path=parent_dir, is_directory=True
                        )
                        self.on_deleted(parent_event)


class FileMonitor:
    """
    Monitors file system events and updates rules files.
    """

    def __init__(self) -> None:
        """Initialize the file monitor."""
        self.pm = get_path_manager()
        self.debug = is_debug_enabled()
        if self.debug:
            logger.info(f"Initialized FileMonitor with path manager: {self.pm}")
        self.observer = Observer()
        self.event_handler = FileEventHandler()
        self.watch_paths: dict[str, bool] = {
            str(self.pm.architecture_file): True,
            str(self.pm.progress_file): True,
            str(self.pm.tasks_file): True,
        }  # path -> recursive
        if self.debug:
            logger.info(f"Watch paths configured: {self.watch_paths}")
        self.ignore_patterns: list[str] = []
        self.on_created = None
        self.on_modified = None
        self.on_deleted = None
        self._is_running = False
        self._last_merge_time = 0
        self._merge_debounce = 0.5  # Debounce time for merging rules

    def _should_merge_rules(self) -> bool:
        """Check if enough time has passed since last merge."""
        current_time = time.time()
        should_merge = current_time - self._last_merge_time > self._merge_debounce
        if should_merge:
            if self.debug:
                logger.debug("Debounce period passed, will merge rules")
            self._last_merge_time = current_time
        elif self.debug:
            logger.debug("Within debounce period, skipping merge")
        return should_merge

    def _handle_context_change(self, event: FileSystemEvent) -> None:
        """Handle changes to context files."""
        if self.debug:
            logger.info(f"Handling context change event: {event.event_type} - {event.src_path}")
        if self._matches_rules_file(event.src_path):
            if self.debug:
                logger.debug(f"Ignoring rules file change: {event.src_path}")
            return

        if self._should_merge_rules():
            logger.info(f"Merging rules due to context file change: {event.src_path}")
            try:
                _merge_rules_file()
                logger.info("Rules merge completed successfully")
            except Exception as e:
                logger.error(f"Error merging rules: {e}")

    def add_watch_path(self, watch_path: str | Path, recursive: bool = False) -> None:
        """Add a path to monitor."""
        watch_path = str(Path(watch_path).resolve())
        if not os.path.exists(watch_path):
            raise FileMonitorError(f"Watch path does not exist: {watch_path}")
        self.watch_paths[watch_path] = recursive
        if self._is_running:
            self.observer.schedule(self.event_handler, watch_path, recursive=recursive)
            logger.info(f"Added watch path: {watch_path}")

    def remove_watch_path(self, watch_path: str | Path) -> None:
        """Remove a monitored path."""
        watch_path = str(Path(watch_path).resolve())
        if watch_path in self.watch_paths:
            del self.watch_paths[watch_path]
            if self._is_running:
                # Find and remove the watch for this path
                for watch in list(self.observer._watches.values()):
                    if watch.path == watch_path:
                        self.observer.unschedule(watch)
                        logger.info(f"Removed watch path: {watch_path}")
                        break

    def add_ignore_pattern(self, pattern: str) -> None:
        """Add a pattern to ignore."""
        self.ignore_patterns.append(pattern)
        logger.info(f"Added ignore pattern: {pattern}")

    def _matches_ignore_pattern(self, file_path: str) -> bool:
        """Check if a file path matches any ignore pattern."""
        return any(fnmatch.fnmatch(file_path, pattern) for pattern in self.ignore_patterns)

    def _matches_rules_file(self, file_path: str) -> bool:
        """Check if a file path matches any rules file pattern."""
        rules_patterns = [
            r"\.codex\.md$",
            r"\.cursorrules$",
            r"\.windsurfrules$",
            r"CLAUDE\.md$",
        ]
        matches = any(re.search(pattern, file_path) for pattern in rules_patterns)
        if matches and self.debug:
            logger.debug(f"File matches rules pattern: {file_path}")
        return matches

    def start(self) -> None:
        """Start monitoring."""
        if not self.watch_paths:
            raise FileMonitorError("No watch paths configured")

        if self._is_running:
            logger.warning("Monitor is already running")
            return

        logger.info("Starting file monitor...")

        # Set up event handlers
        def on_created_wrapper(event):
            if self.debug:
                logger.debug(f"Created event received: {event.src_path}")
            if self._matches_ignore_pattern(event.src_path):
                if self.debug:
                    logger.debug(f"Ignoring created event due to pattern match: {event.src_path}")
                return
            self._handle_context_change(event)
            if self.on_created:
                self.on_created(event)

        def on_modified_wrapper(event):
            if self.debug:
                logger.debug(f"Modified event received: {event.src_path}")
            if self._matches_ignore_pattern(event.src_path):
                if self.debug:
                    logger.debug(f"Ignoring modified event due to pattern match: {event.src_path}")
                return
            self._handle_context_change(event)
            if self.on_modified:
                self.on_modified(event)

        def on_deleted_wrapper(event):
            if self.debug:
                logger.debug(f"Deleted event received: {event.src_path}")
            if self._matches_ignore_pattern(event.src_path):
                if self.debug:
                    logger.debug(f"Ignoring deleted event due to pattern match: {event.src_path}")
                return
            self._handle_context_change(event)
            if self.on_deleted:
                self.on_deleted(event)

        self.event_handler.on_created = on_created_wrapper
        self.event_handler.on_modified = on_modified_wrapper
        self.event_handler.on_deleted = on_deleted_wrapper

        # Start observer for each watch path
        for watch_path, recursive in self.watch_paths.items():
            # Ensure the watch path exists
            if not os.path.exists(watch_path):
                logger.warning(f"Watch path does not exist, creating: {watch_path}")
                os.makedirs(os.path.dirname(watch_path), exist_ok=True)
                Path(watch_path).touch()

            # Schedule the watch
            try:
                self.observer.schedule(
                    self.event_handler, os.path.dirname(watch_path), recursive=recursive
                )
                logger.info(f"Started monitoring: {watch_path} (recursive={recursive})")
            except Exception as e:
                logger.error(f"Failed to schedule watch for {watch_path}: {e}")

        try:
            self.observer.start()
            logger.info("File monitor observer started successfully")
        except Exception as e:
            logger.error(f"Failed to start observer: {e}")
            return

        self._is_running = True

        # Initial merge of rules
        logger.info("Performing initial rules merge...")
        try:
            _merge_rules_file()
            logger.info("Initial rules merge completed successfully")
        except Exception as e:
            logger.error(f"Error during initial rules merge: {e}")

    def stop(self) -> None:
        """Stop monitoring."""
        if not self._is_running:
            logger.warning("Monitor is not running")
            return

        logger.info("Stopping file monitor...")
        if self.observer.is_alive():
            try:
                self.observer.stop()
                self.observer.join()
                self.observer = Observer()  # Create a new observer for next start
                for watch_path in self.watch_paths:
                    logger.info(f"Stopped monitoring: {watch_path}")
                logger.info("File monitor stopped successfully")
            except Exception as e:
                logger.error(f"Error stopping observer: {e}")
        self._is_running = False

    def __enter__(self) -> "FileMonitor":
        """Start monitoring when entering context."""
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Stop monitoring when exiting context."""
        self.stop()


class FileMonitorError(Exception):
    """Base exception for file monitor errors."""


class ContextFileMonitor:
    """Monitors .ctx files and updates the rules file."""

    def __init__(self) -> None:
        """Initialize the context file monitor."""

        from loguru import logger

        self.path_manager = get_path_manager()
        self.observer = Observer()
        self.handler = ContextFileHandler()
        self.root_dir = self.path_manager.get_root_dir()
        self.logger = logger

    def start(self) -> None:
        """Start monitoring context files."""
        try:
            # Watch the root directory for .ctx files
            self.observer.schedule(self.handler, str(self.root_dir), recursive=False)
            self.observer.start()
            self.logger.info(f"Started monitoring {self.root_dir} for .ctx file changes")

            # Initial merge of rules file
            _merge_rules_file()
            self.logger.info("Initial rules file merge completed")

        except Exception as e:
            self.logger.error(f"Error starting context file monitor: {e}")
            raise FileMonitorError(f"Failed to start context file monitor: {e}")

    def stop(self) -> None:
        """Stop monitoring context files."""
        try:
            self.observer.stop()
            self.observer.join()
            self.logger.info("Stopped context file monitor")
        except Exception as e:
            self.logger.error(f"Error stopping context file monitor: {e}")

    def __enter__(self) -> "ContextFileMonitor":
        """Start monitoring when entering context."""
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Stop monitoring when exiting context."""
        self.stop()


class ContextFileHandler(FileSystemEventHandler):
    """Handles file system events for context files."""

    def __init__(self, debounce_time: float = 0.5) -> None:
        """Initialize the context file handler.

        Args:
            debounce_time: Time in seconds to wait before processing duplicate events
        """
        super().__init__()
        self.debounce_time = debounce_time
        self.last_processed = {}
        from loguru import logger

        self.logger = logger

    def _should_process_event(self, event: FileSystemEvent) -> bool:
        """Check if an event should be processed.

        Args:
            event: The file system event

        Returns:
            bool: True if the event should be processed
        """
        if event.is_directory:
            return False

        # Only process .ctx.*.md files
        if not str(event.src_path).endswith(".md") or ".ctx." not in str(event.src_path):
            return False

        current_time = time.time()
        if event.src_path in self.last_processed:
            if current_time - self.last_processed[event.src_path] < self.debounce_time:
                return False

        self.last_processed[event.src_path] = current_time
        return True

    def on_modified(self, event: FileSystemEvent) -> None:
        """Handle file modification events.

        Args:
            event: The file system event
        """
        if self._should_process_event(event):
            try:
                self.logger.info(f"Context file modified: {event.src_path}")
                _merge_rules_file()
                self.logger.info("Rules file updated")
            except Exception as e:
                self.logger.error(f"Error handling context file modification: {e}")

    def on_created(self, event: FileSystemEvent) -> None:
        """Handle file creation events.

        Args:
            event: The file system event
        """
        if self._should_process_event(event):
            try:
                self.logger.info(f"Context file created: {event.src_path}")
                _merge_rules_file()
                self.logger.info("Rules file updated")
            except Exception as e:
                self.logger.error(f"Error handling context file creation: {e}")

    def on_deleted(self, event: FileSystemEvent) -> None:
        """Handle file deletion events.

        Args:
            event: The file system event
        """
        if self._should_process_event(event):
            try:
                self.logger.info(f"Context file deleted: {event.src_path}")
                _merge_rules_file()
                self.logger.info("Rules file updated")
            except Exception as e:
                self.logger.error(f"Error handling context file deletion: {e}")

FileEventHandler = FileEventHandler
FileMonitorError = FileMonitorError
ContextFileHandler = ContextFileHandler

# github_mcp_commands.py
import json
import subprocess
import typer
from typing import List, Dict, Any
from loguru import logger


github_app = typer.Typer(help="Interact with GitHub through the MCP server.")


def _send_mcp_request(method: str, params: Dict[str, Any]) -> Dict[str, Any]:
    """Send a request to the GitHub MCP server.

    Args:
        method: The method name to call
        params: The parameters to send

    Returns:
        The response from the server

    Raises:
        typer.Exit: If the request fails
    """
    request = {"jsonrpc": "2.0", "id": 1, "method": method, "params": params}

    try:
        # Start the MCP server process
        process = subprocess.Popen(
            ["./erasmus/mcp/servers/github/server", "stdio"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        # Send the request
        request_str = json.dumps(request)
        stdout, stderr = process.communicate(input=request_str)

        if process.returncode != 0:
            logger.error(f"MCP server error: {stderr}")
            raise typer.Exit(1)

        # Parse the response
        response = None
        for line in stdout.split("\n"):
            try:
                obj = json.loads(line)
                response = obj
                break
            except Exception:
                continue
        if not response:
            logger.error(f"No valid JSON response from MCP server. Raw output: {stdout}")
            raise typer.Exit(1)
        if "error" in response:
            logger.error(f"MCP server error: {response['error']}")
            raise typer.Exit(1)
        return response["result"]

    except Exception as e:
        logger.error(f"Failed to send MCP request: {e}")
        raise typer.Exit(1)


# Issue commands
@github_app.command()
def create_issue(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    title: str = typer.Option(..., help="Issue title"),
    body: str = typer.Option(None, help="Issue body"),
    labels: List[str] = typer.Option(None, help="Issue labels"),
    assignees: List[str] = typer.Option(None, help="Issue assignees"),
):
    """Create a new issue in a GitHub repository."""
    params = {
        "owner": owner,
        "repo": repo,
        "title": title,
        "body": body,
        "labels": labels,
        "assignees": assignees,
    }
    result = _send_mcp_request("create_issue", params)
    logger.info(f"Created issue #{result['number']}: {result['html_url']}")


@github_app.command()
def get_issue(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Issue number"),
):
    """Get details of a specific issue in a GitHub repository."""
    params = {"owner": owner, "repo": repo, "number": number}
    result = _send_mcp_request("get_issue", params)
    print_table(
        ["Field", "Value"],
        [
            ["Number", result["number"]],
            ["Title", result["title"]],
            ["State", result["state"]],
            ["Created", result["created_at"]],
            ["Updated", result["updated_at"]],
            ["URL", result["html_url"]],
        ],
        title=f"Issue #{number}",
    )


@github_app.command()
def list_issues(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    state: str = typer.Option("open", help="Issue state (open, closed, all)"),
    labels: List[str] = typer.Option(None, help="Filter by labels"),
    assignee: str = typer.Option(None, help="Filter by assignee"),
    creator: str = typer.Option(None, help="Filter by creator"),
    mentioned: str = typer.Option(None, help="Filter by mentioned user"),
    since: str = typer.Option(None, help="Filter by updated date (YYYY-MM-DD)"),
):
    """List issues in a GitHub repository with filtering options."""
    params = {
        "owner": owner,
        "repo": repo,
        "state": state,
        "labels": labels,
        "assignee": assignee,
        "creator": creator,
        "mentioned": mentioned,
        "since": since,
    }
    result = _send_mcp_request("list_issues", params)
    if not result:
        logger.info("No issues found")
        return
    rows = [
        [issue["number"], issue["title"], issue["state"], issue["created_at"]] for issue in result
    ]
    print_table(
        ["Number", "Title", "State", "Created"],
        rows,
        title=f"Issues in {owner}/{repo}",
    )


@github_app.command()
def update_issue(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Issue number"),
    title: str = typer.Option(None, help="New issue title"),
    body: str = typer.Option(None, help="New issue body"),
    state: str = typer.Option(None, help="New issue state (open, closed)"),
    labels: List[str] = typer.Option(None, help="New issue labels"),
    assignees: List[str] = typer.Option(None, help="New issue assignees"),
):
    """Update an existing issue in a GitHub repository."""
    params = {
        "owner": owner,
        "repo": repo,
        "number": number,
        "title": title,
        "body": body,
        "state": state,
        "labels": labels,
        "assignees": assignees,
    }
    result = _send_mcp_request("update_issue", params)
    logger.info(f"Updated issue #{number}: {result['html_url']}")


@github_app.command()
def add_issue_comment(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Issue number"),
    body: str = typer.Option(..., help="Comment body"),
):
    """Add a comment to an existing issue."""
    params = {
        "owner": owner,
        "repo": repo,
        "number": number,
        "body": body,
    }
    result = _send_mcp_request("add_issue_comment", params)
    logger.info(f"Added comment to issue #{number}: {result['html_url']}")


@github_app.command()
def get_issue_comments(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Issue number"),
):
    """Get comments for a GitHub issue."""
    params = {"owner": owner, "repo": repo, "number": number}
    result = _send_mcp_request("get_issue_comments", params)
    if not result:
        logger.info("No comments found")
        return
    rows = [
        [comment["user"]["login"], comment["created_at"], comment["body"][:50] + "..."]
        for comment in result
    ]
    print_table(
        ["Author", "Created", "Comment"],
        rows,
        title=f"Comments on Issue #{number}",
    )


# Pull Request commands
@github_app.command()
def create_pr(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    title: str = typer.Option(..., help="Pull request title"),
    head: str = typer.Option(..., help="The branch with changes"),
    base: str = typer.Option("main", help="The branch to merge into"),
    body: str = typer.Option(None, help="Pull request description"),
    draft: bool = typer.Option(False, help="Create as draft pull request"),
):
    """Create a new pull request in a GitHub repository."""
    params = {
        "owner": owner,
        "repo": repo,
        "title": title,
        "head": head,
        "base": base,
        "body": body,
        "draft": draft,
    }
    result = _send_mcp_request("create_pull_request", params)
    logger.info(f"Created pull request #{result['number']}: {result['html_url']}")


@github_app.command()
def get_pr(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
):
    """Get details of a specific pull request."""
    params = {"owner": owner, "repo": repo, "number": number}
    result = _send_mcp_request("get_pull_request", params)
    print_table(
        ["Field", "Value"],
        [
            ["Number", result["number"]],
            ["Title", result["title"]],
            ["State", result["state"]],
            ["Created", result["created_at"]],
            ["Updated", result["updated_at"]],
            ["Head", result["head"]["ref"]],
            ["Base", result["base"]["ref"]],
            ["URL", result["html_url"]],
        ],
        title=f"Pull Request #{number}",
    )


@github_app.command()
def list_prs(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    state: str = typer.Option("open", help="PR state (open, closed, all)"),
    head: str = typer.Option(None, help="Filter by head branch"),
    base: str = typer.Option(None, help="Filter by base branch"),
    sort: str = typer.Option("created", help="Sort by (created, updated, popularity)"),
    direction: str = typer.Option("desc", help="Sort direction (asc, desc)"),
):
    """List and filter repository pull requests."""
    params = {
        "owner": owner,
        "repo": repo,
        "state": state,
        "head": head,
        "base": base,
        "sort": sort,
        "direction": direction,
    }
    result = _send_mcp_request("list_pull_requests", params)
    if not result:
        logger.info("No pull requests found")
        return
    rows = [[pr["number"], pr["title"], pr["state"], pr["created_at"]] for pr in result]
    print_table(
        ["Number", "Title", "State", "Created"],
        rows,
        title=f"Pull Requests in {owner}/{repo}",
    )


@github_app.command()
def update_pr(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
    title: str = typer.Option(None, help="New PR title"),
    body: str = typer.Option(None, help="New PR body"),
    state: str = typer.Option(None, help="New PR state (open, closed)"),
    base: str = typer.Option(None, help="New base branch"),
):
    """Update an existing pull request in a GitHub repository."""
    params = {
        "owner": owner,
        "repo": repo,
        "number": number,
        "title": title,
        "body": body,
        "state": state,
        "base": base,
    }
    result = _send_mcp_request("update_pull_request", params)
    logger.info(f"Updated pull request #{number}: {result['html_url']}")


@github_app.command()
def merge_pr(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
    merge_method: str = typer.Option("merge", help="Merge method (merge, squash, rebase)"),
    commit_title: str = typer.Option(None, help="Title for the merge commit"),
    commit_message: str = typer.Option(None, help="Message for the merge commit"),
):
    """Merge a pull request."""
    params = {
        "owner": owner,
        "repo": repo,
        "number": number,
        "merge_method": merge_method,
        "commit_title": commit_title,
        "commit_message": commit_message,
    }
    result = _send_mcp_request("merge_pull_request", params)
    logger.info(f"Merged pull request #{number}")


@github_app.command()
def add_pr_comment(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
    body: str = typer.Option(..., help="Comment body"),
):
    """Add a review comment to a pull request."""
    params = {
        "owner": owner,
        "repo": repo,
        "number": number,
        "body": body,
    }
    result = _send_mcp_request("add_pull_request_comment", params)
    logger.info(f"Added comment to pull request #{number}: {result['html_url']}")


@github_app.command()
def get_pr_comments(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
):
    """Get the review comments on a pull request."""
    params = {"owner": owner, "repo": repo, "number": number}
    result = _send_mcp_request("get_pull_request_comments", params)
    if not result:
        logger.info("No comments found")
        return
    rows = [
        [comment["user"]["login"], comment["created_at"], comment["body"][:50] + "..."]
        for comment in result
    ]
    print_table(
        ["Author", "Created", "Comment"],
        rows,
        title=f"Comments on Pull Request #{number}",
    )


@github_app.command()
def get_pr_files(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
):
    """Get the list of files changed in a pull request."""
    params = {"owner": owner, "repo": repo, "number": number}
    result = _send_mcp_request("get_pull_request_files", params)
    if not result:
        logger.info("No files changed")
        return
    rows = [
        [file["filename"], file["status"], file["additions"], file["deletions"]] for file in result
    ]
    print_table(
        ["Filename", "Status", "Additions", "Deletions"],
        rows,
        title=f"Files Changed in Pull Request #{number}",
    )


@github_app.command()
def get_pr_reviews(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
):
    """Get the reviews on a pull request."""
    params = {"owner": owner, "repo": repo, "number": number}
    result = _send_mcp_request("get_pull_request_reviews", params)
    if not result:
        logger.info("No reviews found")
        return
    rows = [[review["user"]["login"], review["state"], review["submitted_at"]] for review in result]
    print_table(
        ["Reviewer", "State", "Submitted"],
        rows,
        title=f"Reviews on Pull Request #{number}",
    )


@github_app.command()
def create_pr_review(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
    event: str = typer.Option(..., help="Review event (APPROVE, REQUEST_CHANGES, COMMENT)"),
    body: str = typer.Option(None, help="Review body"),
):
    """Create a review on a pull request."""
    params = {
        "owner": owner,
        "repo": repo,
        "number": number,
        "event": event,
        "body": body,
    }
    result = _send_mcp_request("create_pull_request_review", params)
    logger.info(f"Created review on pull request #{number}: {result['html_url']}")


@github_app.command()
def get_pr_status(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
):
    """Get the combined status of all status checks for a pull request."""
    params = {"owner": owner, "repo": repo, "number": number}
    result = _send_mcp_request("get_pull_request_status", params)
    print_table(
        ["Field", "Value"],
        [
            ["State", result["state"]],
            ["Total", result["total_count"]],
            ["Successful", result["statuses"].count(lambda s: s["state"] == "success")],
            ["Failed", result["statuses"].count(lambda s: s["state"] == "failure")],
            ["Pending", result["statuses"].count(lambda s: s["state"] == "pending")],
        ],
        title=f"Status Checks for Pull Request #{number}",
    )


@github_app.command()
def update_pr_branch(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Pull request number"),
):
    """Update a pull request branch with the latest changes from the base branch."""
    params = {"owner": owner, "repo": repo, "number": number}
    result = _send_mcp_request("update_pull_request_branch", params)
    logger.info(f"Updated pull request #{number} branch")


# Repository commands
@github_app.command()
def create_repo(
    name: str = typer.Argument(..., help="Repository name"),
    private: bool = typer.Option(False, help="Create a private repository"),
    description: str = typer.Option(None, help="Repository description"),
    homepage: str = typer.Option(None, help="Repository homepage URL"),
    has_issues: bool = typer.Option(True, help="Enable issues"),
    has_projects: bool = typer.Option(True, help="Enable projects"),
    has_wiki: bool = typer.Option(True, help="Enable wiki"),
    auto_init: bool = typer.Option(False, help="Initialize with README"),
    gitignore_template: str = typer.Option(None, help="Add .gitignore template"),
    license_template: str = typer.Option(None, help="Add license template"),
    org: str = typer.Option(None, help="Create in organization"),
):
    """Create a new GitHub repository."""
    params = {
        "name": name,
        "private": private,
        "description": description,
        "homepage": homepage,
        "has_issues": has_issues,
        "has_projects": has_projects,
        "has_wiki": has_wiki,
        "auto_init": auto_init,
        "gitignore_template": gitignore_template,
        "license_template": license_template,
        "org": org,
    }
    result = _send_mcp_request("create_repository", params)
    logger.info(f"Created repository: {result['html_url']}")


@github_app.command()
def get_repo(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
):
    """Get details about a GitHub repository."""
    params = {"owner": owner, "repo": repo}
    result = _send_mcp_request("get_repository", params)
    print_table(
        ["Field", "Value"],
        [
            ["Name", result["name"]],
            ["Description", result["description"]],
            ["Private", result["private"]],
            ["Fork", result["fork"]],
            ["Created", result["created_at"]],
            ["Updated", result["updated_at"]],
            ["Stars", result["stargazers_count"]],
            ["Forks", result["forks_count"]],
            ["URL", result["html_url"]],
        ],
        title=f"Repository {owner}/{repo}",
    )


@github_app.command()
def list_repos(
    owner: str = typer.Argument(..., help="User or organization name"),
    type: str = typer.Option("all", help="Type of repos (all, owner, member)"),
    sort: str = typer.Option("full_name", help="Sort by (created, updated, pushed, full_name)"),
    direction: str = typer.Option("asc", help="Sort direction (asc, desc)"),
):
    """List repositories for a user or organization."""
    params = {
        "owner": owner,
        "type": type,
        "sort": sort,
        "direction": direction,
    }
    result = _send_mcp_request("list_repositories", params)
    if not result:
        logger.info("No repositories found")
        return
    rows = [
        [repo["name"], repo["private"], repo["stargazers_count"], repo["forks_count"]]
        for repo in result
    ]
    print_table(
        ["Name", "Private", "Stars", "Forks"],
        rows,
        title=f"Repositories for {owner}",
    )


@github_app.command()
def update_repo(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    name: str = typer.Option(None, help="New repository name"),
    description: str = typer.Option(None, help="New description"),
    homepage: str = typer.Option(None, help="New homepage URL"),
    private: bool = typer.Option(None, help="Make private"),
    has_issues: bool = typer.Option(None, help="Enable issues"),
    has_projects: bool = typer.Option(None, help="Enable projects"),
    has_wiki: bool = typer.Option(None, help="Enable wiki"),
    default_branch: str = typer.Option(None, help="Set default branch"),
    allow_squash_merge: bool = typer.Option(None, help="Allow squash merging"),
    allow_merge_commit: bool = typer.Option(None, help="Allow merge commits"),
    allow_rebase_merge: bool = typer.Option(None, help="Allow rebase merging"),
):
    """Update a GitHub repository's settings."""
    params = {
        "owner": owner,
        "repo": repo,
        "name": name,
        "description": description,
        "homepage": homepage,
        "private": private,
        "has_issues": has_issues,
        "has_projects": has_projects,
        "has_wiki": has_wiki,
        "default_branch": default_branch,
        "allow_squash_merge": allow_squash_merge,
        "allow_merge_commit": allow_merge_commit,
        "allow_rebase_merge": allow_rebase_merge,
    }
    result = _send_mcp_request("update_repository", params)
    logger.info(f"Updated repository: {result['html_url']}")


@github_app.command()
def delete_repo(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    confirm: bool = typer.Option(
        ...,
        prompt="Are you sure you want to delete this repository? This action cannot be undone.",
        help="Confirm deletion",
    ),
):
    """Delete a GitHub repository."""
    if not confirm:
        logger.info("Operation cancelled")
        return
    params = {"owner": owner, "repo": repo}
    _send_mcp_request("delete_repository", params)
    logger.info(f"Deleted repository {owner}/{repo}")


@github_app.command()
def list_branches(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    protected: bool = typer.Option(None, help="Filter by protection status"),
):
    """List branches in a repository."""
    params = {"owner": owner, "repo": repo, "protected": protected}
    result = _send_mcp_request("list_branches", params)
    if not result:
        logger.info("No branches found")
        return
    rows = [[branch["name"], branch["protected"], branch["commit"]["sha"][:7]] for branch in result]
    print_table(
        ["Name", "Protected", "Latest Commit"],
        rows,
        title=f"Branches in {owner}/{repo}",
    )


@github_app.command()
def get_branch(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    branch: str = typer.Argument(..., help="Branch name"),
):
    """Get details about a specific branch."""
    params = {"owner": owner, "repo": repo, "branch": branch}
    result = _send_mcp_request("get_branch", params)
    print_table(
        ["Field", "Value"],
        [
            ["Name", result["name"]],
            ["Protected", result["protected"]],
            ["Latest Commit", result["commit"]["sha"]],
            ["Latest Commit Message", result["commit"]["commit"]["message"]],
        ],
        title=f"Branch {branch} in {owner}/{repo}",
    )


@github_app.command()
def create_branch(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    branch: str = typer.Argument(..., help="New branch name"),
    source: str = typer.Option("main", help="Source branch or commit SHA"),
):
    """Create a new branch in a repository."""
    params = {"owner": owner, "repo": repo, "branch": branch, "source": source}
    result = _send_mcp_request("create_branch", params)
    logger.info(f"Created branch {branch} from {source}")


@github_app.command()
def delete_branch(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    branch: str = typer.Argument(..., help="Branch name"),
    confirm: bool = typer.Option(
        ...,
        prompt="Are you sure you want to delete this branch?",
        help="Confirm deletion",
    ),
):
    """Delete a branch from a repository."""
    if not confirm:
        logger.info("Operation cancelled")
        return
    params = {"owner": owner, "repo": repo, "branch": branch}
    _send_mcp_request("delete_branch", params)
    logger.info(f"Deleted branch {branch}")


# User commands
@github_app.command()
def get_user(
    username: str = typer.Argument(..., help="GitHub username"),
):
    """Get information about a GitHub user."""
    params = {"username": username}
    result = _send_mcp_request("get_user", params)
    print_table(
        ["Field", "Value"],
        [
            ["Login", result["login"]],
            ["Name", result["name"]],
            ["Company", result["company"]],
            ["Location", result["location"]],
            ["Email", result["email"]],
            ["Bio", result["bio"]],
            ["Public Repos", result["public_repos"]],
            ["Followers", result["followers"]],
            ["Following", result["following"]],
            ["Created", result["created_at"]],
            ["URL", result["html_url"]],
        ],
        title=f"User {username}",
    )


@github_app.command()
def list_user_repos(
    username: str = typer.Argument(..., help="GitHub username"),
    type: str = typer.Option("owner", help="Type of repos (all, owner, member)"),
    sort: str = typer.Option("full_name", help="Sort by (created, updated, pushed, full_name)"),
    direction: str = typer.Option("asc", help="Sort direction (asc, desc)"),
):
    """List repositories owned by a user."""
    params = {
        "username": username,
        "type": type,
        "sort": sort,
        "direction": direction,
    }
    result = _send_mcp_request("list_user_repos", params)
    if not result:
        logger.info("No repositories found")
        return
    rows = [
        [repo["name"], repo["private"], repo["stargazers_count"], repo["forks_count"]]
        for repo in result
    ]
    print_table(
        ["Name", "Private", "Stars", "Forks"],
        rows,
        title=f"Repositories for {username}",
    )


@github_app.command()
def list_user_orgs(
    username: str = typer.Argument(..., help="GitHub username"),
):
    """List organizations a user belongs to."""
    params = {"username": username}
    result = _send_mcp_request("list_user_orgs", params)
    if not result:
        logger.info("No organizations found")
        return
    rows = [[org["login"], org["description"], org["public_repos"]] for org in result]
    print_table(
        ["Name", "Description", "Public Repos"],
        rows,
        title=f"Organizations for {username}",
    )


# Organization commands
@github_app.command()
def get_org(
    org: str = typer.Argument(..., help="Organization name"),
):
    """Get information about a GitHub organization."""
    params = {"org": org}
    result = _send_mcp_request("get_org", params)
    print_table(
        ["Field", "Value"],
        [
            ["Login", result["login"]],
            ["Name", result["name"]],
            ["Description", result["description"]],
            ["Location", result["location"]],
            ["Email", result["email"]],
            ["Public Repos", result["public_repos"]],
            ["Public Members", result["public_members"]],
            ["Created", result["created_at"]],
            ["URL", result["html_url"]],
        ],
        title=f"Organization {org}",
    )


@github_app.command()
def list_org_repos(
    org: str = typer.Argument(..., help="Organization name"),
    type: str = typer.Option(
        "all", help="Type of repos (all, public, private, forks, sources, member)"
    ),
    sort: str = typer.Option("full_name", help="Sort by (created, updated, pushed, full_name)"),
    direction: str = typer.Option("asc", help="Sort direction (asc, desc)"),
):
    """List repositories in an organization."""
    params = {
        "org": org,
        "type": type,
        "sort": sort,
        "direction": direction,
    }
    result = _send_mcp_request("list_org_repos", params)
    if not result:
        logger.info("No repositories found")
        return
    rows = [
        [repo["name"], repo["private"], repo["stargazers_count"], repo["forks_count"]]
        for repo in result
    ]
    print_table(
        ["Name", "Private", "Stars", "Forks"],
        rows,
        title=f"Repositories for {org}",
    )


@github_app.command()
def list_org_members(
    org: str = typer.Argument(..., help="Organization name"),
    role: str = typer.Option("all", help="Filter by role (all, admin, member)"),
):
    """List members of an organization."""
    params = {"org": org, "role": role}
    result = _send_mcp_request("list_org_members", params)
    if not result:
        logger.info("No members found")
        return
    rows = [[member["login"], member["type"], member["site_admin"]] for member in result]
    print_table(
        ["Login", "Type", "Site Admin"],
        rows,
        title=f"Members of {org}",
    )


# Workflow commands
@github_app.command()
def list_workflows(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
):
    """List GitHub Actions workflows in a repository."""
    params = {"owner": owner, "repo": repo}
    result = _send_mcp_request("list_workflows", params)
    if not result:
        logger.info("No workflows found")
        return
    rows = [
        [workflow["name"], workflow["state"], workflow["path"]] for workflow in result["workflows"]
    ]
    print_table(
        ["Name", "State", "Path"],
        rows,
        title=f"Workflows in {owner}/{repo}",
    )


@github_app.command()
def get_workflow(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    workflow_id: str = typer.Argument(..., help="Workflow ID or filename"),
):
    """Get a specific GitHub Actions workflow."""
    params = {"owner": owner, "repo": repo, "workflow_id": workflow_id}
    result = _send_mcp_request("get_workflow", params)
    print_table(
        ["Field", "Value"],
        [
            ["Name", result["name"]],
            ["State", result["state"]],
            ["Path", result["path"]],
            ["Created", result["created_at"]],
            ["Updated", result["updated_at"]],
        ],
        title=f"Workflow {workflow_id}",
    )


@github_app.command()
def list_workflow_runs(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    workflow_id: str = typer.Argument(..., help="Workflow ID or filename"),
    branch: str = typer.Option(None, help="Filter by branch"),
    event: str = typer.Option(None, help="Filter by event type"),
    status: str = typer.Option(None, help="Filter by status"),
):
    """List runs for a specific workflow."""
    params = {
        "owner": owner,
        "repo": repo,
        "workflow_id": workflow_id,
        "branch": branch,
        "event": event,
        "status": status,
    }
    result = _send_mcp_request("list_workflow_runs", params)
    if not result:
        logger.info("No workflow runs found")
        return
    rows = [
        [run["id"], run["head_branch"], run["event"], run["status"], run["conclusion"]]
        for run in result["workflow_runs"]
    ]
    print_table(
        ["ID", "Branch", "Event", "Status", "Conclusion"],
        rows,
        title=f"Runs for workflow {workflow_id}",
    )


@github_app.command()
def get_workflow_run(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    run_id: int = typer.Argument(..., help="Run ID"),
):
    """Get a specific workflow run."""
    params = {"owner": owner, "repo": repo, "run_id": run_id}
    result = _send_mcp_request("get_workflow_run", params)
    print_table(
        ["Field", "Value"],
        [
            ["ID", result["id"]],
            ["Name", result["name"]],
            ["Branch", result["head_branch"]],
            ["Event", result["event"]],
            ["Status", result["status"]],
            ["Conclusion", result["conclusion"]],
            ["Created", result["created_at"]],
            ["Updated", result["updated_at"]],
            ["URL", result["html_url"]],
        ],
        title=f"Workflow Run {run_id}",
    )


@github_app.command()
def rerun_workflow(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    run_id: int = typer.Argument(..., help="Run ID"),
):
    """Rerun a workflow run."""
    params = {"owner": owner, "repo": repo, "run_id": run_id}
    _send_mcp_request("rerun_workflow", params)
    logger.info(f"Triggered rerun of workflow run {run_id}")


# Release commands
@github_app.command()
def list_releases(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
):
    """List releases in a repository."""
    params = {"owner": owner, "repo": repo}
    result = _send_mcp_request("list_releases", params)
    if not result:
        logger.info("No releases found")
        return
    rows = [
        [release["tag_name"], release["name"], release["created_at"], release["draft"]]
        for release in result
    ]
    print_table(
        ["Tag", "Name", "Created", "Draft"],
        rows,
        title=f"Releases in {owner}/{repo}",
    )


@github_app.command()
def get_release(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    release_id: str = typer.Argument(..., help="Release ID or tag name"),
):
    """Get a specific release."""
    params = {"owner": owner, "repo": repo, "release_id": release_id}
    result = _send_mcp_request("get_release", params)
    print_table(
        ["Field", "Value"],
        [
            ["Tag", result["tag_name"]],
            ["Name", result["name"]],
            ["Draft", result["draft"]],
            ["Prerelease", result["prerelease"]],
            ["Created", result["created_at"]],
            ["Published", result["published_at"]],
            ["URL", result["html_url"]],
        ],
        title=f"Release {release_id}",
    )


@github_app.command()
def create_release(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    tag: str = typer.Argument(..., help="Tag name"),
    name: str = typer.Option(None, help="Release name"),
    body: str = typer.Option(None, help="Release description"),
    draft: bool = typer.Option(False, help="Create as draft"),
    prerelease: bool = typer.Option(False, help="Mark as prerelease"),
    target: str = typer.Option(None, help="Target branch or commit SHA"),
):
    """Create a new release."""
    params = {
        "owner": owner,
        "repo": repo,
        "tag": tag,
        "name": name,
        "body": body,
        "draft": draft,
        "prerelease": prerelease,
        "target": target,
    }
    result = _send_mcp_request("create_release", params)
    logger.info(f"Created release {tag}: {result['html_url']}")


# Label commands
@github_app.command()
def list_labels(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
):
    """List labels in a repository."""
    params = {"owner": owner, "repo": repo}
    result = _send_mcp_request("list_labels", params)
    if not result:
        logger.info("No labels found")
        return
    rows = [[label["name"], label["description"], f"#{label['color']}"] for label in result]
    print_table(
        ["Name", "Description", "Color"],
        rows,
        title=f"Labels in {owner}/{repo}",
    )


@github_app.command()
def get_label(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    name: str = typer.Argument(..., help="Label name"),
):
    """Get a specific label."""
    params = {"owner": owner, "repo": repo, "name": name}
    result = _send_mcp_request("get_label", params)
    print_table(
        ["Field", "Value"],
        [
            ["Name", result["name"]],
            ["Description", result["description"]],
            ["Color", f"#{result['color']}"],
        ],
        title=f"Label {name}",
    )


@github_app.command()
def create_label(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    name: str = typer.Argument(..., help="Label name"),
    color: str = typer.Option(..., help="Color (hex without #)"),
    description: str = typer.Option(None, help="Label description"),
):
    """Create a new label."""
    params = {
        "owner": owner,
        "repo": repo,
        "name": name,
        "color": color,
        "description": description,
    }
    result = _send_mcp_request("create_label", params)
    logger.info(f"Created label {name}")


@github_app.command()
def update_label(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    name: str = typer.Argument(..., help="Current label name"),
    new_name: str = typer.Option(None, help="New label name"),
    color: str = typer.Option(None, help="New color (hex without #)"),
    description: str = typer.Option(None, help="New description"),
):
    """Update a label."""
    params = {
        "owner": owner,
        "repo": repo,
        "name": name,
        "new_name": new_name,
        "color": color,
        "description": description,
    }
    result = _send_mcp_request("update_label", params)
    logger.info(f"Updated label {name}")


@github_app.command()
def delete_label(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    name: str = typer.Argument(..., help="Label name"),
    confirm: bool = typer.Option(
        ...,
        prompt="Are you sure you want to delete this label?",
        help="Confirm deletion",
    ),
):
    """Delete a label."""
    if not confirm:
        logger.info("Operation cancelled")
        return
    params = {"owner": owner, "repo": repo, "name": name}
    _send_mcp_request("delete_label", params)
    logger.info(f"Deleted label {name}")


# Milestone commands
@github_app.command()
def list_milestones(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    state: str = typer.Option("open", help="State (open, closed, all)"),
    sort: str = typer.Option("due_on", help="Sort by (due_on, completeness)"),
    direction: str = typer.Option("asc", help="Sort direction (asc, desc)"),
):
    """List milestones in a repository."""
    params = {
        "owner": owner,
        "repo": repo,
        "state": state,
        "sort": sort,
        "direction": direction,
    }
    result = _send_mcp_request("list_milestones", params)
    if not result:
        logger.info("No milestones found")
        return
    rows = [
        [
            milestone["number"],
            milestone["title"],
            milestone["state"],
            milestone["due_on"],
            f"{milestone['closed_issues']}/{milestone['open_issues'] + milestone['closed_issues']}",
        ]
        for milestone in result
    ]
    print_table(
        ["Number", "Title", "State", "Due Date", "Progress"],
        rows,
        title=f"Milestones in {owner}/{repo}",
    )


@github_app.command()
def get_milestone(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Milestone number"),
):
    """Get a specific milestone."""
    params = {"owner": owner, "repo": repo, "number": number}
    result = _send_mcp_request("get_milestone", params)
    print_table(
        ["Field", "Value"],
        [
            ["Number", result["number"]],
            ["Title", result["title"]],
            ["Description", result["description"]],
            ["State", result["state"]],
            ["Due Date", result["due_on"]],
            ["Created", result["created_at"]],
            ["Updated", result["updated_at"]],
            ["Open Issues", result["open_issues"]],
            ["Closed Issues", result["closed_issues"]],
        ],
        title=f"Milestone {number}",
    )


@github_app.command()
def create_milestone(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    title: str = typer.Argument(..., help="Milestone title"),
    description: str = typer.Option(None, help="Milestone description"),
    due_on: str = typer.Option(None, help="Due date (YYYY-MM-DD)"),
):
    """Create a new milestone."""
    params = {
        "owner": owner,
        "repo": repo,
        "title": title,
        "description": description,
        "due_on": due_on,
    }
    result = _send_mcp_request("create_milestone", params)
    logger.info(f"Created milestone {title} (#{result['number']})")


@github_app.command()
def update_milestone(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Milestone number"),
    title: str = typer.Option(None, help="New title"),
    description: str = typer.Option(None, help="New description"),
    due_on: str = typer.Option(None, help="New due date (YYYY-MM-DD)"),
    state: str = typer.Option(None, help="New state (open, closed)"),
):
    """Update a milestone."""
    params = {
        "owner": owner,
        "repo": repo,
        "number": number,
        "title": title,
        "description": description,
        "due_on": due_on,
        "state": state,
    }
    result = _send_mcp_request("update_milestone", params)
    logger.info(f"Updated milestone #{number}")


@github_app.command()
def delete_milestone(
    owner: str = typer.Argument(..., help="Repository owner"),
    repo: str = typer.Argument(..., help="Repository name"),
    number: int = typer.Argument(..., help="Milestone number"),
    confirm: bool = typer.Option(
        ...,
        prompt="Are you sure you want to delete this milestone?",
        help="Confirm deletion",
    ),
):
    """Delete a milestone."""
    if not confirm:
        logger.info("Operation cancelled")
        return
    params = {"owner": owner, "repo": repo, "number": number}
    _send_mcp_request("delete_milestone", params)
    logger.info(f"Deleted milestone #{number}")

create_issue = create_issue
get_issue = get_issue
list_issues = list_issues
update_issue = update_issue
add_issue_comment = add_issue_comment
get_issue_comments = get_issue_comments
create_pr = create_pr
get_pr = get_pr
list_prs = list_prs
update_pr = update_pr
merge_pr = merge_pr
add_pr_comment = add_pr_comment
get_pr_comments = get_pr_comments
get_pr_files = get_pr_files
get_pr_reviews = get_pr_reviews
create_pr_review = create_pr_review
get_pr_status = get_pr_status
update_pr_branch = update_pr_branch
create_repo = create_repo
get_repo = get_repo
list_repos = list_repos
update_repo = update_repo
delete_repo = delete_repo
list_branches = list_branches
get_branch = get_branch
create_branch = create_branch
delete_branch = delete_branch
get_user = get_user
list_user_repos = list_user_repos
list_user_orgs = list_user_orgs
get_org = get_org
list_org_repos = list_org_repos
list_org_members = list_org_members
list_workflows = list_workflows
get_workflow = get_workflow
list_workflow_runs = list_workflow_runs
get_workflow_run = get_workflow_run
rerun_workflow = rerun_workflow
list_releases = list_releases
get_release = get_release
create_release = create_release
list_labels = list_labels
get_label = get_label
create_label = create_label
update_label = update_label
delete_label = delete_label
list_milestones = list_milestones
get_milestone = get_milestone
create_milestone = create_milestone
update_milestone = update_milestone
delete_milestone = delete_milestone

# mcp_commands.py
import typer
from pathlib import Path
from loguru import logger



mcp_registry = MCPRegistry()
mcp_app = typer.Typer(help="Manage MCP servers and clients.")


def show_mcp_help_and_exit():
    """Show help menu and exit with error code."""
    command_rows = [
        ["erasmus mcp server start", "Start an MCP server"],
        ["erasmus mcp server stop", "Stop an MCP server"],
        ["erasmus mcp server register", "Register a new MCP server"],
        ["erasmus mcp server unregister", "Unregister an MCP server"],
        ["erasmus mcp server list", "List all registered servers"],
        ["erasmus mcp client connect", "Connect to an MCP server"],
        ["erasmus mcp client disconnect", "Disconnect from an MCP server"],
        ["erasmus mcp client register", "Register a new MCP client"],
        ["erasmus mcp client unregister", "Unregister an MCP client"],
        ["erasmus mcp client list", "List all registered clients"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available MCP Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus mcp <command> --help")
    raise typer.Exit(1)


@mcp_app.callback(invoke_without_command=True)
def mcp_callback(ctx: typer.Context):
    """
    Manage MCP servers and clients.
    """
    if ctx.invoked_subcommand is None:
        command_rows = [
            ["erasmus mcp server", "Manage MCP servers"],
            ["erasmus mcp client", "Manage MCP clients"],
        ]
        print_table(["Command", "Description"], command_rows, title="Available MCP Commands")
        typer.echo("\nFor more information about a command, run:")
        typer.echo("  erasmus mcp <command> --help")
        raise typer.Exit(0)


# Server commands
server_app = typer.Typer(help="Manage MCP servers.")
server_app.add_typer(github_app, name="github", help="Manage GitHub through the MCP server.")
mcp_app.add_typer(server_app, name="server")


@server_app.command()
def start(
    name: str = typer.Argument(None, help="Name of the server to start"),
    host: str = typer.Option("localhost", help="Host to bind the server to"),
    port: int = typer.Option(8080, help="Port to bind the server to"),
):
    """Start an MCP server.

    This command starts an MCP server with the specified name, host, and port.
    If the server is not registered, it will be registered automatically.
    """
    try:
        if not name:
            name = typer.prompt("Enter the server name")
        if not name:
            typer.echo("Error: Server name is required.")
            raise typer.Exit(1)
        # Check if server is registered
        server_info = mcp_registry.get_server(name)
        if not server_info:
            # Register the server
            mcp_registry.register_server(name, host, port)
            logger.info(f"Registered server: {name}")

        # Start the server
        server = MCPServer(host, port)
        server.start()
        logger.info(f"Started server: {name} on {host}:{port}")
        show_mcp_help_and_exit()
    except MCPError as e:
        logger.error(f"Failed to start server: {e}")
        show_mcp_help_and_exit()


@server_app.command()
def stop(name: str = typer.Argument(None, help="Name of the server to stop")):
    """Stop an MCP server.

    This command stops an MCP server with the specified name.
    """
    try:
        if not name:
            name = typer.prompt("Enter the server name")
        if not name:
            typer.echo("Error: Server name is required.")
            raise typer.Exit(1)
        # Check if server is registered
        server_info = mcp_registry.get_server(name)
        if not server_info:
            raise MCPError(f"Server '{name}' not registered")

        # Stop the server
        server = MCPServer(server_info["host"], server_info["port"])
        server.stop()
        logger.info(f"Stopped server: {name}")
        show_mcp_help_and_exit()
    except MCPError as e:
        logger.error(f"Failed to stop server: {e}")
        show_mcp_help_and_exit()


@server_app.command()
def register(
    name: str = typer.Argument(None, help="Name of the server to register"),
    host: str = typer.Option("localhost", help="Host the server is running on"),
    port: int = typer.Option(8080, help="Port the server is running on"),
):
    """Register a new MCP server."""
    try:
        if not name:
            name = typer.prompt("Enter the server name")
        if not name:
            typer.echo("Error: Server name is required.")
            raise typer.Exit(1)
        mcp_registry.register_server(name, host, port)
        typer.echo(f"Registered server: {name}")
        raise typer.Exit(0)
    except MCPError as e:
        typer.echo(f"Error: Failed to register server: {e}")
        raise typer.Exit(1)


@server_app.command()
def unregister(
    name: str = typer.Argument(None, help="Name of the server to unregister"),
):
    """Unregister an MCP server."""
    try:
        if not name:
            name = typer.prompt("Enter the server name")
        if not name:
            typer.echo("Error: Server name is required.")
            raise typer.Exit(1)
        mcp_registry.unregister_server(name)
        typer.echo(f"Unregistered server: {name}")
        raise typer.Exit(0)
    except MCPError as e:
        typer.echo(f"Error: Failed to unregister server: {e}")
        raise typer.Exit(1)


@server_app.command()
def list():
    """List all registered MCP servers.

    This command lists all registered MCP servers and their information.
    """
    try:
        servers = mcp_registry.list_servers()
        if not servers:
            typer.echo("No servers registered")
            return

        # Display servers in a table
        server_rows = []
        for server_name in servers:
            server_info = mcp_registry.get_server(server_name)
            server_rows.append([server_name, server_info["host"], server_info["port"]])
        print_table(["Server Name", "Host", "Port"], server_rows, title="Registered MCP Servers")
    except MCPError as e:
        logger.error(f"Failed to list servers: {e}")
        show_mcp_help_and_exit()


# Client commands
client_app = typer.Typer(help="Manage MCP clients.")
mcp_app.add_typer(client_app, name="client")


@client_app.command()
def connect(
    name: str = typer.Argument(None, help="Name of the client to connect"),
    server_name: str = typer.Argument(None, help="Name of the server to connect to"),
):
    """Connect to an MCP server.

    This command connects a client to an MCP server.
    If the client is not registered, it will be registered automatically.
    """
    try:
        if not name:
            name = typer.prompt("Enter the client name")
        if not name:
            typer.echo("Error: Client name is required.")
            raise typer.Exit(1)
        if not server_name:
            server_name = typer.prompt("Enter the server name to connect to")
        if not server_name:
            typer.echo("Error: Server name is required.")
            raise typer.Exit(1)
        # Check if server is registered
        server_info = mcp_registry.get_server(server_name)
        if not server_info:
            raise MCPError(f"Server '{server_name}' not registered")

        # Check if client is registered
        client_info = mcp_registry.get_client(name)
        if not client_info:
            # Register the client
            mcp_registry.register_client(name, server_name)
            logger.info(f"Registered client: {name}")

        # Connect to the server
        server_url = f"http://{server_info['host']}:{server_info['port']}"
        client = MCPClient(server_url)
        client.connect()
        logger.info(f"Connected client: {name} to server: {server_name}")
        show_mcp_help_and_exit()
    except MCPError as e:
        logger.error(f"Failed to connect client: {e}")
        show_mcp_help_and_exit()


@client_app.command()
def disconnect(
    name: str = typer.Argument(..., help="Name of the client to disconnect"),
):
    """Disconnect from an MCP server.

    This command disconnects a client from an MCP server.
    """
    try:
        # Check if client is registered
        client_info = mcp_registry.get_client(name)
        if not client_info:
            raise MCPError(f"Client '{name}' not registered")

        # Get server information
        server_name = client_info["server"]
        server_info = mcp_registry.get_server(server_name)
        if not server_info:
            raise MCPError(f"Server '{server_name}' not registered")

        # Disconnect from the server
        server_url = f"http://{server_info['host']}:{server_info['port']}"
        client = MCPClient(server_url)
        client.disconnect()
        logger.info(f"Disconnected client: {name} from server: {server_name}")
        show_mcp_help_and_exit()
    except MCPError as e:
        logger.error(f"Failed to disconnect client: {e}")
        show_mcp_help_and_exit()


@client_app.command()
def register(
    name: str = typer.Argument(None, help="Name of the client to register"),
    server_name: str = typer.Argument(None, help="Name of the server the client is connected to"),
):
    """Register a new MCP client.

    This command registers a new MCP client with the specified name and server.
    """
    try:
        if not name:
            name = typer.prompt("Enter the client name")
        if not name:
            typer.echo("Error: Client name is required.")
            raise typer.Exit(1)
        if not server_name:
            server_name = typer.prompt("Enter the server name the client is connected to")
        if not server_name:
            typer.echo("Error: Server name is required.")
            raise typer.Exit(1)
        mcp_registry.register_client(name, server_name)
        logger.info(f"Registered client: {name} to server: {server_name}")
        show_mcp_help_and_exit()
    except MCPError as e:
        logger.error(f"Failed to register client: {e}")
        show_mcp_help_and_exit()


@client_app.command()
def unregister(
    name: str = typer.Argument(None, help="Name of the client to unregister"),
):
    """Unregister an MCP client.

    This command unregisters an MCP client with the specified name.
    """
    try:
        if not name:
            name = typer.prompt("Enter the client name")
        if not name:
            typer.echo("Error: Client name is required.")
            raise typer.Exit(1)
        mcp_registry.unregister_client(name)
        logger.info(f"Unregistered client: {name}")
        show_mcp_help_and_exit()
    except MCPError as e:
        logger.error(f"Failed to unregister client: {e}")
        show_mcp_help_and_exit()


@client_app.command()
def list():
    """List all registered MCP clients.

    This command lists all registered MCP clients and their information.
    """
    try:
        clients = mcp_registry.list_clients()
        if not clients:
            typer.echo("No clients registered")
            return

        # Display clients in a table
        client_rows = []
        for client_name in clients:
            client_info = mcp_registry.get_client(client_name)
            client_rows.append([client_name, client_info["server"]])
        print_table(
            ["Client Name", "Connected Server"],
            client_rows,
            title="Registered MCP Clients",
        )
    except MCPError as e:
        logger.error(f"Failed to list clients: {e}")
        show_mcp_help_and_exit()


@mcp_app.command("select-server")
def select_server():
    """Interactively select an MCP server and display its details."""
    try:
        servers = mcp_registry.list_servers()
        if not servers:
            typer.echo("No servers found to select.")
            raise typer.Exit(1)
        # Display servers in a table
        server_rows = [[str(index + 1), server_name] for index, server_name in enumerate(servers)]
        print_table(["#", "Server Name"], server_rows, title="Registered MCP Servers")
        choice = typer.prompt("Select a server by number or name")
        selected = None
        if choice.isdigit():
            index = int(choice)
            if 1 <= index <= len(servers):
                selected = servers[index - 1]
        else:
            if choice in servers:
                selected = choice
        if not selected:
            typer.echo(f"Error: Invalid selection: {choice}")
            raise typer.Exit(1)
        server_info = mcp_registry.get_server(selected)
        if not server_info:
            typer.echo(f"Error: Server not found: {selected}")
            raise typer.Exit(1)
        typer.echo(f"Selected server: {selected}")
        typer.echo(f"Host: {server_info['host']}")
        typer.echo(f"Port: {server_info['port']}")
        raise typer.Exit(0)
    except MCPError as exception:
        typer.echo(f"Error: Failed to select server: {exception}")
        raise typer.Exit(1)


@mcp_app.command("select-client")
def select_client():
    """Interactively select an MCP client and display its details."""
    try:
        clients = mcp_registry.list_clients()
        if not clients:
            typer.echo("No clients found to select.")
            raise typer.Exit(1)
        # Display clients in a table
        client_rows = [[str(index + 1), client_name] for index, client_name in enumerate(clients)]
        print_table(["#", "Client Name"], client_rows, title="Registered MCP Clients")
        choice = typer.prompt("Select a client by number or name")
        selected = None
        if choice.isdigit():
            index = int(choice)
            if 1 <= index <= len(clients):
                selected = clients[index - 1]
        else:
            if choice in clients:
                selected = choice
        if not selected:
            typer.echo(f"Error: Invalid selection: {choice}")
            raise typer.Exit(1)
        client_info = mcp_registry.get_client(selected)
        if not client_info:
            typer.echo(f"Error: Client not found: {selected}")
            raise typer.Exit(1)
        typer.echo(f"Selected client: {selected}")
        typer.echo(f"Connected server: {client_info['server']}")
        raise typer.Exit(0)
    except MCPError as exception:
        typer.echo(f"Error: Failed to select client: {exception}")
        raise typer.Exit(1)



show_mcp_help_and_exit = show_mcp_help_and_exit
mcp_callback = mcp_callback
start = start
stop = stop
register = register
unregister = unregister
list = list
connect = connect
disconnect = disconnect
register = register
unregister = unregister
list = list
select_server = select_server
select_client = select_client

# context_commands.py
# """
# CLI commands for managing development contexts.
# """

# import typer
# from loguru import logger
# from erasmus.context import ContextManager, ContextError
# import xml.dom.minidom as minidom
# from erasmus.utils.rich_console import print_table, get_console
# import os
# from rich.panel import Panel
# import xml.etree.ElementTree as ET
# from erasmus.utils.paths import get_path_manager

# context_manager = ContextManager()
# console = get_console()
# context_app = typer.Typer(help="Manage development contexts and their files.")


# @context_app.command("get")
# def get_context(name: str = typer.Argument(..., help="Name of the context to get")):
#     """Get detailed information of a development context."""
#     try:
#         # Use display_context to print full details
#         context_manager.display_context(name)
#     except ContextError as e:
#         # Extract underlying error if prefixed by display_context
#         error_msg = str(e)
#         prefix = "Failed to display context: "
#         if error_msg.startswith(prefix):
#             error_msg = error_msg[len(prefix) :]
#         typer.echo(f"Error: Failed to get context: {error_msg}")
#         raise typer.Exit(1)
#     # Successful display
#     raise typer.Exit(0)


# def show_context_help_and_exit():
#     """Show help menu and exit with error code."""
#     command_rows = [
#         ["erasmus context list", "List all contexts"],
#         ["erasmus context create", "Create a new context"],
#         ["erasmus context show", "Show context details"],
#         ["erasmus context update", "Update context files"],
#         ["erasmus context edit", "Edit context files"],
#         ["erasmus context store", "Store the current context"],
#         ["erasmus context select", "Select and load a context interactively"],
#         ["erasmus context load", "Load a context by name to root .ctx XML files"],
#     ]
#     print_table(["Command", "Description"], command_rows, title="Available Commands")
#     typer.echo("\nFor more information about a command, run:")
#     typer.echo("  erasmus context <command> --help")
#     raise typer.Exit(1)


# @context_app.callback(invoke_without_command=True)
# def context_callback(ctx: typer.Context):
#     """
#     Manage development contexts and their files.
#     """
#     if ctx.invoked_subcommand is None:
#         command_rows = [
#             ["erasmus context list", "List all contexts"],
#             ["erasmus context create", "Create a new context"],
#             ["erasmus context show", "Show context details"],
#             ["erasmus context update", "Update context files"],
#             ["erasmus context edit", "Edit context files"],
#             ["erasmus context store", "Store the current context"],
#             ["erasmus context select", "Select and load a context interactively"],
#             ["erasmus context load", "Load a context by name to root .ctx XML files"],
#         ]
#         print_table(["Command", "Description"], command_rows, title="Available Commands")
#         typer.echo("\nFor more information about a command, run:")
#         typer.echo("  erasmus context <command> --help")
#         raise typer.Exit(0)


# @context_app.command()
# def create(name: str = typer.Argument(None, help="Name of the context to create")):
#     """Create a new development context and display its path."""
#     try:
#         if not name:
#             name = typer.prompt("Enter the context name")
#         if not name:
#             print_table(
#                 ["Error"],
#                 [["Context name is required."]],
#                 title="Context Creation Failed",
#             )
#             raise typer.Exit(1)
#         context_path = context_manager.get_context_path(name)
#         context_manager.create_context(name)
#         # Retrieve created context model for path
#         context = context_manager.get_context(name)
#         # Display created context in a table
#         context_rows = [[context_path]]
#         print_table(["Context Path"], context_rows, title=f"Created Context: {name}")
#         raise typer.Exit(0)
#     except ContextError as error:
#         print_table(["Error"], [[str(error)]], title="Context Creation Failed")
#         raise typer.Exit(1)


# @context_app.command()
# def delete(name: str = typer.Argument(None, help="Name of the context to delete")):
#     """Delete a context.

#     This command permanently removes a context folder and its files.
#     Use with caution as this action cannot be undone.
#     """
#     try:
#         if not name:
#             contexts = context_manager.list_contexts()
#             if not contexts:
#                 print_table(["Info"], [["No contexts found"]], title="Available Contexts")
#                 raise typer.Exit(1)
#             context_rows = [
#                 [str(index + 1), context_name] for index, context_name in enumerate(contexts)
#             ]
#             print_table(["#", "Context Name"], context_rows, title="Available Contexts")
#             choice = typer.prompt("Select a context by number or name")
#             selected = None
#             if choice.isdigit():
#                 index = int(choice)
#                 if 1 <= index <= len(contexts):
#                     selected = contexts[index - 1]
#             else:
#                 if choice in contexts:
#                     selected = choice
#             if not selected:
#                 print_table(
#                     ["Error"],
#                     [[f"Invalid selection: {choice}"]],
#                     title="Context Deletion Failed",
#                 )
#                 raise typer.Exit(1)
#             name = selected
#         context_manager.delete_context(name)
#         print_table(["Info"], [[f"Deleted context: {name}"]], title="Context Deleted")
#         raise typer.Exit(0)
#     except Exception as e:
#         print_table(["Error"], [[str(e)]], title="Context Deletion Failed")
#         raise typer.Exit(1)


# @context_app.command()
# def list():
#     """List all development contexts.

#     This command shows all available contexts and their basic information.
#     Use 'show' to view detailed information about a specific context.
#     """
#     try:
#         contexts = context_manager.list_contexts()
#         if not contexts:
#             print_table(["Info"], [["No contexts found"]], title="Available Contexts")
#             return

#         # Display contexts in a table
#         context_rows = [[context] for context in contexts]
#         print_table(["Context Name"], context_rows, title="Available Contexts")
#     except ContextError as error:
#         print_table(["Error"], [[str(error)]], title="Context Listing Failed")
#         show_context_help_and_exit()


# def preview(text, lines=10):
#     if not text:
#         return ""
#     split = text.splitlines()
#     if len(split) > lines:
#         return "\n".join(split[:lines]) + "\n..."
#     return text


# @context_app.command()
# def show(name: str = typer.Argument(None, help="Name of the context to show")):
#     """Show details of a development context.

#     This command displays detailed information about a specific context,
#     including file sizes and paths. If no name is supplied, it will prompt the user to select one.
#     """
#     try:
#         if not name:
#             # List available contexts and prompt for selection
#             contexts = context_manager.list_contexts()
#             if not contexts:
#                 print_table(["Info"], [["No contexts found"]], title="Available Contexts")
#                 raise typer.Exit(1)
#             context_rows = [
#                 [str(index + 1), context_name] for index, context_name in enumerate(contexts)
#             ]
#             print_table(["#", "Context Name"], context_rows, title="Available Contexts")
#             choice = typer.prompt("Select a context by number or name")
#             selected = None
#             if choice.isdigit():
#                 index = int(choice)
#                 if 1 <= index <= len(contexts):
#                     selected = contexts[index - 1]
#             else:
#                 if choice in contexts:
#                     selected = choice
#             if not selected:
#                 print_table(
#                     ["Error"],
#                     [[f"Invalid selection: {choice}"]],
#                     title="Context Show Failed",
#                 )
#                 raise typer.Exit(1)
#             name = selected
#         context_dir = context_manager.get_context_path(name)

#         def read_context_file(context_dir, file_type):
#             for ext in (".md", ".md"):
#                 file_path = context_dir / f"ctx.{file_type}{ext}"
#                 if file_path.exists():
#                     return file_path.read_text()
#             return ""

#         context_rows = [
#             ["Path", str(context_dir)],
#             ["Architecture", preview(read_context_file(context_dir, "architecture"))],
#             ["Progress", preview(read_context_file(context_dir, "progress"))],
#             ["Tasks", preview(read_context_file(context_dir, "tasks"))],
#             ["Protocol", preview(read_context_file(context_dir, "protocol"))],
#         ]
#         print_table(
#             ["Field", "Preview (first 10 lines)"],
#             context_rows,
#             title=f"Context: {name}",
#         )
#     except ContextError as error:
#         print_table(["Error"], [[str(error)]], title="Context Show Failed")
#         show_context_help_and_exit()


# @context_app.command()
# def update(
#     name: str = typer.Argument(None, help="Name of the context to update"),
#     file_type: str = typer.Argument(
#         None, help="Type of file to update (architecture, progress, tasks, protocol)"
#     ),
#     content: str = typer.Argument(None, help="Content to write to the file"),
# ):
#     """Update a file in a development context.

#     This command updates the content of a specific file in a context.
#     The file type must be one of: architecture, progress, tasks, or protocol.
#     """
#     try:
#         if not name:
#             # List available contexts and prompt for selection
#             contexts = context_manager.list_contexts()
#             if not contexts:
#                 print_table(["Info"], [["No contexts found"]], title="Available Contexts")
#                 raise typer.Exit(1)
#             context_rows = [
#                 [str(index + 1), context_name] for index, context_name in enumerate(contexts)
#             ]
#             print_table(["#", "Context Name"], context_rows, title="Available Contexts")
#             choice = typer.prompt("Select a context by number or name")
#             selected = None
#             if choice.isdigit():
#                 index = int(choice)
#                 if 1 <= index <= len(contexts):
#                     selected = contexts[index - 1]
#             else:
#                 if choice in contexts:
#                     selected = choice
#             if not selected:
#                 print_table(
#                     ["Error"],
#                     [[f"Invalid selection: {choice}"]],
#                     title="Context Update Failed",
#                 )
#                 raise typer.Exit(1)
#             name = selected
#         if not file_type:
#             file_type = typer.prompt(
#                 "Enter the file type to update (architecture, progress, tasks, protocol)"
#             )
#         if not file_type:
#             print_table(
#                 ["Error"],
#                 [["File type is required for update."]],
#                 title="Context Update Failed",
#             )
#             raise typer.Exit(1)
#         if content is None:
#             content = typer.prompt(f"Enter the new content for {file_type}")
#         if not content:
#             print_table(
#                 ["Error"],
#                 [["Content is required for update."]],
#                 title="Context Update Failed",
#             )
#             raise typer.Exit(1)
#         context_manager.update_file(name, file_type, content)
#         print_table(
#             ["Info"],
#             [[f"Updated {file_type} in context: {name}"]],
#             title="Context Updated",
#         )
#         raise typer.Exit(0)
#     except ContextError as error:
#         print_table(["Error"], [[str(error)]], title="Context Update Failed")
#         show_context_help_and_exit()


# @context_app.command()
# def cat(
#     name: str = typer.Argument(..., help="Name of the context"),
#     file_type: str = typer.Argument(
#         ..., help="Type of file to read (architecture, progress, tasks, protocol)"
#     ),
# ):
#     """Display the contents of a file in a development context.

#     This command shows the raw contents of a specific file in a context.
#     The file type must be one of: architecture, progress, tasks, or protocol.
#     """
#     try:
#         content = context_manager.read_file(name, file_type)
#         if content is None:
#             print_table(
#                 ["Error"],
#                 [[f"File not found: {file_type}"]],
#                 title="Context Cat Failed",
#             )
#             logger.info("Available file types: architecture, progress, tasks, protocol")
#             show_context_help_and_exit()

#         # Pretty print XML for better readability
#         try:
#             # Parse the XML content
#             dom = minidom.parseString(content)
#             # Pretty print with indentation
#             pretty_xml = dom.toprettyxml(indent="  ")
#             print(pretty_xml)
#         except Exception:
#             # If XML parsing fails, print the raw content
#             print(content)
#     except ContextError as error:
#         print_table(["Error"], [[str(error)]], title="Context Cat Failed")
#         show_context_help_and_exit()


# @context_app.command()
# def edit(
#     name: str = typer.Argument(None, help="Name of the context"),
#     file_type: str = typer.Argument(
#         None, help="Type of file to edit (architecture, progress, tasks, protocol)"
#     ),
#     editor: str = typer.Argument(None, help="Editor to use for editing"),
# ):
#     """Edit a file in a development context.

#     This command opens a file in your default editor (or specified editor).
#     The file type must be one of: architecture, progress, tasks, or protocol.
#     """
#     if not name:
#         # List available contexts and prompt for selection
#         contexts = context_manager.list_contexts()
#         if not contexts:
#             print_table(["Info"], [["No contexts found"]], title="Available Contexts")
#             raise typer.Exit(1)
#         context_rows = [
#             [str(index + 1), context_name] for index, context_name in enumerate(contexts)
#         ]
#         print_table(["#", "Context Name"], context_rows, title="Available Contexts")
#         choice = typer.prompt("Select a context by number or name")
#         selected = None
#         if choice.isdigit():
#             index = int(choice)
#             if 1 <= index <= len(contexts):
#                 selected = contexts[index - 1]
#         else:
#             if choice in contexts:
#                 selected = choice
#         if not selected:
#             print_table(
#                 ["Error"],
#                 [[f"Invalid selection: {choice}"]],
#                 title="Context Edit Failed",
#             )
#             raise typer.Exit(1)
#         name = selected
#     if not file_type:
#         file_type = typer.prompt(
#             "Enter the file type to edit (architecture, progress, tasks, protocol)"
#         )
#     if not file_type:
#         print_table(
#             ["Error"],
#             [["File type is required for edit."]],
#             title="Context Edit Failed",
#         )
#         raise typer.Exit(1)
#     context_dir = context_manager.get_context_path(name)
#     file_path = None
#     for ext in (".md", ".md"):
#         candidate = context_dir / f"ctx.{file_type}{ext}"
#         if candidate.exists():
#             file_path = candidate
#             break
#     if not file_path:
#         print_table(
#             ["Error"],
#             [[f"File does not exist: {file_type}"]],
#             title="Context Edit Failed",
#         )
#         raise typer.Exit(1)
#     editor_cmd = editor or os.environ.get("EDITOR", "nano")
#     os.system(f"{editor_cmd} {file_path}")
#     print_table(
#         ["Info"],
#         [[f"Edited {file_type} in context: {name}"]],
#         title="Context Edited",
#     )
#     raise typer.Exit(0)


# def get_title_from_architecture() -> str | None:
#     """Parse the title from the architecture file.

#     Returns:
#         The title if found, None otherwise.
#     """
#     try:
#         arch_file = context_manager.pm.get_architecture_file()
#         if not arch_file.exists():
#             return None

#         tree = ET.parse(arch_file)
#         root = tree.getroot()

#         # Try different possible paths to title
#         title_paths = [
#             ".//Title",  # Direct title tag
#             ".//Architecture/Title",  # Under Architecture
#             ".//Overview/Title",  # Under Overview
#             ".//Architecture/Overview/Title",  # Full path
#         ]

#         for path in title_paths:
#             title_elem = root.find(path)
#             if title_elem is not None and title_elem.text:
#                 return title_elem.text.strip()

#         return None
#     except Exception:
#         return None


# @context_app.command()
# def store(name: str = typer.Argument(None, help="Optional name to store the context under")):
#     """Store the current context. If no name is provided, uses the title from architecture file or prompts for one."""
#     try:
#         # If name not provided, try to get from architecture
#         if not name:
#             name = get_title_from_architecture()

#         # If still no name, prompt user
#         if not name:
#             name = typer.prompt("Enter a name for the context")

#         if not name:
#             console.print(
#                 Panel("Error: Context name is required", title="Context Store Failed", style="red")
#             )
#             show_context_help_and_exit()
#             raise typer.Exit(1)

#         context_manager.store_context(name)
#         console.print(
#             Panel(f"Context stored successfully as '{name}'", title="Context Store", style="green")
#         )
#     except Exception as e:
#         console.print(Panel(f"Error\n{str(e)}", title="Context Store Failed", style="red"))
#         show_context_help_and_exit()
#         raise typer.Exit(1)


# @context_app.command("load")
# def load_context(name: str = typer.Argument(None, help="Name of the context to load")):
#     """Load a stored context by name into the root .ctx XML files.

#     If no name is supplied, you will be prompted to select one interactively.
#     """
#     try:
#         if not name:
#             # List available contexts and prompt for selection
#             contexts = context_manager.list_contexts()
#             if not contexts:
#                 print_table(["Info"], [["No contexts found"]], title="Available Contexts")
#                 raise typer.Exit(1)
#             context_rows = [
#                 [str(index + 1), context_name] for index, context_name in enumerate(contexts)
#             ]
#             print_table(["#", "Context Name"], context_rows, title="Available Contexts")
#             choice = typer.prompt("Select a context by number or name")
#             selected = None
#             if choice.isdigit():
#                 index = int(choice)
#                 if 1 <= index <= len(contexts):
#                     selected = contexts[index - 1]
#             else:
#                 if choice in contexts:
#                     selected = choice
#             if not selected:
#                 print_table(
#                     ["Error"],
#                     [[f"Invalid selection: {choice}"]],
#                     title="Context Load Failed",
#                 )
#                 raise typer.Exit(1)
#             name = selected
#         context_manager.load_context(name)
#         print_table(["Info"], [[f"Loaded context: {name}"]], title="Context Loaded")
#         raise typer.Exit(0)
#     except ContextError as error:
#         print_table(["Error"], [[str(error)]], title="Context Load Failed")
#         raise typer.Exit(1)


# @context_app.command("select")
# def select_context():
#     """Interactively select a context and load its XML files."""
#     base_dir = context_manager.base_path
#     # Gather available contexts
#     try:
#         contexts = sorted(
#             [
#                 context_directory.name
#                 for context_directory in base_dir.iterdir()
#                 if context_directory.is_dir()
#             ]
#         )
#     except Exception as exception:
#         typer.echo(f"Error: Unable to list contexts: {exception}")
#         raise typer.Exit(1)
#     if not contexts:
#         typer.echo("No contexts found to select.")
#         raise typer.Exit(1)
#     # Display contexts in a table with create new option
#     context_rows = [["0", "Create New Context"]] + [
#         [str(index + 1), context_name] for index, context_name in enumerate(contexts)
#     ]
#     print_table(["#", "Context Name"], context_rows, title="Available Contexts")
#     choice = typer.prompt("Select a context by number or name (0 to create new)")
#     # Handle create new option
#     if choice == "0":
#         new_name = typer.prompt("Enter name for new context")
#         if not new_name:
#             typer.echo("Error: Context name is required")
#             raise typer.Exit(1)
#         try:
#             context_manager.create_context(new_name)
#             selected = new_name
#         except ContextError as e:
#             typer.echo(f"Error creating context: {e}")
#             raise typer.Exit(1)
#     else:
#         # Determine selected context name
#         selected = None
#         if choice.isdigit():
#             index = int(choice)
#             if 1 <= index <= len(contexts):
#                 selected = contexts[index - 1]
#         else:
#             if choice in contexts:
#                 selected = choice
#         if not selected:
#             typer.echo(f"Error: Invalid selection: {choice}")
#             raise typer.Exit(1)
#     # Load the selected context
#     try:
#         context_manager.load_context(selected)
#         typer.echo(f"Loaded context: {selected}")
#         raise typer.Exit(0)
#     except ContextError as exception:
#         typer.echo(f"Error: Failed to load context: {exception}")
#         raise typer.Exit(1)


# def setup_callback(ctx: typer.Context):
#     """Initialize the context manager and create initial context."""
#     try:
#         # Get path manager
#         path_manager = get_path_manager()

#         # Create erasmus directories
#         erasmus_dir = path_manager.erasmus_dir
#         context_dir = path_manager.context_dir
#         protocol_dir = path_manager.protocol_dir
#         template_dir = path_manager.template_dir

#         erasmus_dir.mkdir(parents=True, exist_ok=True)
#         context_dir.mkdir(parents=True, exist_ok=True)
#         protocol_dir.mkdir(parents=True, exist_ok=True)
#         template_dir.mkdir(parents=True, exist_ok=True)

#         print_table(["Info"], [[f"Erasmus folders created in: {erasmus_dir}"]], title="Setup")

#         # Create a template context in the context folder and update root .ctx.*.md
#         context_manager = ContextManager(base_path=str(context_dir))
#         project_name = path_manager.root_dir.name
#         context_manager.create_context(project_name)
#         print_table(["Info"], [[f"Template context created: {project_name}"]], title="Setup")

#         # Load the new context to root .ctx.*.md files
#         context_manager.load_context(project_name)
#         print_table(["Info"], [[f"Context loaded: {project_name}"]], title="Setup")

#     except Exception as e:
#         print_table(["Error"], [[str(e)]], title="Setup Failed")
#         raise typer.Exit(1)


# protocol_commands.py
import typer
from pathlib import Path
from loguru import logger


import os
import re

protocol_manager = ProtocolManager()
protocol_app = typer.Typer(help="Manage development protocols.")


def show_protocol_help_and_exit():
    """Show help menu and exit with error code."""
    command_rows = [
        ["erasmus protocol list", "List all protocols"],
        ["erasmus protocol create", "Create a new protocol"],
        ["erasmus protocol show", "Show protocol details"],
        ["erasmus protocol update", "Update a protocol"],
        ["erasmus protocol edit", "Edit a protocol"],
        ["erasmus protocol delete", "Delete a protocol"],
        ["erasmus protocol select", "Select and display a protocol"],
        ["erasmus protocol load", "Load a protocol as active"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Protocol Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus protocol <command> --help")
    raise typer.Exit(1)


@protocol_app.callback(invoke_without_command=True)
def protocol_callback(ctx: typer.Context):
    """
    Manage development protocols.
    """
    if ctx.invoked_subcommand is None:
        command_rows = [
            ["erasmus protocol list", "List all protocols"],
            ["erasmus protocol create", "Create a new protocol"],
            ["erasmus protocol show", "Show protocol details"],
            ["erasmus protocol update", "Update a protocol"],
            ["erasmus protocol edit", "Edit a protocol"],
            ["erasmus protocol delete", "Delete a protocol"],
            ["erasmus protocol select", "Select and display a protocol"],
            ["erasmus protocol load", "Load a protocol as active"],
        ]
        print_table(
            ["Command", "Description"],
            command_rows,
            title="Available Protocol Commands",
        )
        typer.echo("\nFor more information about a command, run:")
        typer.echo("  erasmus protocol <command> --help")
        raise typer.Exit(0)


@protocol_app.command()
def create(
    name: str = typer.Argument(None, help="Name of the protocol to create"),
    content: str = typer.Argument(None, help="Content of the protocol"),
):
    """Create a new protocol.

    This command creates a new protocol file with optional content.
    The protocol name will be sanitized to ensure it's safe for filesystem operations.
    """
    try:
        if not name:
            name = typer.prompt("Enter the protocol name")
        if not name:
            print_table(
                ["Error"],
                [["Protocol name is required."]],
                title="Protocol Creation Failed",
            )
            raise typer.Exit(1)
        if content is None:
            content = typer.prompt("Enter the protocol content (leave blank to use template)")
        protocol_manager.create_protocol(name, content)
        logger.info(f"Created protocol: {name}")
        print_table(["Info"], [[f"Created protocol: {name}"]], title="Protocol Created")
        raise typer.Exit(0)
    except ProtocolError as e:
        logger.error(f"Failed to create protocol: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def update(
    name: str = typer.Argument(None, help="Name of the protocol to update"),
    content: str = typer.Argument(None, help="New content for the protocol"),
):
    """Update an existing protocol.

    This command updates the content of an existing protocol.
    The protocol must exist before it can be updated.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Update Failed",
                )
                raise typer.Exit(1)
            name = selected
        if content is None:
            content = typer.prompt("Enter the new protocol content")
        if not content:
            print_table(
                ["Error"],
                [["Protocol content is required."]],
                title="Protocol Update Failed",
            )
            raise typer.Exit(1)
        protocol_manager.update_protocol(name, content)
        logger.info(f"Updated protocol: {name}")
        print_table(["Info"], [[f"Updated protocol: {name}"]], title="Protocol Updated")
        raise typer.Exit(0)
    except ProtocolError as e:
        logger.error(f"Failed to update protocol: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def delete(name: str = typer.Argument(None, help="Name of the protocol to delete")):
    """Delete a protocol.

    This command permanently removes a protocol file.
    Use with caution as this action cannot be undone.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Deletion Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol_manager.delete_protocol(name)
        logger.info(f"Deleted protocol: {name}")
        print_table(["Info"], [[f"Deleted protocol: {name}"]], title="Protocol Deleted")
        raise typer.Exit(0)
    except (ProtocolError, PermissionError, FileNotFoundError) as e:
        print_table(["Error"], [[str(e)]], title="Protocol Deletion Failed")
        raise typer.Exit(1)


@protocol_app.command()
def list():
    """List all protocols.

    This command shows all available protocols and their basic information.
    Use 'show' to view detailed information about a specific protocol.
    """
    try:
        protocols = protocol_manager.list_protocols()
        if not protocols:
            typer.echo("No protocols found")
            return

        # Display protocols in a table
        protocol_rows = [[protocol] for protocol in protocols]
        print_table(["Protocol Name"], protocol_rows, title="Available Protocols")
    except ProtocolError as e:
        logger.error(f"Failed to list protocols: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def show(name: str = typer.Argument(None, help="Name of the protocol to show")):
    """Show details of a protocol.

    This command displays detailed information about a specific protocol,
    including its content and metadata.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Show Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Show Failed",
            )
            raise typer.Exit(1)
        print_table(["Info"], [[f"Protocol: {name}"]], title="Protocol Details")
        typer.echo(f"Path: {protocol.path}")
        typer.echo(f"Content:\n{protocol.content}")
        raise typer.Exit(0)
    except ProtocolError as e:
        print_table(["Error"], [[str(e)]], title="Protocol Show Failed")
        raise typer.Exit(1)


@protocol_app.command("select")
def select_protocol():
    """Interactively select a protocol, display its details, and update the rules file with it."""
    try:
        protocols = protocol_manager.list_protocols()
        if not protocols:
            print_table(["Info"], [["No protocols found"]], title="Available Protocols")
            raise typer.Exit(1)
        protocol_rows = [
            [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
        ]
        print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            index = int(choice)
            if 1 <= index <= len(protocols):
                selected = protocols[index - 1]
        else:
            if choice in protocols:
                selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        protocol = protocol_manager.get_protocol(selected)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {selected}"]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        print_table(["Info"], [[f"Selected protocol: {selected}"]], title="Protocol Selected")
        typer.echo(f"Path: {protocol.path}")
        typer.echo(f"Content:\n{protocol.content}")
        # Write the selected protocol name to .erasmus/current_protocol.txt


        path_manager = get_path_manager()
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        current_protocol_path.write_text(selected)
        # Also update the rules file as in load
        template_path = path_manager.template_dir / "meta_rules.md"
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.md template not found."]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        meta_rules_content = template_path.read_text()
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        meta_rules_content = meta_rules_content.replace(
            "<!--ARCHITECTURE-->\n  <!--/ARCHITECTURE-->", architecture
        )
        meta_rules_content = meta_rules_content.replace(
            "<!--PROGRESS-->\n  <!--/PROGRESS-->", progress
        )
        meta_rules_content = meta_rules_content.replace("<!--TASKS-->\n  <!--/TASKS-->", tasks)
        meta_rules_content = meta_rules_content.replace(
            "<!--PROTOCOL-->\n  <!--/PROTOCOL-->", protocol.content
        )
        rules_file = path_manager.get_rules_file()
        if not rules_file:
            print_table(
                ["Error"],
                [["No rules file configured."]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Updated rules file with protocol: {selected}"]],
            title="Rules File Updated",
        )
        raise typer.Exit(0)
    except ProtocolError as exception:
        print_table(["Error"], [[str(exception)]], title="Protocol Select Failed")
        raise typer.Exit(1)


@protocol_app.command("load")
def load_protocol(
    name: str = typer.Argument(None, help="Name of the protocol to load"),
):
    """Interactively select and load a protocol, merging it into the rules file with current context."""
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Load Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Load Failed",
            )
            raise typer.Exit(1)
        # Write the selected protocol name to .erasmus/current_protocol.txt


        path_manager = get_path_manager()
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        current_protocol_path.write_text(name)
        # Load meta_rules.md template
        template_path = path_manager.template_dir / "meta_rules.md"
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.md template not found."]],
                title="Protocol Load Failed",
            )
            raise typer.Exit(1)
        meta_rules_content = template_path.read_text()
        # Read current context files
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        # Replace context and protocol blocks using regex for robustness
        meta_rules_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            meta_rules_content,
        )
        meta_rules_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, meta_rules_content
        )
        meta_rules_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, meta_rules_content)
        meta_rules_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->",
            protocol.content,
            meta_rules_content,
        )
        # Write to rules file
        rules_file = path_manager.get_rules_file()
        if not rules_file:
            print_table(["Error"], [["No rules file configured."]], title="Protocol Load Failed")
            raise typer.Exit(1)
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Loaded protocol: {name} into rules file"]],
            title="Protocol Loaded",
        )
        raise typer.Exit(0)
    except ProtocolError as exception:
        print_table(["Error"], [[str(exception)]], title="Protocol Load Failed")
        raise typer.Exit(1)


@protocol_app.command()
def edit(
    name: str = typer.Argument(None, help="Name of the protocol to edit"),
    editor: str = typer.Argument(None, help="Editor to use for editing"),
):
    """Edit a protocol file in your default editor (or specified editor)."""
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Edit Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Edit Failed",
            )
            raise typer.Exit(1)
        file_path = protocol.path
        editor_cmd = editor or os.environ.get("EDITOR", "nano")
        os.system(f"{editor_cmd} {file_path}")
        print_table(["Info"], [[f"Edited protocol: {name}"]], title="Protocol Edited")
        raise typer.Exit(0)
    except ProtocolError as error:
        print_table(["Error"], [[str(error)]], title="Protocol Edit Failed")
        raise typer.Exit(1)


@protocol_app.command("watch")
def watch_protocol():
    """Monitor .ctx.*.md files for changes and update the rules file with the current protocol. Does NOT monitor the rules file itself."""
    import time



    path_manager = get_path_manager()
    protocol_manager = ProtocolManager()
    ctx_files = [
        path_manager.get_architecture_file(),
        path_manager.get_progress_file(),
        path_manager.get_tasks_file(),
    ]
    template_path = path_manager.template_dir / "meta_rules.md"
    rules_file = path_manager.get_rules_file()
    current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"

    def get_protocol_name():
        if current_protocol_path.exists():
            return current_protocol_path.read_text().strip()
        protocols = protocol_manager.list_protocols()
        if not protocols:
            print_table(["Error"], [["No protocols found."]], title="Protocol Watch Failed")
            raise typer.Exit(1)
        protocol_rows = [[str(i + 1), p] for i, p in enumerate(protocols)]
        print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            idx = int(choice)
            if 1 <= idx <= len(protocols):
                selected = protocols[idx - 1]
        elif choice in protocols:
            selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Protocol Watch Failed",
            )
            raise typer.Exit(1)
        current_protocol_path.write_text(selected)
        return selected

    def merge_and_write():
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.md template not found."]],
                title="Protocol Watch Failed",
            )
            return
        meta_rules_content = template_path.read_text()
        architecture = ctx_files[0].read_text() if ctx_files[0].exists() else ""
        progress = ctx_files[1].read_text() if ctx_files[1].exists() else ""
        tasks = ctx_files[2].read_text() if ctx_files[2].exists() else ""
        meta_rules_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            meta_rules_content,
        )
        meta_rules_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, meta_rules_content
        )
        meta_rules_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, meta_rules_content)
        protocol_name = get_protocol_name()
        protocol = protocol_manager.get_protocol(protocol_name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {protocol_name}"]],
                title="Protocol Watch Failed",
            )
            return
        meta_rules_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->",
            protocol.content,
            meta_rules_content,
        )
        if not rules_file:
            print_table(
                ["Error"],
                [["No rules file configured."]],
                title="Protocol Watch Failed",
            )
            return
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Rules file updated with protocol: {protocol_name}"]],
            title="Rules File Updated",
        )

    # Track last modification times for only the .ctx.*.md files
    last_mtimes = [f.stat().st_mtime if f.exists() else 0 for f in ctx_files]
    print_table(["Info"], [["Watching .ctx.*.md files for changes..."]], title="Protocol Watch")
    try:
        while True:
            changed = False
            for i, f in enumerate(ctx_files):
                if f.exists():
                    mtime = f.stat().st_mtime
                    if mtime != last_mtimes[i]:
                        changed = True
                        last_mtimes[i] = mtime
            if changed:
                merge_and_write()
            time.sleep(1)
    except KeyboardInterrupt:
        print_table(["Info"], [["Stopped watching context files."]], title="Protocol Watch")



show_protocol_help_and_exit = show_protocol_help_and_exit
protocol_callback = protocol_callback
create = create
update = update
delete = delete
list = list
show = show
select_protocol = select_protocol
load_protocol = load_protocol
edit = edit
watch_protocol = watch_protocol

# setup_commands.py
import typer
import re
from pathlib import Path



setup_app = typer.Typer(help="Setup Erasmus: initialize project, environment, and context.")

console = get_console()


def set_erasmus_path():
    import os

    shell = os.environ.get("SHELL", "").split("/")[-1]
    home = str(Path.home())
    added = False
    msg = ""
    erasmus_func = """erasmus() {
    if [ -f erasmus.py ]; then
        uv run erasmus.py "$@"
    else
        command erasmus "$@"
    fi
}"""
    erasmus_fish_func = """function erasmus
    if test -f erasmus.py
        uv run erasmus.py $argv
    else
        command erasmus $argv
    end
end"""
    if shell == "bash":
        rc = f"{home}/.bashrc"
        if not Path(rc).read_text(errors="ignore").find("erasmus()") >= 0:
            with open(rc, "a") as f:
                f.write(f"\n{erasmus_func}\n")
            msg = f"Added erasmus function to {rc}"
            added = True
    elif shell == "zsh":
        rc = f"{home}/.zshrc"
        if not Path(rc).read_text(errors="ignore").find("erasmus()") >= 0:
            with open(rc, "a") as f:
                f.write(f"\n{erasmus_func}\n")
            msg = f"Added erasmus function to {rc}"
            added = True
    elif shell == "fish":
        rc = f"{home}/.config/fish/config.fish"
        if not Path(rc).read_text(errors="ignore").find("function erasmus") >= 0:
            with open(rc, "a") as f:
                f.write(f"\n{erasmus_fish_func}\n")
            msg = f"Added erasmus function to {rc}"
            added = True
    elif shell in ("csh", "tcsh"):
        rc = f"{home}/.cshrc" if shell == "csh" else f"{home}/.tcshrc"
        if not Path(rc).read_text(errors="ignore").find("alias erasmus") >= 0:
            with open(rc, "a") as f:
                f.write(
                    '\nalias erasmus "if ( -f erasmus.py ) uv run erasmus.py !*; else command erasmus !*; endif"\n'
                )
            msg = f"Added erasmus alias to {rc}"
            added = True
    else:
        msg = f"Unsupported shell: {shell}. Please add the erasmus function to your shell rc file manually."
    if added:
        print(msg)
    else:
        print(msg or "erasmus function/alias already present in your shell rc file.")


@setup_app.callback(invoke_without_command=True)
def setup_callback(ctx: typer.Context):
    if ctx.invoked_subcommand is not None:
        return
    """Interactive setup for Erasmus: configure IDE, project, context, and protocol."""
    # Step 1: Use path manager for IDE detection and prompting
    path_manager = get_path_manager()
    print_table(["Info"], [[f"IDE detected: {path_manager.ide.name}"]], title="Setup")

    # Step 2: Ensure Erasmus directories exist
    path_manager.ensure_dirs()
    print_table(["Info"], [[f"Erasmus folders created in: {path_manager.erasmus_dir}"]], title="Setup")

    # Step 3: Set up shell integration
    set_erasmus_path()

    # Step 4: List available contexts and allow creating new
    contexts = [d.name for d in sorted(path_manager.get_context_dir().iterdir()) if d.is_dir()]
    context_rows = [["0", "Create New Context"]] + [
        [str(i + 1), name] for i, name in enumerate(contexts)
    ]
    print_table(["#", "Context Name"], context_rows, title="Available Contexts")
    
    choice = typer.prompt("Select a context by number or name (0 to create new)")
    
    # Handle context selection
    if choice == "0":
        context_name = typer.prompt("Enter name for new context")
        if not context_name:
            print_table(["Error"], [["Context name is required"]], title="Setup Failed")
            raise typer.Exit(1)
    else:
        # Find existing context
        selected = None
        if choice.isdigit():
            idx = int(choice)
            if 1 <= idx <= len(contexts):
                selected = contexts[idx - 1]
        else:
            if choice in contexts:
                selected = choice
        if not selected:
            print_table(["Error"], [[f"Invalid selection: {choice}"]], title="Setup Failed")
            raise typer.Exit(1)
        context_name = selected

    # Create or load context files
    ctx_dir = path_manager.get_context_dir() / context_name
    ctx_dir.mkdir(parents=True, exist_ok=True)
    
    # Set up context files
    ctx_files = [
        (ctx_dir / '.ctx.architecture.md', path_manager.architecture_template),
        (ctx_dir / '.ctx.tasks.md', path_manager.tasks_template),
        (ctx_dir / '.ctx.progress.md', path_manager.progress_template)
    ]
    
    for target_file, template_file in ctx_files:
        if not target_file.exists():
            if template_file.exists():
                content = template_file.read_text()
                # Replace title in template
                content = re.sub(r'<Title>.*?</Title>', f'<Title>{context_name}</Title>', content)
                content = re.sub(r'^# [^\n]*', f'# {context_name}', content)
            else:
                # Default content with title
                file_type = target_file.stem.split('.')[-1]
                content = f'# {context_name} {file_type.capitalize()}\n\n'
                if file_type == 'tasks':
                    content += '- [ ] Initial project setup\n'
                elif file_type == 'progress':
                    content += '## Current Sprint\n\n- Project initialized\n'
                elif file_type == 'architecture':
                    content += 'Define your system architecture here.\n'
            target_file.write_text(content)
    
    # Copy context files to root
    for ctx_file in ctx_files:
        target = Path(ctx_file[0].name)
        if ctx_file[0].exists():
            target.write_text(ctx_file[0].read_text())
    
    print_table(["Info"], [[f"Context {context_name} set up and loaded"]], title="Setup")

    # Step 6: Prompt for protocol selection
    protocol_manager = ProtocolManager()
    protocols = protocol_manager.list_protocols()
    if not protocols:
        print_table(["Error"], [["No protocols found."]], title="Setup Failed")
        raise typer.Exit(1)
    protocol_rows = [[str(i + 1), p] for i, p in enumerate(protocols)]
    print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
    while True:
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            idx = int(choice)
            if 1 <= idx <= len(protocols):
                selected = protocols[idx - 1]
        elif choice in protocols:
            selected = choice
        if selected:
            # Write the selected protocol to current_protocol.txt using path manager
            current_protocol_path = path_manager.erasmus_dir / "current_protocol.txt"
            current_protocol_path.write_text(selected)
            print_table(["Info"], [[f"Protocol set to: {selected}"]], title="Setup")
            # Immediately update the rules file to reflect the selected protocol
            try:


                _merge_rules_file()
                print_table(
                    ["Info"],
                    [[f"Rules file updated with protocol: {selected}"]],
                    title="Setup",
                )
            except Exception as e:
                print_table(
                    ["Error"],
                    [[f"Failed to update rules file: {e}"]],
                    title="Setup Warning",
                )
            break
        print(f"Invalid selection: {choice}")

    print_table(["Info"], [["Erasmus setup complete."]], title="Setup Success")
    raise typer.Exit(0)

set_erasmus_path = set_erasmus_path
setup_callback = setup_callback

# main.py
import typer



app = typer.Typer(
    help="Erasmus - Development Context Management System\n\nA tool for managing development contexts, protocols, and Model Context Protocol (MCP) interactions.\n\nFor more information, visit: https://github.com/hydra-dynamics/erasmus"
)


# Add sub-commands
app.add_typer(context_app, name="context", help="Manage development contexts")
app.add_typer(protocol_app, name="protocol", help="Manage protocols")
app.add_typer(setup_app, name="setup", help="Setup Erasmus")
app.add_typer(mcp_app, name="mcp", help="Manage MCP servers, clients, and integrations")


# Custom error handler for unknown commands and argument errors
def print_main_help_and_exit():
    try:
        from rich.console import Console

        console = Console()
        banner = [
            ("green", " _____                                  "),
            ("green", "|  ___|                                 "),
            ("cyan", "| |__ _ __ __ _ ___ _ __ ___  _   _ ___ "),
            ("green", "|  __| '__/ _` / __| '_ ` _ \\| | | / __|"),
            ("cyan", "| |__| | | (_| \\__ \\ | | | | | |_| \\__ \\"),
            ("green", "\\____/_|  \\__,_|___/_| |_| |_|\\__,_|___/"),
        ]
        for color, line in banner:
            console.print(line, style=color)
    except ImportError:
        # Fallback to plain text if rich is not available
        typer.echo(r"""
 _____                                  
|  ___|                                 
| |__ _ __ __ _ ___ _ __ ___  _   _ ___ 
|  __| '__/ _` / __| '_ ` _ \| | | / __|
| |__| | | (_| \__ \ | | | | | |_| \__ \
\____/_|  \__,_|___/_| |_| |_|\__,_|___/
""")
    typer.echo("\n Development Context Management System\n")
    command_rows = [
        ["erasmus context", "Manage development contexts"],
        ["erasmus protocol", "Manage protocols"],
        ["erasmus mcp", "Manage MCP servers, clients, and integrations"],
        ["erasmus setup", "Setup Erasmus"],
        ["erasmus watch", "Watch for .ctx file changes"],
        ["erasmus status", "Show current status"],
        ["erasmus version", "Show Erasmus version"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Erasmus Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus <command> --help")
    raise typer.Exit(1)


@app.callback(invoke_without_command=True)
def main(ctx: typer.Context):
    """
    Erasmus - Development Context Management System
    """
    if ctx.invoked_subcommand is None:
        print_main_help_and_exit()


# Patch Typer's error handling to show help on unknown command
from typer.main import get_command
from typer.core import TyperGroup
from click import UsageError

original_command = get_command(app)


class HelpOnErrorGroup(TyperGroup):
    def main(self, *args, **kwargs):
        try:
            return super().main(*args, **kwargs)
        except UsageError as e:
            typer.echo(str(e))
            print_main_help_and_exit()


app.command_class = HelpOnErrorGroup


@app.command()
def watch():  # pragma: no cover
    """Watch for changes to .ctx files and update the IDE rules file automatically.

    Press Ctrl+C to stop watching.
    """


    from loguru import logger

    pm = get_path_manager()
    root = pm.get_root_dir()

    # Configure logger for file monitoring
    logger.add(
        pm.get_log_dir() / "file_monitor.log", rotation="1 day", retention="7 days", level="INFO"
    )

    monitor = ContextFileMonitor()

    try:
        with monitor:
            typer.echo(f"Watching {root} for .ctx file changes (Ctrl+C to stop)...")
            typer.echo("Log file: " + str(pm.get_log_dir() / "file_monitor.log"))

            # Keep the main thread alive
            import signal

            signal.pause()
    except KeyboardInterrupt:
        typer.echo("\nStopped watching.")
    except Exception as e:
        logger.error(f"Error during file monitoring: {e}")
        typer.echo(f"Error: {e}")
        raise typer.Exit(1)


@app.command()
def status():
    """Show the current Erasmus context and protocol status."""


    import os

    context_manager = ContextManager()
    protocol_manager = ProtocolManager()

    # Current context (from .erasmus/current_context.txt if exists)
    current_context = None
    current_context_path = os.path.join(context_manager.base_dir.parent, "current_context.txt")
    if os.path.exists(current_context_path):
        with open(current_context_path) as f:
            current_context = f.read().strip()

    # List all contexts
    try:
        contexts = context_manager.list_contexts()
    except Exception as e:
        contexts = []

    # List all protocols
    try:
        protocols = protocol_manager.list_protocols()
    except Exception as e:
        protocols = []

    print_table(
        ["Status", "Value"],
        [
            ["Current Context", current_context or "(none set)"],
            ["Available Contexts", ", ".join(contexts) if contexts else "(none)"],
            ["Available Protocols", ", ".join(protocols) if protocols else "(none)"],
        ],
        title="Erasmus Status",
    )


@app.command()
def version():
    """Show the Erasmus version."""


    typer.echo(f"Erasmus version: {erasmus.__version__}")




if __name__ == '__main__':
    app()
