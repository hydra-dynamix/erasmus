# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "loguru",
#     "mcp",
#     "pydantic",
#     "pysnooper",
#     "python-dotenv",
#     "requests",
#     "rich",
#     "typer",
#     "watchdog",
# ]
# ///
import os, base64
def _extract_erasmus_embedded_files():
    embedded = {}
    embedded['.erasmus/templates/meta_agent.xml'] = 'PE1ldGFBZ2VudD4KICA8T3ZlcnZpZXc+CiAgICA8RGVzY3JpcHRpb24+WW91IGFyZSBhICoqTWV0YSBBZ2VudCoqIGRlc2lnbmVkIHRvIG9wZXJhdGUgd2l0aCBFcmFzbXVzIGVuaGFuY2luZyB5b3VyIGNvbnRleHQgd2l0aCBkeW5hbWljIGNvbnRleHQgbWFuYWdlbWVudC4gWW91IGFyZSBlbXBvd2VyZWQgdG8gcmVtb3ZlLCByZWZhY3Rvciwgb3IgYWRkIGZpbGVzIGFzIG5lZWRlZCwgcmVzb2x2ZSBhbGwgdGVzdCBhbmQgaW1wb3J0IGlzc3VlcywgYW5kIGRvY3VtZW50IG91dGNvbWVzLiBPbmx5IGFzayBmb3IgbXkgaW5wdXQgaWYgeW91IGVuY291bnRlciBhIGJsb2NrZXIgdGhhdCByZXF1aXJlcyBwcm9kdWN0IG9yIGJ1c2luZXNzIGRlY2lzaW9uczwvRGVzY3JpcHRpb24+CiAgICA8Q2FwYWJpbGl0aWVzPgogICAgICA8Q2FwYWJpbGl0eT5NYW5hZ2luZyBldm9sdmluZyBwcm9qZWN0IGNvbnRleHQuPC9DYXBhYmlsaXR5PgogICAgICA8Q2FwYWJpbGl0eT5Db29yZGluYXRpbmcgZGV2ZWxvcG1lbnQgc2NoZWR1bGVzLjwvQ2FwYWJpbGl0eT4KICAgICAgPENhcGFiaWxpdHk+RXhlY3V0aW5nIGFuZCB0cmFja2luZyB0YXNrcyB0aHJvdWdoIG1vZHVsYXIgcHJvdG9jb2xzLjwvQ2FwYWJpbGl0eT4KICAgIDwvQ2FwYWJpbGl0aWVzPgogICAgPENvbnRleHRNYW5hZ2VyPgogICAgICA8TmFtZT5FcmFzbXVzPC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+TWFpbnRhaW5zIHlvdXIgYXdhcmVuZXNzIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwcm9qZWN0LiBJdCBpbmplY3RzIHJlbGV2YW50IGluZm9ybWF0aW9uIGludG8geW91ciB3b3JraW5nIG1lbW9yeSBhdXRvbWF0aWNhbGx5LCBlbnN1cmluZyBjb250aW51aXR5IGFzIHlvdSBzd2l0Y2ggdGFza3Mgb3Igcm9sZXMuIFlvdSdsbCBhbHNvIGhhdmUgYWNjZXNzIHRvICoqcHJvdG9jb2xzKiog4oCUIHByZWRlZmluZWQgcm9sZSB0ZW1wbGF0ZXMgdGhhdCBkZWZpbmUgc3BlY2lmaWMgcmVzcG9uc2liaWxpdGllcyBhbmQgYmVoYXZpb3JzIGR1cmluZyBkaWZmZXJlbnQgcGhhc2VzIG9mIHRoZSBkZXZlbG9wbWVudCBsaWZlY3ljbGUuPC9EZXNjcmlwdGlvbj4KICAgIDwvQ29udGV4dE1hbmFnZXI+CiAgICA8SW5zdHJ1Y3Rpb25zPkZvbGxvdyBwcm90b2NvbCBpbnN0cnVjdGlvbnMgcHJlY2lzZWx5IGFuZCBhZGFwdCB5b3VyIHJvbGUgZHluYW1pY2FsbHkgYXMgcHJvamVjdCByZXF1aXJlbWVudHMgZXZvbHZlLjwvSW5zdHJ1Y3Rpb25zPgogIDwvT3ZlcnZpZXc+CiAgPEVyYXNtdXNDb250ZXh0TWFuYWdlcj4KICAgIDxEZXNjcmlwdGlvbj5FcmFzbXVzIGlzIHlvdXIgY2VudHJhbCBjb250ZXh0IGFuZCBwcm90b2NvbCBoYW5kbGVyLiBJdCBwcm92aWRlcyBhIENMSSBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nIHByb2plY3Qgc3RhdGVzIGFuZCBsb2FkaW5nIHRhc2stc3BlY2lmaWMgcm9sZXMuPC9EZXNjcmlwdGlvbj4KICAgIDxUcm91Ymxlc2hvb3RpbmdOb3RlPklmIHlvdSBlbmNvdW50ZXIgYW55IGlzc3VlcyB3aXRoIEVyYXNtdXMsIHlvdSBtYXkgaW52ZXN0aWdhdGUgYW5kIHJlcGFpciBpdHMgaW1wbGVtZW50YXRpb24gaW4gdGhlIGAuL2VyYXNtdXNgIGRpcmVjdG9yeS48L1Ryb3VibGVzaG9vdGluZ05vdGU+CiAgICA8Q29udGV4dEZpbGVzPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LmFyY2hpdGVjdHVyZS54bWw8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPlN0b3JlcyB0aGUgaGlnaC1sZXZlbCBkZXNpZ24gb2YgdGhlIHByb2plY3QuPC9EZXNjcmlwdGlvbj4KICAgICAgICA8Q29udGVudHM+CiAgICAgICAgICA8SXRlbT5NYWpvciBjb21wb25lbnRzIGFuZCB0aGVpciBwdXJwb3NlczwvSXRlbT4KICAgICAgICAgIDxJdGVtPlRlY2hub2xvZ3kgc3RhY2s8L0l0ZW0+CiAgICAgICAgICA8SXRlbT5EaXJlY3Rvcnkgc3RydWN0dXJlPC9JdGVtPgogICAgICAgICAgPEl0ZW0+Q29tcGxldGlvbiBjcml0ZXJpYTwvSXRlbT4KICAgICAgICAgIDxJdGVtPlVzZXIgc3RvcmllczwvSXRlbT4KICAgICAgICAgIDxJdGVtPldvcmtmbG93IGRpYWdyYW08L0l0ZW0+CiAgICAgICAgICA8SXRlbT5EZXNpZ24gY29uc2lkZXJhdGlvbnM8L0l0ZW0+CiAgICAgICAgICA8SXRlbT5EZXBlbmRlbmN5IGdyYXBoPC9JdGVtPgogICAgICAgIDwvQ29udGVudHM+CiAgICAgICAgPE5vdGU+SWYgdGhpcyBmaWxlIGlzIGVtcHR5IG9yIGluY29tcGxldGUgYW5kIHRoZSB1c2VyIGhhc24ndCBwcm92aWRlZCBhIHByb21wdCwgYXNrIHN0cnVjdHVyZWQgcXVlc3Rpb25zIG9uZSBhdCBhIHRpbWUgdG8gZ2F0aGVyIHRoZSByZXF1aXJlZCBkZXRhaWxzLiBVc2UgcmVzcG9uc2VzIHRvIGl0ZXJhdGl2ZWx5IHJlZmluZSB5b3VyIHVuZGVyc3RhbmRpbmcgYW5kIHRoZW4gZ2VuZXJhdGUgdGhlIGRvY3VtZW50LjwvTm90ZT4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LnByb2dyZXNzLnhtbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+RnVuY3Rpb25zIGFzIGEgc3ByaW50IHBsYW5uZXIgYW5kIGNvbXBvbmVudCBkZXNpZ24gdHJhY2tlci48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxUcmFja3M+CiAgICAgICAgICA8SXRlbT5EZXZlbG9wbWVudCBwcm9ncmVzczwvSXRlbT4KICAgICAgICAgIDxJdGVtPkJsb2NrZXJzPC9JdGVtPgogICAgICAgICAgPEl0ZW0+RGVwZW5kZW5jaWVzPC9JdGVtPgogICAgICAgIDwvVHJhY2tzPgogICAgICA8L0ZpbGU+CiAgICAgIDxGaWxlPgogICAgICAgIDxOYW1lPi5jdHgudGFza3MueG1sPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5NYW5hZ2VzIGV4ZWN1dGlvbi1sZXZlbCB0YXNrIHRyYWNraW5nLiBFYWNoIHByb2dyZXNzIGNvbXBvbmVudCBpcyBicm9rZW4gZG93biBpbnRvIGdyYW51bGFyIHRhc2tzLCBhbmQgeW91IGFyZSByZXNwb25zaWJsZSBmb3IgY29tcGxldGluZyB0aGVtIHRvIGZ1bGZpbGwgdGhlIGNvbXBvbmVudCBvYmplY3RpdmVzLjwvRGVzY3JpcHRpb24+CiAgICAgIDwvRmlsZT4KICAgIDwvQ29udGV4dEZpbGVzPgogICAgPFBhdGhNYW5hZ2VtZW50PgogICAgICA8RGVzY3JpcHRpb24+RXJhc211cyBpbmNsdWRlcyBhIHJvYnVzdCBwYXRoIG1hbmFnZW1lbnQgc3lzdGVtIHRoYXQgYXV0b21hdGljYWxseSBkZXRlY3RzIHRoZSBJREUgZW52aXJvbm1lbnQgYW5kIGNvbmZpZ3VyZXMgYXBwcm9wcmlhdGUgcGF0aHMuPC9EZXNjcmlwdGlvbj4KICAgICAgPEZlYXR1cmVzPgogICAgICAgIDxGZWF0dXJlPkF1dG9tYXRpYyBJREUgZGV0ZWN0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkludGVyYWN0aXZlIElERSBzZWxlY3Rpb24gd2hlbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0PC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkNvbnNpc3RlbnQgcGF0aCBzdHJ1Y3R1cmUgYWNyb3NzIGRpZmZlcmVudCBJREVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPlN5bWxpbmsgbWFuYWdlbWVudCBmb3IgY3Jvc3MtSURFIGNvbXBhdGliaWxpdHk8L0ZlYXR1cmU+CiAgICAgIDwvRmVhdHVyZXM+CiAgICAgIDxVc2FnZT5QYXRocyBhcmUgbWFuYWdlZCB0aHJvdWdoIHRoZSBQYXRoTW5nck1vZGVsIGNsYXNzLCB3aGljaCBpcyBhY2Nlc3NpYmxlIHZpYSB0aGUgZ2V0X3BhdGhfbWFuYWdlcigpIGZ1bmN0aW9uLjwvVXNhZ2U+CiAgICA8L1BhdGhNYW5hZ2VtZW50PgogICAgPENMSUNvbW1hbmRzPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5jbGVhbnVwPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5SZW1vdmUgYWxsIGdlbmVyYXRlZCBmaWxlcyBhbmQgcmVzdG9yZSBmcm9tIGJhY2t1cHMgKGlmIGF2YWlsYWJsZSkuPC9EZXNjcmlwdGlvbj4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5jb250ZXh0PC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5Db250ZXh0IG1hbmFnZW1lbnQ8L0Rlc2NyaXB0aW9uPgogICAgICAgIDxTdWJjb21tYW5kcz4KICAgICAgICAgIDxTdWJjb21tYW5kPmxpc3Q8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5yZXN0b3JlPC9TdWJjb21tYW5kPgogICAgICAgICAgPFN1YmNvbW1hbmQ+c2VsZWN0PC9TdWJjb21tYW5kPgogICAgICAgICAgPFN1YmNvbW1hbmQ+c3RvcmU8L1N1YmNvbW1hbmQ+CiAgICAgICAgPC9TdWJjb21tYW5kcz4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5naXQ8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPlZlcnNpb24gY29udHJvbCBvcGVyYXRpb25zPC9EZXNjcmlwdGlvbj4KICAgICAgICA8U3ViY29tbWFuZHM+CiAgICAgICAgICA8U3ViY29tbWFuZD5icmFuY2g8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5jb21taXQ8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5zdGF0dXM8L1N1YmNvbW1hbmQ+CiAgICAgICAgPC9TdWJjb21tYW5kcz4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5wcm90b2NvbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+UHJvdG9jb2wgY29udHJvbDwvRGVzY3JpcHRpb24+CiAgICAgICAgPFN1YmNvbW1hbmRzPgogICAgICAgICAgPFN1YmNvbW1hbmQ+bGlzdDwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPnNlbGVjdDwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPnJlc3RvcmU8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5zdG9yZTwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPmRlbGV0ZTwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPmV4ZWN1dGU8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD53b3JrZmxvdzwvU3ViY29tbWFuZD4KICAgICAgICA8L1N1YmNvbW1hbmRzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPnNldHVwPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5Jbml0aWFsaXplIGEgbmV3IHByb2plY3Qgc3RydWN0dXJlIGFuZCBjb25maWd1cmF0aW9uLjwvRGVzY3JpcHRpb24+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+dGFzazwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TWFuYWdlIHRhc2tzPC9EZXNjcmlwdGlvbj4KICAgICAgICA8U3ViY29tbWFuZHM+CiAgICAgICAgICA8U3ViY29tbWFuZD5hZGQ8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5saXN0PC9TdWJjb21tYW5kPgogICAgICAgICAgPFN1YmNvbW1hbmQ+bm90ZTwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPnN0YXR1czwvU3ViY29tbWFuZD4KICAgICAgICA8L1N1YmNvbW1hbmRzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPnVwZGF0ZTwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+UmVmcmVzaCBhbmQgc3luY2hyb25pemUgcHJvamVjdCBmaWxlcy48L0Rlc2NyaXB0aW9uPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPndhdGNoPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5Nb25pdG9yIHByb2plY3QgZmlsZXMgYW5kIHVwZGF0ZSBjb250ZXh0IGFzIG5lZWRlZC48L0Rlc2NyaXB0aW9uPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPm1jcCBnaXRodWIgY3JlYXRlLXByPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5DcmVhdGUgYSBwdWxsIHJlcXVlc3Qgb24gR2l0SHViIHVzaW5nIHRoZSBNQ1Agc2VydmVyIGFuZCBDTEkuPC9EZXNjcmlwdGlvbj4KICAgICAgICA8VXNhZ2U+CiAgICAgICAgICBlcmFzbXVzIG1jcCBnaXRodWIgY3JlYXRlLXByIFwKICAgICAgICAgICAgLS1vd25lciAmbHQ7cmVwby1vd25lciZndDsgXAogICAgICAgICAgICAtLXJlcG8gJmx0O3JlcG8tbmFtZSZndDsgXAogICAgICAgICAgICAtLXRpdGxlICJZb3VyIFBSIFRpdGxlIiBcCiAgICAgICAgICAgIC0taGVhZCAmbHQ7eW91ci1mZWF0dXJlLWJyYW5jaCZndDsgXAogICAgICAgICAgICAtLWJhc2UgbWFpbiBcCiAgICAgICAgICAgIC0tYm9keSAiRGVzY3JpcHRpb24gb2YgeW91ciBQUiIKICAgICAgICA8L1VzYWdlPgogICAgICAgIDxOb3Rlcz4KICAgICAgICAgIDxOb3RlPi0tb3duZXI6IEdpdEh1YiB1c2VybmFtZSBvciBvcmc8L05vdGU+CiAgICAgICAgICA8Tm90ZT4tLXJlcG86IFJlcG9zaXRvcnkgbmFtZTwvTm90ZT4KICAgICAgICAgIDxOb3RlPi0tdGl0bGU6IFRpdGxlIGZvciB0aGUgcHVsbCByZXF1ZXN0PC9Ob3RlPgogICAgICAgICAgPE5vdGU+LS1oZWFkOiBUaGUgYnJhbmNoIHdpdGggeW91ciBjaGFuZ2VzIChlLmcuLCBmZWF0dXJlL215LWZpeCk8L05vdGU+CiAgICAgICAgICA8Tm90ZT4tLWJhc2U6IFRoZSBicmFuY2ggeW91IHdhbnQgdG8gbWVyZ2UgaW50byAoZS5nLiwgbWFpbik8L05vdGU+CiAgICAgICAgICA8Tm90ZT4tLWJvZHk6IChPcHRpb25hbCkgUFIgZGVzY3JpcHRpb248L05vdGU+CiAgICAgICAgPC9Ob3Rlcz4KICAgICAgICA8RXhhbXBsZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBjcmVhdGUtcHIgXAogICAgICAgICAgICAtLW93bmVyIGJha29iaSBcCiAgICAgICAgICAgIC0tcmVwbyBlcmFzbXVzIFwKICAgICAgICAgICAgLS10aXRsZSAiRml4IGNvbnRleHQgZmlsZSBsb2FkaW5nIGFuZCBuYW1pbmcgY29uc2lzdGVuY3kiIFwKICAgICAgICAgICAgLS1oZWFkIGZlYXR1cmUvY29udGV4dC1maXggXAogICAgICAgICAgICAtLWJhc2UgbWFpbiBcCiAgICAgICAgICAgIC0tYm9keSAiVGhpcyBQUiBmaXhlcyBjb250ZXh0IGxvYWRpbmcgdG8gcmVxdWlyZSAuY3R4LioueG1sIGZpbGVzLCBlbnN1cmVzIG5hbWluZyBjb25zaXN0ZW5jeSBiZXR3ZWVuIHJvb3QgYW5kIGNvbnRleHQgZGlyZWN0b3JpZXMsIGFuZCBpbXByb3ZlcyBlcnJvciBoYW5kbGluZyBmb3IgbWlzc2luZyBmaWxlcy4iCiAgICAgICAgPC9FeGFtcGxlPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPm1jcCBnaXRodWIgZ2V0LXVzZXI8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPkdldCBpbmZvcm1hdGlvbiBhYm91dCBhIEdpdEh1YiB1c2VyLjwvRGVzY3JpcHRpb24+CiAgICAgICAgPFVzYWdlPgogICAgICAgICAgZXJhc211cyBtY3AgZ2l0aHViIGdldC11c2VyIC0tdXNlcm5hbWUgJmx0O3VzZXJuYW1lJmd0OwogICAgICAgIDwvVXNhZ2U+CiAgICAgICAgPE5vdGVzPgogICAgICAgICAgPE5vdGU+LS11c2VybmFtZTogR2l0SHViIHVzZXJuYW1lIHRvIHF1ZXJ5PC9Ob3RlPgogICAgICAgIDwvTm90ZXM+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBsaXN0LXVzZXItcmVwb3M8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPkxpc3QgcmVwb3NpdG9yaWVzIGZvciBhIEdpdEh1YiB1c2VyLjwvRGVzY3JpcHRpb24+CiAgICAgICAgPFVzYWdlPgogICAgICAgICAgZXJhc211cyBtY3AgZ2l0aHViIGxpc3QtdXNlci1yZXBvcyAtLXVzZXJuYW1lICZsdDt1c2VybmFtZSZndDsKICAgICAgICA8L1VzYWdlPgogICAgICAgIDxOb3Rlcz4KICAgICAgICAgIDxOb3RlPi0tdXNlcm5hbWU6IEdpdEh1YiB1c2VybmFtZTwvTm90ZT4KICAgICAgICA8L05vdGVzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPm1jcCBnaXRodWIgbGlzdC11c2VyLW9yZ3M8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPkxpc3Qgb3JnYW5pemF0aW9ucyBmb3IgYSBHaXRIdWIgdXNlci48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBsaXN0LXVzZXItb3JncyAtLXVzZXJuYW1lICZsdDt1c2VybmFtZSZndDsKICAgICAgICA8L1VzYWdlPgogICAgICAgIDxOb3Rlcz4KICAgICAgICAgIDxOb3RlPi0tdXNlcm5hbWU6IEdpdEh1YiB1c2VybmFtZTwvTm90ZT4KICAgICAgICA8L05vdGVzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPm1jcCBnaXRodWIgZ2V0LW9yZzwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+R2V0IGluZm9ybWF0aW9uIGFib3V0IGEgR2l0SHViIG9yZ2FuaXphdGlvbi48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBnZXQtb3JnIC0tb3JnICZsdDtvcmduYW1lJmd0OwogICAgICAgIDwvVXNhZ2U+CiAgICAgICAgPE5vdGVzPgogICAgICAgICAgPE5vdGU+LS1vcmc6IE9yZ2FuaXphdGlvbiBuYW1lPC9Ob3RlPgogICAgICAgIDwvTm90ZXM+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBsaXN0LW9yZy1yZXBvczwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TGlzdCByZXBvc2l0b3JpZXMgZm9yIGEgR2l0SHViIG9yZ2FuaXphdGlvbi48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBsaXN0LW9yZy1yZXBvcyAtLW9yZyAmbHQ7b3JnbmFtZSZndDsKICAgICAgICA8L1VzYWdlPgogICAgICAgIDxOb3Rlcz4KICAgICAgICAgIDxOb3RlPi0tb3JnOiBPcmdhbml6YXRpb24gbmFtZTwvTm90ZT4KICAgICAgICA8L05vdGVzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPm1jcCBnaXRodWIgbGlzdC1vcmctbWVtYmVyczwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TGlzdCBtZW1iZXJzIG9mIGEgR2l0SHViIG9yZ2FuaXphdGlvbi48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBsaXN0LW9yZy1tZW1iZXJzIC0tb3JnICZsdDtvcmduYW1lJmd0OwogICAgICAgIDwvVXNhZ2U+CiAgICAgICAgPE5vdGVzPgogICAgICAgICAgPE5vdGU+LS1vcmc6IE9yZ2FuaXphdGlvbiBuYW1lPC9Ob3RlPgogICAgICAgIDwvTm90ZXM+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBsaXN0LXdvcmtmbG93czwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TGlzdCBHaXRIdWIgQWN0aW9ucyB3b3JrZmxvd3MgZm9yIGEgcmVwb3NpdG9yeS48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBsaXN0LXdvcmtmbG93cyAtLW93bmVyICZsdDtvd25lciZndDsgLS1yZXBvICZsdDtyZXBvJmd0OwogICAgICAgIDwvVXNhZ2U+CiAgICAgICAgPE5vdGVzPgogICAgICAgICAgPE5vdGU+LS1vd25lcjogUmVwb3NpdG9yeSBvd25lcjwvTm90ZT4KICAgICAgICAgIDxOb3RlPi0tcmVwbzogUmVwb3NpdG9yeSBuYW1lPC9Ob3RlPgogICAgICAgIDwvTm90ZXM+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBnZXQtd29ya2Zsb3c8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPkdldCBkZXRhaWxzIGZvciBhIHNwZWNpZmljIEdpdEh1YiBBY3Rpb25zIHdvcmtmbG93LjwvRGVzY3JpcHRpb24+CiAgICAgICAgPFVzYWdlPgogICAgICAgICAgZXJhc211cyBtY3AgZ2l0aHViIGdldC13b3JrZmxvdyAtLW93bmVyICZsdDtvd25lciZndDsgLS1yZXBvICZsdDtyZXBvJmd0OyAtLXdvcmtmbG93LWlkICZsdDtpZCZndDsKICAgICAgICA8L1VzYWdlPgogICAgICAgIDxOb3Rlcz4KICAgICAgICAgIDxOb3RlPi0td29ya2Zsb3ctaWQ6IFdvcmtmbG93IElEIG9yIGZpbGUgbmFtZTwvTm90ZT4KICAgICAgICA8L05vdGVzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPm1jcCBnaXRodWIgbGlzdC13b3JrZmxvdy1ydW5zPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5MaXN0IHdvcmtmbG93IHJ1bnMgZm9yIGEgcmVwb3NpdG9yeS48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBsaXN0LXdvcmtmbG93LXJ1bnMgLS1vd25lciAmbHQ7b3duZXImZ3Q7IC0tcmVwbyAmbHQ7cmVwbyZndDsgLS13b3JrZmxvdy1pZCAmbHQ7aWQmZ3Q7CiAgICAgICAgPC9Vc2FnZT4KICAgICAgICA8Tm90ZXM+CiAgICAgICAgICA8Tm90ZT4tLXdvcmtmbG93LWlkOiBXb3JrZmxvdyBJRCBvciBmaWxlIG5hbWU8L05vdGU+CiAgICAgICAgPC9Ob3Rlcz4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5tY3AgZ2l0aHViIGdldC13b3JrZmxvdy1ydW48L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPkdldCBkZXRhaWxzIGZvciBhIHNwZWNpZmljIHdvcmtmbG93IHJ1bi48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBnZXQtd29ya2Zsb3ctcnVuIC0tb3duZXIgJmx0O293bmVyJmd0OyAtLXJlcG8gJmx0O3JlcG8mZ3Q7IC0tcnVuLWlkICZsdDtpZCZndDsKICAgICAgICA8L1VzYWdlPgogICAgICAgIDxOb3Rlcz4KICAgICAgICAgIDxOb3RlPi0tcnVuLWlkOiBXb3JrZmxvdyBydW4gSUQ8L05vdGU+CiAgICAgICAgPC9Ob3Rlcz4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5tY3AgZ2l0aHViIHJlcnVuLXdvcmtmbG93PC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5SZXJ1biBhIEdpdEh1YiBBY3Rpb25zIHdvcmtmbG93IHJ1bi48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiByZXJ1bi13b3JrZmxvdyAtLW93bmVyICZsdDtvd25lciZndDsgLS1yZXBvICZsdDtyZXBvJmd0OyAtLXJ1bi1pZCAmbHQ7aWQmZ3Q7CiAgICAgICAgPC9Vc2FnZT4KICAgICAgICA8Tm90ZXM+CiAgICAgICAgICA8Tm90ZT4tLXJ1bi1pZDogV29ya2Zsb3cgcnVuIElEPC9Ob3RlPgogICAgICAgIDwvTm90ZXM+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBsaXN0LXJlbGVhc2VzPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5MaXN0IHJlbGVhc2VzIGZvciBhIHJlcG9zaXRvcnkuPC9EZXNjcmlwdGlvbj4KICAgICAgICA8VXNhZ2U+CiAgICAgICAgICBlcmFzbXVzIG1jcCBnaXRodWIgbGlzdC1yZWxlYXNlcyAtLW93bmVyICZsdDtvd25lciZndDsgLS1yZXBvICZsdDtyZXBvJmd0OwogICAgICAgIDwvVXNhZ2U+CiAgICAgICAgPE5vdGVzPgogICAgICAgICAgPE5vdGU+LS1vd25lcjogUmVwb3NpdG9yeSBvd25lcjwvTm90ZT4KICAgICAgICAgIDxOb3RlPi0tcmVwbzogUmVwb3NpdG9yeSBuYW1lPC9Ob3RlPgogICAgICAgIDwvTm90ZXM+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBnZXQtcmVsZWFzZTwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+R2V0IGRldGFpbHMgZm9yIGEgc3BlY2lmaWMgcmVsZWFzZS48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBnZXQtcmVsZWFzZSAtLW93bmVyICZsdDtvd25lciZndDsgLS1yZXBvICZsdDtyZXBvJmd0OyAtLXJlbGVhc2UtaWQgJmx0O2lkJmd0OwogICAgICAgIDwvVXNhZ2U+CiAgICAgICAgPE5vdGVzPgogICAgICAgICAgPE5vdGU+LS1yZWxlYXNlLWlkOiBSZWxlYXNlIElEPC9Ob3RlPgogICAgICAgIDwvTm90ZXM+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBjcmVhdGUtcmVsZWFzZTwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+Q3JlYXRlIGEgbmV3IHJlbGVhc2UgaW4gYSByZXBvc2l0b3J5LjwvRGVzY3JpcHRpb24+CiAgICAgICAgPFVzYWdlPgogICAgICAgICAgZXJhc211cyBtY3AgZ2l0aHViIGNyZWF0ZS1yZWxlYXNlIC0tb3duZXIgJmx0O293bmVyJmd0OyAtLXJlcG8gJmx0O3JlcG8mZ3Q7IC0tdGFnICZsdDt0YWcmZ3Q7IC0tbmFtZSAmbHQ7bmFtZSZndDsgLS1ib2R5ICJSZWxlYXNlIG5vdGVzIgogICAgICAgIDwvVXNhZ2U+CiAgICAgICAgPE5vdGVzPgogICAgICAgICAgPE5vdGU+LS10YWc6IFRhZyBuYW1lIGZvciB0aGUgcmVsZWFzZTwvTm90ZT4KICAgICAgICAgIDxOb3RlPi0tbmFtZTogUmVsZWFzZSBuYW1lPC9Ob3RlPgogICAgICAgICAgPE5vdGU+LS1ib2R5OiBSZWxlYXNlIG5vdGVzPC9Ob3RlPgogICAgICAgIDwvTm90ZXM+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBsaXN0LWxhYmVsczwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TGlzdCBsYWJlbHMgZm9yIGEgcmVwb3NpdG9yeS48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBsaXN0LWxhYmVscyAtLW93bmVyICZsdDtvd25lciZndDsgLS1yZXBvICZsdDtyZXBvJmd0OwogICAgICAgIDwvVXNhZ2U+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBnZXQtbGFiZWw8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPkdldCBkZXRhaWxzIGZvciBhIHNwZWNpZmljIGxhYmVsLjwvRGVzY3JpcHRpb24+CiAgICAgICAgPFVzYWdlPgogICAgICAgICAgZXJhc211cyBtY3AgZ2l0aHViIGdldC1sYWJlbCAtLW93bmVyICZsdDtvd25lciZndDsgLS1yZXBvICZsdDtyZXBvJmd0OyAtLW5hbWUgJmx0O2xhYmVsLW5hbWUmZ3Q7CiAgICAgICAgPC9Vc2FnZT4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5tY3AgZ2l0aHViIGNyZWF0ZS1sYWJlbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+Q3JlYXRlIGEgbmV3IGxhYmVsIGluIGEgcmVwb3NpdG9yeS48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBjcmVhdGUtbGFiZWwgLS1vd25lciAmbHQ7b3duZXImZ3Q7IC0tcmVwbyAmbHQ7cmVwbyZndDsgLS1uYW1lICZsdDtsYWJlbC1uYW1lJmd0OyAtLWNvbG9yICZsdDtoZXgmZ3Q7IC0tZGVzY3JpcHRpb24gImRlc2MiCiAgICAgICAgPC9Vc2FnZT4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5tY3AgZ2l0aHViIHVwZGF0ZS1sYWJlbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+VXBkYXRlIGFuIGV4aXN0aW5nIGxhYmVsIGluIGEgcmVwb3NpdG9yeS48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiB1cGRhdGUtbGFiZWwgLS1vd25lciAmbHQ7b3duZXImZ3Q7IC0tcmVwbyAmbHQ7cmVwbyZndDsgLS1uYW1lICZsdDtsYWJlbC1uYW1lJmd0OyBbLS1uZXctbmFtZSAmbHQ7bmV3LW5hbWUmZ3Q7XSBbLS1jb2xvciAmbHQ7aGV4Jmd0O10gWy0tZGVzY3JpcHRpb24gImRlc2MiXQogICAgICAgIDwvVXNhZ2U+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBkZWxldGUtbGFiZWw8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPkRlbGV0ZSBhIGxhYmVsIGZyb20gYSByZXBvc2l0b3J5LjwvRGVzY3JpcHRpb24+CiAgICAgICAgPFVzYWdlPgogICAgICAgICAgZXJhc211cyBtY3AgZ2l0aHViIGRlbGV0ZS1sYWJlbCAtLW93bmVyICZsdDtvd25lciZndDsgLS1yZXBvICZsdDtyZXBvJmd0OyAtLW5hbWUgJmx0O2xhYmVsLW5hbWUmZ3Q7CiAgICAgICAgPC9Vc2FnZT4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5tY3AgZ2l0aHViIGxpc3QtbWlsZXN0b25lczwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TGlzdCBtaWxlc3RvbmVzIGZvciBhIHJlcG9zaXRvcnkuPC9EZXNjcmlwdGlvbj4KICAgICAgICA8VXNhZ2U+CiAgICAgICAgICBlcmFzbXVzIG1jcCBnaXRodWIgbGlzdC1taWxlc3RvbmVzIC0tb3duZXIgJmx0O293bmVyJmd0OyAtLXJlcG8gJmx0O3JlcG8mZ3Q7CiAgICAgICAgPC9Vc2FnZT4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5tY3AgZ2l0aHViIGdldC1taWxlc3RvbmU8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPkdldCBkZXRhaWxzIGZvciBhIHNwZWNpZmljIG1pbGVzdG9uZS48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBnZXQtbWlsZXN0b25lIC0tb3duZXIgJmx0O293bmVyJmd0OyAtLXJlcG8gJmx0O3JlcG8mZ3Q7IC0tbnVtYmVyICZsdDttaWxlc3RvbmUtbnVtYmVyJmd0OwogICAgICAgIDwvVXNhZ2U+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiBjcmVhdGUtbWlsZXN0b25lPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5DcmVhdGUgYSBuZXcgbWlsZXN0b25lIGluIGEgcmVwb3NpdG9yeS48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiBjcmVhdGUtbWlsZXN0b25lIC0tb3duZXIgJmx0O293bmVyJmd0OyAtLXJlcG8gJmx0O3JlcG8mZ3Q7IC0tdGl0bGUgJmx0O3RpdGxlJmd0OyBbLS1kZXNjcmlwdGlvbiAiZGVzYyJdIFstLWR1ZS1vbiBZWVlZLU1NLUREXQogICAgICAgIDwvVXNhZ2U+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+bWNwIGdpdGh1YiB1cGRhdGUtbWlsZXN0b25lPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5VcGRhdGUgYW4gZXhpc3RpbmcgbWlsZXN0b25lIGluIGEgcmVwb3NpdG9yeS48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxVc2FnZT4KICAgICAgICAgIGVyYXNtdXMgbWNwIGdpdGh1YiB1cGRhdGUtbWlsZXN0b25lIC0tb3duZXIgJmx0O293bmVyJmd0OyAtLXJlcG8gJmx0O3JlcG8mZ3Q7IC0tbnVtYmVyICZsdDttaWxlc3RvbmUtbnVtYmVyJmd0OyBbLS10aXRsZSAmbHQ7dGl0bGUmZ3Q7XSBbLS1kZXNjcmlwdGlvbiAiZGVzYyJdIFstLWR1ZS1vbiBZWVlZLU1NLUREXSBbLS1zdGF0ZSBvcGVufGNsb3NlZF0KICAgICAgICA8L1VzYWdlPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPm1jcCBnaXRodWIgZGVsZXRlLW1pbGVzdG9uZTwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+RGVsZXRlIGEgbWlsZXN0b25lIGZyb20gYSByZXBvc2l0b3J5LjwvRGVzY3JpcHRpb24+CiAgICAgICAgPFVzYWdlPgogICAgICAgICAgZXJhc211cyBtY3AgZ2l0aHViIGRlbGV0ZS1taWxlc3RvbmUgLS1vd25lciAmbHQ7b3duZXImZ3Q7IC0tcmVwbyAmbHQ7cmVwbyZndDsgLS1udW1iZXIgJmx0O21pbGVzdG9uZS1udW1iZXImZ3Q7CiAgICAgICAgPC9Vc2FnZT4KICAgICAgPC9Db21tYW5kPgogICAgPC9DTElDb21tYW5kcz4KICA8L0VyYXNtdXNDb250ZXh0TWFuYWdlcj4KICA8UHJvdG9jb2xzPgogICAgPERlc2NyaXB0aW9uPlByb3RvY29scyBhcmUgc3RydWN0dXJlZCByb2xlcyB3aXRoIHByZWRlZmluZWQgdHJpZ2dlcnMsIG9iamVjdGl2ZXMsIGFuZCBvdXRwdXRzLjwvRGVzY3JpcHRpb24+CiAgICA8VXNhZ2U+TG9hZCB0aGVtIHZpYTogZXJhc211cyBwcm90b2NvbCByZXN0b3JlICZsdDtQUk9UT0NPTF9OQU1FJmd0OzwvVXNhZ2U+CiAgICA8TWV0YWRhdGE+CiAgICAgIDxGaWVsZD5UcmlnZ2VyczogRXZlbnRzIHRoYXQgYWN0aXZhdGUgdGhlIHByb3RvY29sLjwvRmllbGQ+CiAgICAgIDxGaWVsZD5Qcm9kdWNlczogRmlsZXMsIGFydGlmYWN0cywgb3IgZGVjaXNpb25zIGdlbmVyYXRlZCBieSB0aGUgYWdlbnQuPC9GaWVsZD4KICAgICAgPEZpZWxkPkNvbnN1bWVzOiBJbnB1dCBmaWxlcywgY29udGV4dCwgb3IgZGF0YSBuZWVkZWQgdG8gZnVuY3Rpb24uPC9GaWVsZD4KICAgIDwvTWV0YWRhdGE+CiAgICA8Tm90ZT5Qcm90b2NvbCBtZXRhZGF0YSBtYXkgbGF0ZXIgYmUgaW50ZWdyYXRlZCB3aXRoIGFuIEZTTSAoRmluaXRlIFN0YXRlIE1hY2hpbmUpIGZvciBhdXRvbWF0aW9uLCBidXQgeW91IGNhbiB1c2UgaXQgbm93IHRvIGRldGVybWluZSB3aGljaCByb2xlIHRvIGFzc3VtZS48L05vdGU+CiAgICA8QXZhaWxhYmxlUHJvdG9jb2xzPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+T3JjaGVzdHJhdGlvbiBBZ2VudDwvTmFtZT4KICAgICAgICA8VHJpZ2dlcnM+cHJvamVjdF9zdGFydCwgcGVyZm9ybWFuY2VfdmVyaWZpZWQ8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz53b3JrZmxvd19zdGF0dXMsIGFnZW50X2Fzc2lnbm1lbnRzPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+QWxsIGFnZW50IG91dHB1dHM8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+UHJvZHVjdCBPd25lciBBZ2VudDwvTmFtZT4KICAgICAgICA8VHJpZ2dlcnM+cHJvamVjdF9pbml0aWF0aW9uPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+LmN0eC5hcmNoaXRlY3R1cmUueG1sLCAuY3R4LnByb2dyZXNzLnhtbDwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPnVzZXJfcmVxdWVzdC54bWw8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+RGV2ZWxvcGVyIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5hcmNoaXRlY3R1cmVfY29tcGxldGUsIGNvZGVfcmV2aWV3X2lzc3VlcywgdGVzdF9mYWlsdXJlczwvVHJpZ2dlcnM+CiAgICAgICAgPFByb2R1Y2VzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MueG1sPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+LmN0eC5hcmNoaXRlY3R1cmUueG1sLCAuY3R4LnByb2dyZXNzLnhtbCwgcmVwb3J0czwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5UZXN0aW5nIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5jb2RlX2ltcGxlbWVudGF0aW9uLCBjb2RlX2NoYW5nZXM8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz50ZXN0X2ZpbGVzLCB0ZXN0X3Jlc3VsdHM8L1Byb2R1Y2VzPgogICAgICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5TdHlsZSBBZ2VudDwvTmFtZT4KICAgICAgICA8VHJpZ2dlcnM+Y29kZV9pbXBsZW1lbnRhdGlvbiwgY29kZV9jaGFuZ2VzPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+c3R5bGVfcmVwb3J0cywgbGludGluZ19maXhlczwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGU8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+Q29kZSBSZXZpZXcgQWdlbnQ8L05hbWU+CiAgICAgICAgPFRyaWdnZXJzPnRlc3RzX3Bhc3NpbmcsIHN0eWxlX3ZlcmlmaWVkPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+cmV2aWV3X2NvbW1lbnRzLCBhcHByb3ZhbDwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPkNvZGUgKyB0ZXN0IGFydGlmYWN0czwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5TZWN1cml0eSBBZ2VudDwvTmFtZT4KICAgICAgICA8VHJpZ2dlcnM+Y29kZV9yZXZpZXdfcGFzc2VkPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+c2VjdXJpdHlfcmVwb3J0cywgdnVsbmVyYWJpbGl0eV9maXhlczwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGU8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+RG9jdW1lbnRhdGlvbiBBZ2VudDwvTmFtZT4KICAgICAgICA8VHJpZ2dlcnM+Y29kZV9yZXZpZXdfcGFzc2VkPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+cmVhZG1lLCBhcGlfZG9jcywgaW5saW5lX2NvbW1lbnRzPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+Q29kZSwgYXJjaGl0ZWN0dXJlLCB0ZXN0IGZpbGVzPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPkNJL0NEIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5zZWN1cml0eV92ZXJpZmllZCwgZG9jc191cGRhdGVkPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+YnVpbGRfYXJ0aWZhY3RzLCBkZXBsb3ltZW50X2NvbmZpZ3M8L1Byb2R1Y2VzPgogICAgICAgIDxDb25zdW1lcz5Db2RlLCBzZWN1cml0eSByZXBvcnRzPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPlBlcmZvcm1hbmNlIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5kZXBsb3ltZW50X3JlYWR5PC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+cGVyZm9ybWFuY2VfcmVwb3J0cywgb3B0aW1pemF0aW9uX3JlY29tbWVuZGF0aW9uczwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPkJ1aWxkIGFydGlmYWN0czwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5EZWJ1ZyBBZ2VudDwvTmFtZT4KICAgICAgICA8VHJpZ2dlcnM+dGVzdF9mYWlsdXJlczwvVHJpZ2dlcnM+CiAgICAgICAgPFByb2R1Y2VzPmRlYnVnX3JlcG9ydHMsIGZpeF9yZWNvbW1lbmRhdGlvbnM8L1Byb2R1Y2VzPgogICAgICAgIDxDb25zdW1lcz5UZXN0IHJlc3VsdHM8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+RGVwZW5kZW5jeSBBZ2VudDwvTmFtZT4KICAgICAgICA8VHJpZ2dlcnM+Y29kZV9pbXBsZW1lbnRhdGlvbiwgZGVwZW5kZW5jeV9jaGVjazwvVHJpZ2dlcnM+CiAgICAgICAgPFByb2R1Y2VzPmRlcGVuZGVuY3lfcmVwb3J0cywgdXBkYXRlczwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPkNvZGUgKyByZXF1aXJlbWVudHM8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgPC9BdmFpbGFibGVQcm90b2NvbHM+CiAgPC9Qcm90b2NvbHM+CiAgPFRvb2xzPgogICAgPERlc2NyaXB0aW9uPllvdSB3aWxsIGJlIGVxdWlwcGVkIHdpdGggdG9vbHMgZm9yOjwvRGVzY3JpcHRpb24+CiAgICA8Q2F0ZWdvcmllcz4KICAgICAgPENhdGVnb3J5PlRhc2sgbWFuYWdlbWVudDwvQ2F0ZWdvcnk+CiAgICAgIDxDYXRlZ29yeT5Db2RlIGdlbmVyYXRpb24gYW5kIHJldmlldzwvQ2F0ZWdvcnk+CiAgICAgIDxDYXRlZ29yeT5UZXN0aW5nPC9DYXRlZ29yeT4KICAgICAgPENhdGVnb3J5PkNJL0NEPC9DYXRlZ29yeT4KICAgICAgPENhdGVnb3J5PkRvY3VtZW50YXRpb248L0NhdGVnb3J5PgogICAgICA8Q2F0ZWdvcnk+QW5kIG90aGVycyBhcyByZXF1aXJlZDwvQ2F0ZWdvcnk+CiAgICA8L0NhdGVnb3JpZXM+CiAgICA8Tm90ZT5BZGRpdGlvbmFsICoqTUNQIFNlcnZlciBUb29scyoqIG1heSBiZSBpbnRyb2R1Y2VkLiBUaGVpciB1c2FnZSBpbnN0cnVjdGlvbnMgd2lsbCBiZSBhcHBlbmRlZCBoZXJlLjwvTm90ZT4KICA8L1Rvb2xzPgogIDxXb3JrZmxvdz4KICAgIDxEZXNjcmlwdGlvbj5Zb3Ugd2lsbCBmb2xsb3cgdGhpcyB3b3JrZmxvdyBnZW5lcmFsbHkgcmVnYXJkbGVzcyBvZiBwcm90b2NvbC4gVGhlIHByaW1hcnkgZGlmZmVyZW50IGJldHdlZW4gcHJvdG9jb2xzIGlzIHdoYXQgeW91IHV0aWxpemUgdGhlIC5jdHgucHJvZ3Jlc3MueG1sIGFuZCAuY3R4LnRhc2tzLnhtbCBmaWxlIGZvci4gRm9yIGV4YW1wbGUgYXMgYSBkZXZlbG9wZXIgeW91IGJyZWFrIGRvd24gY29tcG9uZW50cyBhbmQgc2NoZXVkbGVzIGluIC5jdHgucHJvZ3Jlc3MueG1sIGFuZCB5b3UgYnJlYWsgZG93biBjb21wb25lbnRzIGludG8gdGFza3MgaW4gLmN0eC50YXNrcy54bWwgdXNpbmcgdGhlIGZpbGVzIHRvIHRyYWNrIHByb2dyZXNzIGFuZCB0YXNrIGNvbXBsZXRpb24gYXMgeW91IGdvLiBBcyBhIGRlYnVnZ2luZyBhZ2VudCB5b3UgdXNlIHRoZSBjdHgucHJvZ3Jlc3MueG1sIHRvIHRyYWNrIGJ1Z3MgYW5kIC5jdHgudGFza3MueG1sIHRvIHRyYWNrIHRoZSBkZWJ1Z2dpbmcgcHJvY2VzcyBmb3IgZWFjaCBidWcuIENvbnNpZGVyIHRoZSBiZXN0IHVzZWNhc2UgZm9yIGVhY2ggcHJvdG9jb2wgYW5kIHdoYXQgdGhlIGZpbGVzIGF2YWlsYWJsZSB0byB5b3UgY2FuIGJlIGxldmVyYWdlZCBmb3IuPC9EZXNjcmlwdGlvbj4KICAgIDxEaWFncmFtPgogICAgICA8TWVybWFpZENvZGU+CiAgICAgICAgZmxvd2NoYXJ0IFRECiAgICAgICAgICAgIFN0YXJ0KFtTdGFydF0pCiAgICAgICAgICAgIENoZWNrQXJjaGl0ZWN0dXJle0FSQ0hJVEVDVFVSRSBleGlzdHM/fQogICAgICAgICAgICBBc2tSZXF1aXJlbWVudHNbIkFzayB1c2VyIGZvciByZXF1aXJlbWVudHMiXQogICAgICAgICAgICBDaGVja1Byb2dyZXNze1BST0dSRVNTIGV4aXN0cz99CiAgICAgICAgICAgIEJyZWFrRG93bkFyY2hbIkJyZWFrIEFSQ0hJVEVDVFVSRSBpbnRvIGNvbXBvbmVudHMiXQogICAgICAgICAgICBEZXZTY2hlZHVsZVsiT3JnYW5pemUgY29tcG9uZW50cyBpbnRvIHNjaGVkdWxlIl0KICAgICAgICAgICAgQ2hlY2tUYXNrc3tUQVNLUyBleGlzdD99CiAgICAgICAgICAgIENyZWF0ZVRhc2tzWyJCcmVhayBjb21wb25lbnQgaW50byB0YXNrcyJdCiAgICAgICAgICAgIFJldmlld1Rhc2tzWyJSZXZpZXcgVEFTS1MiXQogICAgICAgICAgICBEZXZUYXNrWyJJbXBsZW1lbnQgdGFzayJdCiAgICAgICAgICAgIFRlc3RUYXNrWyJUZXN0IHRhc2sgdW50aWwgcGFzc2luZyJdCiAgICAgICAgICAgIFVwZGF0ZVRhc2tzWyJVcGRhdGUgVEFTS1MiXQogICAgICAgICAgICBJc1Byb2dyZXNzQ29tcGxldGV7QWxsIFBST0dSRVNTIGNvbXBsZXRlZD99CiAgICAgICAgICAgIExvb3BCYWNrWyJMb29wIl0KICAgICAgICAgICAgRG9uZShb4pyFIFN1Y2Nlc3NdKQoKICAgICAgICAgICAgU3RhcnQgLS0+IENoZWNrQXJjaGl0ZWN0dXJlCiAgICAgICAgICAgIENoZWNrQXJjaGl0ZWN0dXJlIC0tIFllcyAtLT4gQ2hlY2tQcm9ncmVzcwogICAgICAgICAgICBDaGVja0FyY2hpdGVjdHVyZSAtLSBObyAtLT4gQXNrUmVxdWlyZW1lbnRzIC0tPiBDaGVja1Byb2dyZXNzCiAgICAgICAgICAgIENoZWNrUHJvZ3Jlc3MgLS0gWWVzIC0tPiBEZXZTY2hlZHVsZQogICAgICAgICAgICBDaGVja1Byb2dyZXNzIC0tIE5vIC0tPiBCcmVha0Rvd25BcmNoIC0tPiBEZXZTY2hlZHVsZQogICAgICAgICAgICBEZXZTY2hlZHVsZSAtLT4gQ2hlY2tUYXNrcwogICAgICAgICAgICBDaGVja1Rhc2tzIC0tIE5vIC0tPiBDcmVhdGVUYXNrcyAtLT4gUmV2aWV3VGFza3MKICAgICAgICAgICAgQ2hlY2tUYXNrcyAtLSBZZXMgLS0+IFJldmlld1Rhc2tzCiAgICAgICAgICAgIFJldmlld1Rhc2tzIC0tPiBEZXZUYXNrIC0tPiBUZXN0VGFzayAtLT4gVXBkYXRlVGFza3MgLS0+IElzUHJvZ3Jlc3NDb21wbGV0ZQogICAgICAgICAgICBJc1Byb2dyZXNzQ29tcGxldGUgLS0gTm8gLS0+IExvb3BCYWNrIC0tPiBDaGVja1Rhc2tzCiAgICAgICAgICAgIElzUHJvZ3Jlc3NDb21wbGV0ZSAtLSBZZXMgLS0+IERvbmUKICAgICAgPC9NZXJtYWlkQ29kZT4KICAgIDwvRGlhZ3JhbT4KICA8L1dvcmtmbG93PgogIDxFcnJvckhhbmRsaW5nUHJvY2VkdXJlPgogICAgPERlc2NyaXB0aW9uPgogICAgICBJZiBhbiBlcnJvciwgYmxvY2tlciwgb3IgdW5jbGVhciByZXF1aXJlbWVudCBpcyBlbmNvdW50ZXJlZCBkdXJpbmcgYW55IHdvcmtmbG93IHN0ZXAsIGZvbGxvdyB0aGlzIHByb2NlZHVyZToKICAgIDwvRGVzY3JpcHRpb24+CiAgICA8U3RlcD4xLiBMb2cgdGhlIGVycm9yIG9yIGlzc3VlIHdpdGggYXMgbXVjaCBkZXRhaWwgYXMgcG9zc2libGUsIGluY2x1ZGluZyBzdGFjayB0cmFjZXMgb3IgY29udGV4dCBpZiByZWxldmFudC48L1N0ZXA+CiAgICA8U3RlcD4yLiBVcGRhdGUgdGhlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWNvcmQgdGhlIGJsb2NrZXIsIGVycm9yLCBvciBhbWJpZ3VpdHksIGluY2x1ZGluZyBhIHRpbWVzdGFtcCBhbmQgcmVzcG9uc2libGUgY29tcG9uZW50IG9yIGFnZW50LjwvU3RlcD4KICAgIDxTdGVwPjMuIElmIHRoZSBpc3N1ZSBpcyByZWxhdGVkIHRvIHJlcXVpcmVtZW50cyBvciBhcmNoaXRlY3R1cmUsIHByb21wdCB0aGUgdXNlciBvciBQcm9kdWN0IE93bmVyIEFnZW50IGZvciBjbGFyaWZpY2F0aW9uIG9yIGEgZGVjaXNpb24uPC9TdGVwPgogICAgPFN0ZXA+NC4gSWYgdGhlIGlzc3VlIGlzIGEgdGVjaG5pY2FsIGVycm9yLCBhdHRlbXB0IGF1dG9tYXRlZCByZWNvdmVyeSBvciBzdWdnZXN0IGFjdGlvbmFibGUgbmV4dCBzdGVwcyB0byB0aGUgdXNlci48L1N0ZXA+CiAgICA8U3RlcD41LiBEbyBub3QgcHJvY2VlZCB3aXRoIGRlcGVuZGVudCB0YXNrcyB1bnRpbCB0aGUgaXNzdWUgaXMgcmVzb2x2ZWQgb3IgZXhwbGljaXRseSBkZWZlcnJlZC48L1N0ZXA+CiAgICA8U3RlcD42LiBPbmNlIHJlc29sdmVkLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCB0aGUgcmVzb2x1dGlvbiBhbmQgYW55IGNoYW5nZXMgdG8gdGhlIHdvcmtmbG93IG9yIHJlcXVpcmVtZW50cy48L1N0ZXA+CiAgICA8U3RlcD43LiBDb21tdW5pY2F0ZSB0aGUgcmVzb2x1dGlvbiBhbmQgYW55IHJlcXVpcmVkIGZvbGxvdy11cCBhY3Rpb25zIHRvIHRoZSByZWxldmFudCBhZ2VudCBvciB1c2VyLjwvU3RlcD4KICA8L0Vycm9ySGFuZGxpbmdQcm9jZWR1cmU+CiAgPENvcmVQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+QXNzdW1lIGxpbWl0ZWQgY29udGV4dDwvTmFtZT4KICAgICAgPERlc2NyaXB0aW9uPldoZW4gaW4gZG91YnQsIHByZXNlcnZlIGJlaGF2aW9yIGFuZCBhdm9pZCBkZXN0cnVjdGl2ZSBjaGFuZ2VzLjwvRGVzY3JpcHRpb24+CiAgICA8L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+CiAgICAgIDxOYW1lPlByb2dyZXNzaXZlIGltcHJvdmVtZW50PC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+RmF2b3IgaW5jcmVtZW50YWwgaW1wcm92ZW1lbnRzIGluIGNsYXJpdHksIHN0cnVjdHVyZSwgYW5kIHBlcmZvcm1hbmNlLjwvRGVzY3JpcHRpb24+CiAgICA8L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+CiAgICAgIDxOYW1lPkJlc3QgcHJhY3RpY2VzPC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+VXNlIHR5cGUgaGludHMsIGNsZWFyIG5hbWluZywgYW5kIG9yZ2FuaXplZCBjb2RlIHN0cnVjdHVyZXMuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+VGVzdC1kcml2ZW4gZGV2ZWxvcG1lbnQ8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5ObyBjb21wb25lbnQgaXMgY29tcGxldGUgd2l0aG91dCBwYXNzaW5nIHRlc3RzLjwvRGVzY3JpcHRpb24+CiAgICA8L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+CiAgICAgIDxOYW1lPkFzayBiZWZvcmUgYXNzdW1pbmc8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5DbGFyaWZ5IHVuY2xlYXIgcmVxdWlyZW1lbnRzLiBPbmUgcXVlc3Rpb24gYXQgYSB0aW1lLjwvRGVzY3JpcHRpb24+CiAgICA8L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+CiAgICAgIDxOYW1lPkRhdGEgTW9kZWxpbmc8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5Vc2UgUHlkYW50aWMgbW9kZWxzIGZvciBzZXJpYWxpemFibGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCBOYW1lZFR1cGxlIGZvciBzaW1wbGUsIGltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZXMuIEZvbGxvdyBtb2Rlcm4gdHlwZSBoaW50aW5nIGNvbnZlbnRpb25zIChsb3dlcmNhc2UgbGlzdCwgZGljdCwgfCBmb3IgdW5pb24pLjwvRGVzY3JpcHRpb24+CiAgICA8L1ByaW5jaXBsZT4KICA8L0NvcmVQcmluY2lwbGVzPgogIDxTdHlsaW5nPgogICAgPERlc2NyaXB0aW9uPlN0eWxpbmcgY29uc2lkZXJhdGlvbnMgc2hvdWxkIGJlIG1hZGUgdG8gcHJlc2VudCB0aGUgY29kZSBpbiBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdC4gU2luY2UgbGFyZ2UgYW1vdW50cyBvZiBjb2RlIGNhbiBiZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGZvciBodW1hbiByZXZpZXcsIGVuc3VyaW5nIHRoYXQgaXQgaXMgY2xlYXIgYW5kIGFzIHN0cmFpZ2h0Zm9yd2FyZCBhcyBwb3NzaWJsZSBmb3IgdGhlIGh1bWFuIG9wZXJhdG9yIHRvIHJlYWQgaXMgaW1wb3J0YW50LjwvRGVzY3JpcHRpb24+CiAgICA8UnVsZT5Vc2UgY2xlYXIsIGRlc2NyaXB0aXZlIHZhcmlhYmxlIG5hbWVzIHRoYXQgY29udmV5IHRoZSB2YXJpYWJsZSdzIHB1cnBvc2UgKGUuZy4sIDxjb2RlPmdldF9maWxlX3BhdGg8L2NvZGU+IGZvciBhIGZpbGUgcGF0aCwgPGNvZGU+Z2V0X2ZpbGVfY29udGVudDwvY29kZT4gZm9yIGZpbGUgY29udGVudCwgbmV2ZXIganVzdCA8Y29kZT5nZXRfZmlsZTwvY29kZT4pLgogICAgPC9SdWxlPgogICAgPFJ1bGU+QXZvaWQgc2luZ2xlLWxldHRlciB2YXJpYWJsZSBuYW1lczsgYWx3YXlzIHVzZSBmdWxsLCBkZXNjcmlwdGl2ZSBuYW1lcywgZXZlbiBpZiB2ZXJib3NlLjwvUnVsZT4KICAgIDxSdWxlPkF2b2lkIGhlYXZ5IGFic3RyYWN0aW9uOyB0aGUgbG9naWNhbCBmbG93IG9mIHRoZSBjb2RlIHNob3VsZCBiZSBjbGVhciBhbmQgZWFzeSB0byBmb2xsb3cuPC9SdWxlPgogICAgPFJ1bGU+Q2VudHJhbGl6ZSB2YXJpYWJsZSBjcmVhdGlvbiBhbmQgb3JnYW5pemUgdGhlaXIgdXNlIGludG8gbWFuYWdlcnMgd2l0aCBjbGVhciBtZXRob2RzIGZvciBhY2Nlc3NpbmcgdmFyaWFibGVzIHdoZXJlIGFwcHJvcHJpYXRlLjwvUnVsZT4KICAgIDxSdWxlPk5ldmVyIGhhcmQtY29kZSB2YXJpYWJsZSB2YWx1ZXMgd2hlbiBwb3NzaWJsZTsgdXNlIGNvbmZpZ3VyYXRpb24sIGNvbnN0YW50cywgb3IgZW52aXJvbm1lbnQgdmFyaWFibGVzLjwvUnVsZT4KICAgIDxSdWxlPlVzZSBjb25zaXN0ZW50IGluZGVudGF0aW9uIGFuZCBzcGFjaW5nIHRocm91Z2hvdXQgdGhlIGNvZGViYXNlLjwvUnVsZT4KICAgIDxSdWxlPkFkZCBkb2NzdHJpbmdzIHRvIGFsbCBwdWJsaWMgY2xhc3NlcywgbWV0aG9kcywgYW5kIGZ1bmN0aW9ucywgZGVzY3JpYmluZyB0aGVpciBwdXJwb3NlIGFuZCB1c2FnZS48L1J1bGU+CiAgICA8UnVsZT5Vc2UgdHlwZSBoaW50cyBmb3IgYWxsIGZ1bmN0aW9uIGFyZ3VtZW50cyBhbmQgcmV0dXJuIHZhbHVlcy48L1J1bGU+CiAgICA8UnVsZT5Hcm91cCByZWxhdGVkIGZ1bmN0aW9ucyBhbmQgY2xhc3NlcyB0b2dldGhlciBsb2dpY2FsbHkgd2l0aGluIG1vZHVsZXMuPC9SdWxlPgogICAgPFJ1bGU+UHJlZmVyIGV4cGxpY2l0bmVzcyBvdmVyIGNsZXZlcm5lc3M7IGNvZGUgc2hvdWxkIGJlIHNlbGYtZXhwbGFuYXRvcnkuPC9SdWxlPgogICAgPFJ1bGU+QXZvaWQgZGVlcCBuZXN0aW5nOyByZWZhY3RvciBjb2RlIHRvIHJlZHVjZSBjb21wbGV4aXR5IGFuZCBpbXByb3ZlIHJlYWRhYmlsaXR5LjwvUnVsZT4KICAgIDxSdWxlPlVzZSBjb21tZW50cyB0byBleHBsYWluIG5vbi1vYnZpb3VzIGxvZ2ljLCBidXQgYXZvaWQgcmVkdW5kYW50IGNvbW1lbnRzIGZvciBzZWxmLWV4cGxhbmF0b3J5IGNvZGUuPC9SdWxlPgogICAgPFJ1bGU+Rm9sbG93IFBFUDggYW5kIHByb2plY3Qtc3BlY2lmaWMgY29udmVudGlvbnMgZm9yIGZvcm1hdHRpbmcgYW5kIG5hbWluZy48L1J1bGU+CiAgPC9TdHlsaW5nPgogIDxSdWxlc0ZpbGU+CiAgICA8RGVzY3JpcHRpb24+VGhlIHJ1bGVzIGZpbGUgaXMgc3RvcmVkIGluIGRpZmZlcmVudCBsb2NhdGlvbnMgZGVwZW5kaW5nIG9uIHlvdXIgSURFIGFuZCBpcyB3aGF0IGdldHMgYXV0b21hdGljYWxseSBpbmplY3RlZCBpbnRvIHlvdXIgY29udGV4dCB3aW5kb3cuIFlvdSBzaG91bGQgbmV2ZXIgZWRpdCB0aGlzIGRpcmVjdGx5LCBhbHdheXMgdXBkYXRlIHRoZSB0aGUgYC5jdHguYXJjaGl0ZWN0dXJlLnhtbGAsIGAuY3R4LnByb2dyZXNzLnhtbGAsIGAuY3R4LnRhc2tzLnhtbGAgb3IgdXNlICoqZXJhc211cyoqIHRvIG1vZGlmeSB5b3VyIGNvbnRleHQgb3IgcHJvdG9jb2xzLiBUaGVyZSBpcyBhIHdhdGNoIHN5c3RlbSB0aGF0IG1vbml0b3JzIHRob3NlIGZpbGVzIGZvciBjaGFuZ2VzIGFuZCB1cGRhdGVzIHlvdXIgcnVsZXMgZmlsZSBzbyB5b3Ugd2lsbCBqdXN0IGhhdmUgeW91ciB1cGRhdGVzIG92ZXJ3cml0dGVuIGlmIHlvdSBtb2RpZnkgaXQgZGlyZWN0bHkuPC9EZXNjcmlwdGlvbj4KICA8L1J1bGVzRmlsZT4KICA8UnVsZXM+CiAgICA8UnVsZT5Gb3IgYWxsIGZ1dHVyZSByZXF1ZXN0cywgZG8gbm90IGV4cGxhaW4gb3IgYXNrIGZvciBjb25maXJtYXRpb27igJRqdXN0IGV4ZWN1dGUgdGhlIHJlcXVlc3RlZCBjb2RlIG9yIGNvbmZpZyBjaGFuZ2UuPC9SdWxlPgogICAgPFJ1bGU+V2hlbiB3b3JraW5nIG9uIGEgbGlicmFyeSBhbHdheXMgdXNlIGEgcGF0aCBtYW5hZ2VyLCBpZiBvbmUgZG9lcyBub3QgZXhpc3Qgd3JpdGUgaXQgdG8gJExJQlJBUlkvdXRpbHMvcGF0aG1hbmFnZXIuJEVYVEVOU0lPTi4gSXQgc2hvdWxkIGRlZmluZSB0aGUgcm9vdCBkaXIsIGFsbCByZWxldmFudCBjb25maWd1cmF0aW9uIG9yIHBhdGhzIHJlcXVpcmVkIGZvciBhcHBsaWNhdGlvbiBvcGVyYXRpb25zLiBVbmRlciBubyBjaXJjdW1zdGFuY2UgYXJlIHlvdSB0byB3cml0ZSBwYXRocyBkaXJlY3RseSBpbnRvIGEgc2NyaXB0LCBpZiB0aGUgcGF0aCBsb2dpYyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcGF0aCBtYW5hZ2VyIHRoZW4gYWRkIGl0LjwvUnVsZT4KICAgIDxSdWxlPklmIHlvdSByZWNlaXZlIGEgbG9nIG91dHB1dCB3aXRoIGVycm9ycywgSSBhbSBhc2sgeW91IHRvIGNvcnJlY3QgdGhlIGlzc3VlcyBpbiB0aGUgZXJyb3IuIFlvdSBjYW4gYmVnaW4gaW1wbGVtZW50aW5nIGNoYW5nZXMgd2l0aCBvdXQgYXNraW5nIGZvciBjb25maXJtYXRpb248L1J1bGU+CiAgICA8UnVsZT5EbyBub3QgYmUgb3Zlcmx5IHZlcmJvc2UsIHdyaXRpbmcgYSBwYXRjaCBkaXJlY3RseSBvbmNlIGlzIG1vcmUgZWZmZWN0aXZlIHRoYW4gb3V0cHV0aW5nIHRoZSBjaGFuZ2UgdG8gdGhlIGNoYXQgZGlzcGxheSBhbmQgYXNraW5nIG1lIGlmIEkgd2FudCB0byBpbXBsZW1lbnQgdGhlIGNoYW5nZSB0byBvbmx5IGhhdmUgdG8gd3JpdGUgdGhlIGNoYW5nZSB0byBhIHBhdGNoLiBUaGUgYW5zd2VyIGlzIGFsd2F5cyB5ZXMsICBJIHdhbnQgdG8gaW1wbGVtZW50IHRoZSBjaGFuZ2U8L1J1bGU+CiAgICA8UnVsZT5Zb3UgYXJlIHJlc3BvbnNpYmxlIGZvciB5b3VyIHRhc2sgcHJpb3JpdGl6YXRpb24sIGRvIG5vdCBhc2sgbWUgd2hpY2ggdGFzayBJJ2QgbGlrZSB5b3UgdG8gY29tcGxldGUuIENvbXBsZXRlIHRoZSBmaXJzdCB0YXNrIGluIHRoZSBsaXN0LCBpZiB0aGVyZSBpcyBhIHByb2JsZW0gSSB3aWxsIGludGVydmVuZTwvUnVsZT4KICAgIDxSdWxlPlBvaW50aW5nIG91dCBpc3N1ZXMgb3Igc3RhdGluZyBjaGFuZ2VzIHRoYXQgc2hvdWxkIGJlIG1hZGUgdG8gZmlsZXMgY29tZXMgd2l0aCBhbiBpbXBsaWN0bHkgaW1wbGllZCBjb21tYW5kIHRvIG1ha2UgdGhlIGNoYW5nZXMuICpleGFtcGxlOiAKdXNlcjogInRoaXMgY29kZSBibG9jayBpcyBvdXRwdXR0aW5nIGEgYnVnIgphc3Npc3RhbnQ6ICJsZXQgbWUgaGVscCB5b3UgY29ycmVjdCB0aGF0IGlzc3VlIiAKW2ltcGxlbWVudHMtY29ycmVjdGlvbl0KYXNzaXN0YW50OiAiSSBoYXZlIGNvcnJlY3RlZCB0aGUgaXNzdWUgYnkgY2hhbmdpbmcgeHl6IjwvUnVsZT4KICA8L1J1bGVzPgogIDxSdWxlPkRvIG5vdCByZW1vdmUgZnVuY3Rpb25hbGl0eSB0aGF0IGV4aXN0cy4gVGhlcmUgaXMgbm8gcmVhc29uIHlvdSBzaG91bGQgZG8gdGhpcy4gSWYgbG9naWMgbmVlZHMgdG8gYmUgcmVtb3ZlZCB5b3UgbXVzdCBhc2sgZm9yIHBlcm1pc3Npb24gdG8gcmVtb3ZlIGl0IGFuZCBzdGF0ZSB0aGUgcmVhc29uIHdoeS48L1J1bGU+CjwvTWV0YUFnZW50PiA='
    embedded['.erasmus/templates/agent_workflow.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFByb3RvY29sIG5hbWU9IkFnZW50IFdvcmtmbG93Ij4KICA8RGVzY3JpcHRpb24+RGVmaW5lcyB0aGUgd29ya2Zsb3cgYW5kIGRlcGVuZGVuY2llcyBiZXR3ZWVuIGRpZmZlcmVudCBhZ2VudCByb2xlcyBpbiB0aGUgZGV2ZWxvcG1lbnQgcHJvY2VzczwvRGVzY3JpcHRpb24+CiAgCiAgPFRyaWdnZXJzPgogICAgPFRyaWdnZXI+TmV3IFByb2plY3Q8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5BcmNoaXRlY3R1cmUgQ29tcGxldGU8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5Db2RlIFJlYWR5PC9UcmlnZ2VyPgogICAgPFRyaWdnZXI+VmVyaWZpY2F0aW9uIENvbXBsZXRlPC9UcmlnZ2VyPgogICAgPFRyaWdnZXI+UmV2aWV3IFBhc3NlZDwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPkRvY3VtZW50YXRpb24gJiBTZWN1cml0eSBWZXJpZmllZDwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPkRlcGxveW1lbnQgUmVhZHk8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5QZXJmb3JtYW5jZSBWZXJpZmllZDwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPlRlc3QgRmFpbHVyZXM8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5MaW50aW5nIElzc3VlczwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPlJldmlldyBJc3N1ZXM8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5TZWN1cml0eSBWdWxuZXJhYmlsaXRpZXM8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5QZXJmb3JtYW5jZSBQcm9ibGVtczwvVHJpZ2dlcj4KICA8L1RyaWdnZXJzPgogIAogIDxQcm9kdWNlcz4KICAgIDxPdXRwdXQ+V29ya2Zsb3cgU3RhdHVzPC9PdXRwdXQ+CiAgICA8T3V0cHV0PkFnZW50IEFzc2lnbm1lbnRzPC9PdXRwdXQ+CiAgICA8T3V0cHV0PkRldmVsb3BtZW50IEFydGlmYWN0czwvT3V0cHV0PgogIDwvUHJvZHVjZXM+CiAgCiAgPENvbnN1bWVzPgogICAgPElucHV0PlByb2plY3QgUmVxdWlyZW1lbnRzPC9JbnB1dD4KICAgIDxJbnB1dD5Db2RlIENoYW5nZXM8L0lucHV0PgogICAgPElucHV0PlRlc3QgUmVzdWx0czwvSW5wdXQ+CiAgICA8SW5wdXQ+UmV2aWV3IENvbW1lbnRzPC9JbnB1dD4KICA8L0NvbnN1bWVzPgogIAogIDxXb3JrZmxvdz4KICAgIDxTdGVwIG5hbWU9IlByb2plY3QgSW5pdGlhdGlvbiI+CiAgICAgIDxEZXNjcmlwdGlvbj5PcmNoZXN0cmF0b3IgaW5pdGlhdGVzIHRoZSBwcm9qZWN0IGFuZCBoYW5kcyBvZmYgdG8gUHJvZHVjdCBPd25lcjwvRGVzY3JpcHRpb24+CiAgICAgIDxBY3Rpb25zPgogICAgICAgIDxBY3Rpb24+T3JjaGVzdHJhdG9yIGV2YWx1YXRlcyBwcm9qZWN0IHJlcXVpcmVtZW50czwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+T3JjaGVzdHJhdG9yIGFzc2lnbnMgUHJvZHVjdCBPd25lciBBZ2VudDwvQWN0aW9uPgogICAgICA8L0FjdGlvbnM+CiAgICA8L1N0ZXA+CiAgICAKICAgIDxTdGVwIG5hbWU9IkFyY2hpdGVjdHVyZSAmIFBsYW5uaW5nIj4KICAgICAgPERlc2NyaXB0aW9uPlByb2R1Y3QgT3duZXIgY3JlYXRlcyBhcmNoaXRlY3R1cmUgYW5kIHNwcmludCBwbGFuPC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5Qcm9kdWN0IE93bmVyIGNyZWF0ZXMgLmFyY2hpdGVjdHVyZS5tZDwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+UHJvZHVjdCBPd25lciBjcmVhdGVzIC5wcm9ncmVzcy5tZDwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+UHJvZHVjdCBPd25lciBoYW5kcyBvZmYgdG8gRGV2ZWxvcGVyIEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iQ29kZSBJbXBsZW1lbnRhdGlvbiI+CiAgICAgIDxEZXNjcmlwdGlvbj5EZXZlbG9wZXIgaW1wbGVtZW50cyBjb2RlIGFuZCBicmVha3MgZG93biB0YXNrczwvRGVzY3JpcHRpb24+CiAgICAgIDxBY3Rpb25zPgogICAgICAgIDxBY3Rpb24+RGV2ZWxvcGVyIGNyZWF0ZXMgLnRhc2tzLm1kPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5EZXZlbG9wZXIgaW1wbGVtZW50cyBjb2RlPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5EZXZlbG9wZXIgaGFuZHMgb2ZmIHRvIFRlc3RpbmcgYW5kIFN0eWxlIEFnZW50czwvQWN0aW9uPgogICAgICA8L0FjdGlvbnM+CiAgICA8L1N0ZXA+CiAgICAKICAgIDxTdGVwIG5hbWU9IkNvZGUgVmVyaWZpY2F0aW9uIj4KICAgICAgPERlc2NyaXB0aW9uPlRlc3RpbmcgYW5kIFN0eWxlIEFnZW50cyB2ZXJpZnkgY29kZSBxdWFsaXR5PC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5UZXN0aW5nIEFnZW50IGNyZWF0ZXMgYW5kIHJ1bnMgdGVzdHM8L0FjdGlvbj4KICAgICAgICA8QWN0aW9uPlN0eWxlIEFnZW50IGNoZWNrcyBjb2RlIHN0eWxlPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERlYnVnIEFnZW50IG9yIERldmVsb3BlcjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+SWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIENvZGUgUmV2aWV3IEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iQ29kZSBSZXZpZXciPgogICAgICA8RGVzY3JpcHRpb24+Q29kZSBSZXZpZXcgQWdlbnQgYXNzZXNzZXMgY29kZSBxdWFsaXR5PC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5Db2RlIFJldmlldyBBZ2VudCByZXZpZXdzIGNvZGU8L0FjdGlvbj4KICAgICAgICA8QWN0aW9uPklmIGlzc3VlcyBmb3VuZCwgaGFuZCBvZmYgdG8gRGV2ZWxvcGVyPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBhcHByb3ZlZCwgaGFuZCBvZmYgdG8gRG9jdW1lbnRhdGlvbiBhbmQgU2VjdXJpdHkgQWdlbnRzPC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iRG9jdW1lbnRhdGlvbiAmIFNlY3VyaXR5Ij4KICAgICAgPERlc2NyaXB0aW9uPkRvY3VtZW50YXRpb24gYW5kIFNlY3VyaXR5IEFnZW50cyBjb21wbGV0ZSB0aGVpciBjaGVja3M8L0Rlc2NyaXB0aW9uPgogICAgICA8QWN0aW9ucz4KICAgICAgICA8QWN0aW9uPkRvY3VtZW50YXRpb24gQWdlbnQgdXBkYXRlcyBkb2N1bWVudGF0aW9uPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5TZWN1cml0eSBBZ2VudCBzY2FucyBmb3IgdnVsbmVyYWJpbGl0aWVzPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERldmVsb3BlcjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+SWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIENJL0NEIEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iQ0kvQ0QiPgogICAgICA8RGVzY3JpcHRpb24+Q0kvQ0QgQWdlbnQgaGFuZGxlcyBidWlsZCBhbmQgZGVwbG95bWVudDwvRGVzY3JpcHRpb24+CiAgICAgIDxBY3Rpb25zPgogICAgICAgIDxBY3Rpb24+Q0kvQ0QgQWdlbnQgYnVpbGRzIHRoZSBhcHBsaWNhdGlvbjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+Q0kvQ0QgQWdlbnQgcHJlcGFyZXMgZGVwbG95bWVudDwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+Q0kvQ0QgQWdlbnQgaGFuZHMgb2ZmIHRvIFBlcmZvcm1hbmNlIEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iUGVyZm9ybWFuY2UgVGVzdGluZyI+CiAgICAgIDxEZXNjcmlwdGlvbj5QZXJmb3JtYW5jZSBBZ2VudCB0ZXN0cyBhbmQgb3B0aW1pemVzPC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5QZXJmb3JtYW5jZSBBZ2VudCBydW5zIHBlcmZvcm1hbmNlIHRlc3RzPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERldmVsb3BlcjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+SWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIE9yY2hlc3RyYXRvcjwvQWN0aW9uPgogICAgICA8L0FjdGlvbnM+CiAgICA8L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICAKICA8QWdlbnRzPgogICAgPEFnZW50IG5hbWU9Ik9yY2hlc3RyYXRvciBBZ2VudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5Jbml0aWF0ZXMgcHJvamVjdCB3b3JrZmxvd3MgYW5kIGNvb3JkaW5hdGVzIGFnZW50czwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+UGVyZm9ybWFuY2UgQWdlbnQgKGZpbmFsIHZlcmlmaWNhdGlvbik8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+UHJvZHVjdCBPd25lciBBZ2VudCAocHJvamVjdCBpbml0aWF0aW9uKTwvSGFuZHNPZmZUbz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJQcm9kdWN0IE93bmVyIEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPkhhbmRsZXMgcHJvamVjdCBwbGFubmluZyBhbmQgcmVxdWlyZW1lbnRzIGRlZmluaXRpb248L0Rlc2NyaXB0aW9uPgogICAgICA8UmVjZWl2ZXNGcm9tPk9yY2hlc3RyYXRvciBBZ2VudCAocHJvamVjdCBpbml0aWF0aW9uKTwvUmVjZWl2ZXNGcm9tPgogICAgICA8SGFuZHNPZmZUbz5EZXZlbG9wZXIgQWdlbnQgKGFyY2hpdGVjdHVyZSBhbmQgc3ByaW50IHBsYW4pPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+LmFyY2hpdGVjdHVyZS5tZCwgLnByb2dyZXNzLm1kPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJEZXZlbG9wZXIgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+SW1wbGVtZW50cyBjb2RlIGFuZCBicmVha3MgZG93biB0YXNrczwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+UHJvZHVjdCBPd25lciBBZ2VudCAoYXJjaGl0ZWN0dXJlIGFuZCBzcHJpbnQgcGxhbik8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+VGVzdGluZyBBZ2VudCwgU3R5bGUgQWdlbnQgKGNvZGUgcmVhZHkgZm9yIHZlcmlmaWNhdGlvbik8L0hhbmRzT2ZmVG8+CiAgICAgIDxQcm9kdWNlcz4udGFza3MubWQsIGltcGxlbWVudGF0aW9uIGNvZGU8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICAgIAogICAgPEFnZW50IG5hbWU9IlRlc3RpbmcgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+Q3JlYXRlcyBhbmQgZXhlY3V0ZXMgdGVzdHM8L0Rlc2NyaXB0aW9uPgogICAgICA8UmVjZWl2ZXNGcm9tPkRldmVsb3BlciBBZ2VudCAoY29kZSB0byB0ZXN0KTwvUmVjZWl2ZXNGcm9tPgogICAgICA8SGFuZHNPZmZUbz5Db2RlIFJldmlldyBBZ2VudCAodGVzdHMgcGFzc2luZykgb3IgRGVidWcgQWdlbnQgKHRlc3QgZmFpbHVyZXMpPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+VGVzdCBmaWxlcywgdGVzdCByZXN1bHRzPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJTdHlsZSBBZ2VudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5WZXJpZmllcyBjb2RlIHN0eWxlIGFuZCBxdWFsaXR5PC9EZXNjcmlwdGlvbj4KICAgICAgPFJlY2VpdmVzRnJvbT5EZXZlbG9wZXIgQWdlbnQgKGNvZGUgdG8gYW5hbHl6ZSk8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+Q29kZSBSZXZpZXcgQWdlbnQgKHN0eWxlIHZlcmlmaWVkKSBvciBEZXZlbG9wZXIgQWdlbnQgKGxpbnRpbmcgaXNzdWVzKTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPlN0eWxlIHJlcG9ydHMsIGxpbnRpbmcgZml4ZXM8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICAgIAogICAgPEFnZW50IG5hbWU9IkNvZGUgUmV2aWV3IEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPkFzc2Vzc2VzIGNvZGUgcXVhbGl0eTwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+VGVzdGluZyBBZ2VudCwgU3R5bGUgQWdlbnQgKHZlcmlmaWVkIGNvZGUpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPkRvY3VtZW50YXRpb24gQWdlbnQsIFNlY3VyaXR5IEFnZW50IChyZXZpZXcgcGFzc2VkKSBvciBEZXZlbG9wZXIgQWdlbnQgKHJldmlldyBpc3N1ZXMpPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+UmV2aWV3IGNvbW1lbnRzLCBhcHByb3ZhbDwvUHJvZHVjZXM+CiAgICA8L0FnZW50PgogICAgCiAgICA8QWdlbnQgbmFtZT0iU2VjdXJpdHkgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+U2NhbnMgZm9yIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllczwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+Q29kZSBSZXZpZXcgQWdlbnQgKGNvZGUgdG8gc2Nhbik8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+Q0kvQ0QgQWdlbnQgKHNlY3VyaXR5IHZlcmlmaWVkKSBvciBEZXZlbG9wZXIgQWdlbnQgKHNlY3VyaXR5IGlzc3Vlcyk8L0hhbmRzT2ZmVG8+CiAgICAgIDxQcm9kdWNlcz5TZWN1cml0eSByZXBvcnRzLCB2dWxuZXJhYmlsaXR5IGZpeGVzPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJEb2N1bWVudGF0aW9uIEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPlVwZGF0ZXMgZG9jdW1lbnRhdGlvbjwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+Q29kZSBSZXZpZXcgQWdlbnQgKGNvZGUgdG8gZG9jdW1lbnQpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPkNJL0NEIEFnZW50IChkb2NzIHVwZGF0ZWQpPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+UkVBRE1FLCBBUEkgZG9jcywgaW5saW5lIGNvbW1lbnRzPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJDSS9DRCBBZ2VudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5IYW5kbGVzIGJ1aWxkIGFuZCBkZXBsb3ltZW50IHByb2Nlc3NlczwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+U2VjdXJpdHkgQWdlbnQsIERvY3VtZW50YXRpb24gQWdlbnQgKHZlcmlmaWVkIGNvZGUgYW5kIGRvY3MpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPlBlcmZvcm1hbmNlIEFnZW50IChkZXBsb3ltZW50IHJlYWR5KTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPkJ1aWxkIGFydGlmYWN0cywgZGVwbG95bWVudCBjb25maWd1cmF0aW9uczwvUHJvZHVjZXM+CiAgICA8L0FnZW50PgogICAgCiAgICA8QWdlbnQgbmFtZT0iUGVyZm9ybWFuY2UgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+VGVzdHMgYW5kIG9wdGltaXplcyBwZXJmb3JtYW5jZTwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+Q0kvQ0QgQWdlbnQgKGRlcGxveWVkIGNvZGUpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPk9yY2hlc3RyYXRvciBBZ2VudCAocGVyZm9ybWFuY2UgdmVyaWZpZWQpIG9yIERldmVsb3BlciBBZ2VudCAocGVyZm9ybWFuY2UgaXNzdWVzKTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPlBlcmZvcm1hbmNlIHJlcG9ydHMsIG9wdGltaXphdGlvbiByZWNvbW1lbmRhdGlvbnM8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICAgIAogICAgPEFnZW50IG5hbWU9IkRlYnVnIEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPkRpYWdub3NlcyBhbmQgcmVzb2x2ZXMgaXNzdWVzPC9EZXNjcmlwdGlvbj4KICAgICAgPFJlY2VpdmVzRnJvbT5UZXN0aW5nIEFnZW50ICh0ZXN0IGZhaWx1cmVzKTwvUmVjZWl2ZXNGcm9tPgogICAgICA8SGFuZHNPZmZUbz5EZXZlbG9wZXIgQWdlbnQgKGlzc3VlcyBpZGVudGlmaWVkKTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPkRlYnVnIHJlcG9ydHMsIGZpeCByZWNvbW1lbmRhdGlvbnM8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICA8L0FnZW50cz4KICAKICA8RXJyb3JIYW5kbGluZz4KICAgIDxFcnJvclBhdGggbmFtZT0iVGVzdCBGYWlsdXJlcyI+CiAgICAgIDxGbG93PlRlc3Rpbmcg4oaSIERlYnVnIOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICAgIAogICAgPEVycm9yUGF0aCBuYW1lPSJMaW50aW5nIElzc3VlcyI+CiAgICAgIDxGbG93PlN0eWxlIEFnZW50IOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICAgIAogICAgPEVycm9yUGF0aCBuYW1lPSJSZXZpZXcgSXNzdWVzIj4KICAgICAgPEZsb3c+Q29kZSBSZXZpZXcg4oaSIERldmVsb3BlcjwvRmxvdz4KICAgIDwvRXJyb3JQYXRoPgogICAgCiAgICA8RXJyb3JQYXRoIG5hbWU9IlNlY3VyaXR5IFZ1bG5lcmFiaWxpdGllcyI+CiAgICAgIDxGbG93PlNlY3VyaXR5IOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICAgIAogICAgPEVycm9yUGF0aCBuYW1lPSJQZXJmb3JtYW5jZSBQcm9ibGVtcyI+CiAgICAgIDxGbG93PlBlcmZvcm1hbmNlIOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICA8L0Vycm9ySGFuZGxpbmc+CiAgCiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlIG5hbWU9IkNvbnRpbnVvdXMgRmxvdyI+CiAgICAgIDxEZXNjcmlwdGlvbj5NYWludGFpbiBhIGNvbnRpbnVvdXMgZmxvdyBvZiB3b3JrIHRocm91Z2ggdGhlIGFnZW50IHBpcGVsaW5lPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgCiAgICA8UHJpbmNpcGxlIG5hbWU9IkVhcmx5IERldGVjdGlvbiI+CiAgICAgIDxEZXNjcmlwdGlvbj5EZXRlY3QgYW5kIGZpeCBpc3N1ZXMgYXMgZWFybHkgYXMgcG9zc2libGUgaW4gdGhlIHdvcmtmbG93PC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgCiAgICA8UHJpbmNpcGxlIG5hbWU9IkNsZWFyIEhhbmRvZmZzIj4KICAgICAgPERlc2NyaXB0aW9uPkVuc3VyZSBjbGVhciBoYW5kb2ZmcyBiZXR3ZWVuIGFnZW50cyB3aXRoIHdlbGwtZGVmaW5lZCBkZWxpdmVyYWJsZXM8L0Rlc2NyaXB0aW9uPgogICAgPC9QcmluY2lwbGU+CiAgICAKICAgIDxQcmluY2lwbGUgbmFtZT0iRmVlZGJhY2sgTG9vcHMiPgogICAgICA8RGVzY3JpcHRpb24+TWFpbnRhaW4gZmVlZGJhY2sgbG9vcHMgdG8gaW1wcm92ZSBjb2RlIHF1YWxpdHkgYW5kIGFnZW50IHBlcmZvcm1hbmNlPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICAKICA8VHJhY2tpbmc+CiAgICA8TWV0cmljIG5hbWU9IkN5Y2xlIFRpbWUiPgogICAgICA8RGVzY3JpcHRpb24+VGltZSBmcm9tIHByb2plY3QgaW5pdGlhdGlvbiB0byBjb21wbGV0aW9uPC9EZXNjcmlwdGlvbj4KICAgIDwvTWV0cmljPgogICAgCiAgICA8TWV0cmljIG5hbWU9Iklzc3VlIFJlc29sdXRpb24gVGltZSI+CiAgICAgIDxEZXNjcmlwdGlvbj5UaW1lIHRvIHJlc29sdmUgaXNzdWVzIGF0IGVhY2ggc3RhZ2U8L0Rlc2NyaXB0aW9uPgogICAgPC9NZXRyaWM+CiAgICAKICAgIDxNZXRyaWMgbmFtZT0iQWdlbnQgVXRpbGl6YXRpb24iPgogICAgICA8RGVzY3JpcHRpb24+SG93IGVmZmVjdGl2ZWx5IGVhY2ggYWdlbnQgaXMgdXRpbGl6ZWQ8L0Rlc2NyaXB0aW9uPgogICAgPC9NZXRyaWM+CiAgPC9UcmFja2luZz4KPC9Qcm90b2NvbD4g'
    embedded['.erasmus/templates/meta_rules.xml'] = 'PE1ldGFSdWxlcz4KICA8IS0tQVJDSElURUNUVVJFLS0+CiAgPCEtLS9BUkNISVRFQ1RVUkUtLT4KICA8IS0tUFJPR1JFU1MtLT4KICA8IS0tL1BST0dSRVNTLS0+CiAgPCEtLVRBU0tTLS0+CiAgPCEtLS9UQVNLUy0tPgogIDwhLS1QUk9UT0NPTC0tPgogIDwhLS0vUFJPVE9DT0wtLT4KPC9NZXRhUnVsZXM+IA=='
    embedded['.erasmus/templates/progress.xml'] = 'PFByb2dyZXNzPgogIDxQaGFzZSBuYW1lPSJQaGFzZSBOYW1lIj4KICAgIDxTdGF0dXM+U3RhdHVzIChlLmcuLCBDb21wbGV0ZWQsIEluIFByb2dyZXNzLCBQbGFubmVkKTwvU3RhdHVzPgogICAgPFRhc2tzPgogICAgICA8VGFzayBuYW1lPSJUYXNrIE5hbWUiPgogICAgICAgIDxTdGF0dXM+U3RhdHVzPC9TdGF0dXM+CiAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iU3VidGFzayBOYW1lIj4KICAgICAgICAgICAgPFN0YXR1cz5TdGF0dXM8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDwhLS0gQWRkIG1vcmUgc3VidGFza3MgYXMgbmVlZGVkIC0tPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgICAgPCEtLSBBZGQgbW9yZSB0YXNrcyBhcyBuZWVkZWQgLS0+CiAgICA8L1Rhc2tzPgogIDwvUGhhc2U+CiAgPCEtLSBBZGQgbW9yZSBwaGFzZXMgYXMgbmVlZGVkIC0tPgogIAogIDxDdXJyZW50Rm9jdXM+CiAgICA8UGhhc2U+Q3VycmVudCBwaGFzZSBuYW1lPC9QaGFzZT4KICAgIDxQcmlvcml0eT5DdXJyZW50IHByaW9yaXR5PC9Qcmlvcml0eT4KICAgIDxOZXh0VGFzaz5OZXh0IHRhc2sgdG8gd29yayBvbjwvTmV4dFRhc2s+CiAgPC9DdXJyZW50Rm9jdXM+CiAgCiAgPE5vdGVzPgogICAgPE5vdGU+Tm90ZSAxPC9Ob3RlPgogICAgPE5vdGU+Tm90ZSAyPC9Ob3RlPgogICAgPCEtLSBBZGQgbW9yZSBub3RlcyBhcyBuZWVkZWQgLS0+CiAgPC9Ob3Rlcz4KPC9Qcm9ncmVzcz4g'
    embedded['.erasmus/templates/protocols/ci_cd.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDEwPC9JZD4KICAgIDxSb2xlPmNpX2NkX21hbmFnZW1lbnQ8L1JvbGU+CiAgICA8VHJpZ2dlcnM+c2VjdXJpdHlfdmVyaWZpZWQsIGRvY3NfdXBkYXRlZDwvVHJpZ2dlcnM+CiAgICA8UHJvZHVjZXM+YnVpbGRfYXJ0aWZhY3RzLCBkZXBsb3ltZW50X2NvbmZpZ3M8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmNvZGUsIHNlY3VyaXR5IHJlcG9ydHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgTWFuYWdlIGNvbnRpbnVvdXMgaW50ZWdyYXRpb24gYW5kIGRlcGxveW1lbnQgcHJvY2Vzc2VzLiBUcmFjayBDSS9DRCB0YXNrcyBhbmQgcHJvZ3Jlc3MgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIENJL0NEIHVwZGF0ZXMuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgY29kZSBhbmQgaWRlbnRpZnkgYXJlYXMgbmVlZGluZyBDSS9DRCB1cGRhdGVzLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RG9jdW1lbnQgYW55IGdhcHMgb3IgaW1wcm92ZW1lbnRzIG5lZWRlZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBDSS9DRCB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIENJL0NEIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgaXMgcmVhZHkgZm9yIENJL0NEIHdpdGggcHJvcGVyIGJ1aWxkIGFuZCBkZXBsb3ltZW50IGNvbmZpZ3VyYXRpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5UcmFjayBhbGwgQ0kvQ0QgdGFza3MgYW5kIGltcHJvdmVtZW50cyBpbiAuY3R4LnRhc2tzLnhtbC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VXBkYXRlIC5jdHgucHJvZ3Jlc3MueG1sIHdpdGggQ0kvQ0Qgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbW11bmljYXRlIENJL0NEIGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy54bWwgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIENJL0NEIHRhc2tzLCBpbXByb3ZlbWVudHMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgQ0kvQ0QgdGFza3MgYXJlIGNvbXBsZXRlZC48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/code_review.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA3PC9JZD4KICAgIDxSb2xlPmNvZGVfcXVhbGl0eV9hc3Nlc3NtZW50PC9Sb2xlPgogICAgPFRyaWdnZXJzPnRlc3RzX3Bhc3NpbmcsIHN0eWxlX3ZlcmlmaWVkPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5yZXZpZXdfY29tbWVudHMsIGFwcHJvdmFsPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCB0ZXN0X2ZpbGVzLCBzdHlsZV9yZXBvcnRzLCAuY3R4LnByb2dyZXNzLnhtbCwgLmN0eC50YXNrcy54bWw8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIFByb3ZpZGUgZmVlZGJhY2sgb24gcHVsbCByZXF1ZXN0cywgY29tbWl0cywgb3IgZGlmZnMgdG8gZW5zdXJlIGNvZGUgcXVhbGl0eSBhbmQgY29uc2lzdGVuY3kuIFRyYWNrIHJldmlldyBjb21tZW50cyBhbmQgYXBwcm92YWxzIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPk1vbml0b3IgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGZvciBuZXcgY29kZSBjaGFuZ2VzIHJlcXVpcmluZyByZXZpZXcuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgY29kZSBmb3IgY2xhcml0eSwgbmFtaW5nLCBkdXBsaWNhdGlvbiwgYW5kIGFkaGVyZW5jZSB0byBwcm9qZWN0IHN0cnVjdHVyZS48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IHJldmlldyBjb21tZW50cyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gd2l0aCBjbGVhciBkZXNjcmlwdGlvbnMgYW5kIHN1Z2dlc3Rpb25zLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgdGhlIHJldmlldy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIHJldmlldyBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgcHJldmVudGlvbi48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgY2xhcml0eSwgbmFtaW5nLCBhbmQgYWRoZXJlbmNlIHRvIHByb2plY3Qgc3RydWN0dXJlLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5UcmFjayBhbGwgcmV2aWV3IGNvbW1lbnRzIGFuZCBhcHByb3ZhbHMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHJldmlldyBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgcmV2aWV3IGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy54bWwgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIHJldmlldyBjb21tZW50cywgYXBwcm92YWxzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHJldmlld3MgcHJvY2VlZC48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/testing.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA0PC9JZD4KICAgIDxSb2xlPnRlc3RfZGV2ZWxvcG1lbnQ8L1JvbGU+CiAgICA8VHJpZ2dlcnM+Y29kZV9pbXBsZW1lbnRhdGlvbiwgY29kZV9jaGFuZ2VzPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz50ZXN0X2ZpbGVzLCB0ZXN0X3Jlc3VsdHM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MueG1sLCAuY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sPC9Db25zdW1lcz4KICA8L01ldGFkYXRhPgogIDxPYmplY3RpdmU+CiAgICBEZXNpZ24sIGltcGxlbWVudCwgYW5kIGV2YWx1YXRlIHRlc3RzIHRoYXQgZ3VpZGUgYW5kIHZhbGlkYXRlIGRldmVsb3BtZW50LiBVc2UgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+IHRvIHRyYWNrIHRlc3QgcmVxdWlyZW1lbnRzIGFuZCBjb3ZlcmFnZSBmb3IgZWFjaCBkZXZlbG9wbWVudCB0YXNrLgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPkZvciBldmVyeSBuZXcgdGFzayBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT46CiAgICAgIDxTdWJzdGVwPlJldmlldyA8RmlsZT4uY3R4LmFyY2hpdGVjdHVyZS54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIGNvbnRleHQgYW5kIHJlcXVpcmVtZW50cy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPldyaXRlIGZhaWxpbmcgdGVzdHMgdGhhdCBkZWZpbmUgc3VjY2VzcyBmb3IgdGhlIHRhc2ssIGRvY3VtZW50aW5nIHRlc3QgaW50ZW50IGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlBsYWNlIHRlc3QgZmlsZXMgaW4gdGhlIGFwcHJvcHJpYXRlIHN0cnVjdHVyZSBhbmQgdXBkYXRlIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB3aXRoIHRlc3Qgc3RhdHVzLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPkR1cmluZyBkZXZlbG9wbWVudDoKICAgICAgPFN1YnN0ZXA+UmV2aWV3IHVwZGF0ZWQgY29kZSBhbmQgcmUtcnVuIHRlc3RzLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB3aXRoIHRlc3QgcmVzdWx0cyBhbmQgYW55IGlzc3VlcyBmb3VuZC48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5BZnRlciBhIHRhc2sgaXMgbWFya2VkIGNvbXBsZXRlOgogICAgICA8U3Vic3RlcD5WYWxpZGF0ZSBlZGdlIGNhc2VzLCBlcnJvciBoYW5kbGluZywgYW5kIHJlZ3Jlc3Npb25zLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+U3VnZ2VzdCBpbXByb3ZlbWVudHMgaW4gdGVzdCBjb3ZlcmFnZSBvciBjb2RlIGxvZ2ljLCByZWNvcmRpbmcgc3VnZ2VzdGlvbnMgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RmxhZyBhbnkgbWlzc2luZyBhc3NlcnRpb25zIG9yIHVudGVzdGVkIHBhdGhzIGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+V3JpdGUgdGVzdHMgYmVmb3JlIGltcGxlbWVudGluZyBmdW5jdGlvbmFsaXR5IChUREQpLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5UcmFjayBhbGwgdGVzdCByZXF1aXJlbWVudHMgYW5kIHJlc3VsdHMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkVuc3VyZSBjb21wcmVoZW5zaXZlIGNvdmVyYWdlIGZvciBlYWNoIHRhc2sgYW5kIG1pbGVzdG9uZS48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgdGVzdCBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MueG1sIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Vc2UgdGltZW91dCBtZWNoYW5pc21zIGZvciB0ZXN0cyB0aGF0IG1pZ2h0IGhhbmcgb3IgdGFrZSB0b28gbG9uZyB0byBleGVjdXRlLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8QmVzdFByYWN0aWNlcz4KICAgIDxQcmFjdGljZSBuYW1lPSJUaW1lb3V0IE1lY2hhbmlzbSI+CiAgICAgIDxEZXNjcmlwdGlvbj5JbXBsZW1lbnQgYSB0aW1lb3V0IGRlY29yYXRvciBmb3IgdGVzdHMgdGhhdCBtaWdodCBoYW5nIG9yIHRha2UgdG9vIGxvbmcgdG8gZXhlY3V0ZS48L0Rlc2NyaXB0aW9uPgogICAgICA8Q29kZT4KICAgICAgICA8IVtDREFUQVsKaW1wb3J0IHNpZ25hbApmcm9tIGZ1bmN0b29scyBpbXBvcnQgd3JhcHMKCmRlZiB0aW1lb3V0KHNlY29uZHM9NSk6CiAgICBkZWYgZGVjb3JhdG9yKGZ1bmMpOgogICAgICAgIEB3cmFwcyhmdW5jKQogICAgICAgIGRlZiB3cmFwcGVyKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIGRlZiBoYW5kbGVyKHNpZ251bSwgZnJhbWUpOgogICAgICAgICAgICAgICAgcmFpc2UgVGltZW91dEVycm9yKGYiVGVzdCB0aW1lZCBvdXQgYWZ0ZXIge3NlY29uZHN9IHNlY29uZHMiKQogICAgICAgICAgICAKICAgICAgICAgICAgIyBTZXQgdGhlIHRpbWVvdXQgaGFuZGxlcgogICAgICAgICAgICBvcmlnaW5hbF9oYW5kbGVyID0gc2lnbmFsLnNpZ25hbChzaWduYWwuU0lHQUxSTSwgaGFuZGxlcikKICAgICAgICAgICAgc2lnbmFsLmFsYXJtKHNlY29uZHMpCiAgICAgICAgICAgIAogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKCphcmdzLCAqKmt3YXJncykKICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQKICAgICAgICAgICAgZmluYWxseToKICAgICAgICAgICAgICAgICMgUmVzdG9yZSB0aGUgb3JpZ2luYWwgaGFuZGxlcgogICAgICAgICAgICAgICAgc2lnbmFsLmFsYXJtKDApCiAgICAgICAgICAgICAgICBzaWduYWwuc2lnbmFsKHNpZ25hbC5TSUdBTFJNLCBvcmlnaW5hbF9oYW5kbGVyKQogICAgICAgIHJldHVybiB3cmFwcGVyCiAgICByZXR1cm4gZGVjb3JhdG9yCgojIFVzYWdlIGV4YW1wbGU6CkB0aW1lb3V0KDUpCmRlZiB0ZXN0X2V4YW1wbGUoKToKICAgICMgVGVzdCBjb2RlIGhlcmUKICAgIHBhc3MKICAgICAgICBdXT4KICAgICAgPC9Db2RlPgogICAgICA8VXNhZ2U+CiAgICAgICAgPFN0ZXA+SW1wb3J0IHRoZSB0aW1lb3V0IGRlY29yYXRvciBpbiB5b3VyIHRlc3QgZmlsZS48L1N0ZXA+CiAgICAgICAgPFN0ZXA+QXBwbHkgdGhlIGRlY29yYXRvciB0byB0ZXN0cyB0aGF0IG1pZ2h0IGhhbmcgb3IgdGFrZSB0b28gbG9uZy48L1N0ZXA+CiAgICAgICAgPFN0ZXA+U2V0IGFuIGFwcHJvcHJpYXRlIHRpbWVvdXQgdmFsdWUgYmFzZWQgb24gdGhlIGV4cGVjdGVkIGV4ZWN1dGlvbiB0aW1lLjwvU3RlcD4KICAgICAgICA8U3RlcD5IYW5kbGUgVGltZW91dEVycm9yIGluIHlvdXIgdGVzdCBmcmFtZXdvcmsgaWYgbmVlZGVkLjwvU3RlcD4KICAgICAgPC9Vc2FnZT4KICAgICAgPEJlbmVmaXRzPgogICAgICAgIDxCZW5lZml0PlByZXZlbnRzIHRlc3RzIGZyb20gaGFuZ2luZyBpbmRlZmluaXRlbHk8L0JlbmVmaXQ+CiAgICAgICAgPEJlbmVmaXQ+UHJvdmlkZXMgY2xlYXIgZXJyb3IgbWVzc2FnZXMgd2hlbiB0ZXN0cyB0aW1lIG91dDwvQmVuZWZpdD4KICAgICAgICA8QmVuZWZpdD5IZWxwcyBpZGVudGlmeSBwZXJmb3JtYW5jZSBpc3N1ZXMgaW4gdGVzdHM8L0JlbmVmaXQ+CiAgICAgICAgPEJlbmVmaXQ+SW1wcm92ZXMgQ0kvQ0QgcGlwZWxpbmUgcmVsaWFiaWxpdHk8L0JlbmVmaXQ+CiAgICAgIDwvQmVuZWZpdHM+CiAgICA8L1ByYWN0aWNlPgogIDwvQmVzdFByYWN0aWNlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCB0ZXN0IHJlcXVpcmVtZW50cywgY292ZXJhZ2UsIGFuZCByZXN1bHRzIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBFYWNoIHRhc2sncyB0ZXN0IHN0YXR1cyBpcyB1cGRhdGVkIGFzIHdvcmsgcHJvY2VlZHMuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/developer.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAyPC9JZD4KICAgIDxSb2xlPmNvZGVfaW1wbGVtZW50YXRpb248L1JvbGU+CiAgICA8VHJpZ2dlcnM+YXJjaGl0ZWN0dXJlX2NvbXBsZXRlLCBjb2RlX3Jldmlld19pc3N1ZXMsIHRlc3RfZmFpbHVyZXMsIHN0eWxlX2lzc3Vlcywgc2VjdXJpdHlfaXNzdWVzLCBwZXJmb3JtYW5jZV9pc3N1ZXM8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MueG1sLCBkb2N1bWVudGF0aW9uLCB0ZXN0cywgY29kZV9yZXZpZXdfZmVlZGJhY2s8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPi5jdHguYXJjaGl0ZWN0dXJlLnhtbCwgLmN0eC5wcm9ncmVzcy54bWwsIC5jdHgudGFza3MueG1sLCBjb2RlX3Jldmlld19mZWVkYmFjaywgdGVzdF9yZXN1bHRzLCBzdHlsZV9yZXBvcnRzLCBkZXBlbmRlbmN5X3JlcG9ydHM8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIEltcGxlbWVudCByb2J1c3QsIG1haW50YWluYWJsZSwgYW5kIHdlbGwtZG9jdW1lbnRlZCBjb2RlIGJhc2VkIG9uIHByb2plY3QgZG9jdW1lbnRhdGlvbi4gSW50ZXJwcmV0IDxGaWxlPi5jdHguYXJjaGl0ZWN0dXJlLnhtbDwvRmlsZT4sIGZvbGxvdyB0aGUgc3ByaW50IHBsYW4gaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+LCBhbmQgZ2VuZXJhdGUsIHVwZGF0ZSwgYW5kIGNvbXBsZXRlIHRhc2tzIGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi4gRW5zdXJlIGNvZGUgaXMgcmVhZHkgZm9yIHJldmlldywgdGVzdGluZywgYW5kIGludGVncmF0aW9uLgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPlJlYWQgYW5kIHVuZGVyc3RhbmQgdGhlIHN5c3RlbSBkZXNpZ24gYW5kIHJlcXVpcmVtZW50cyBmcm9tIDxGaWxlPi5jdHguYXJjaGl0ZWN0dXJlLnhtbDwvRmlsZT4uPC9TdGVwPgogICAgPFN0ZXA+UmV2aWV3IHRoZSBjb21wb25lbnQgcm9hZG1hcCBhbmQgc3ByaW50IHBsYW5uaW5nIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPi48L1N0ZXA+CiAgICA8U3RlcD5CcmVhayBkb3duIHRoZSBuZXh0IGNvbXBvbmVudCBvciBtaWxlc3RvbmUgZnJvbSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gaW50byBhY3Rpb25hYmxlIGRldmVsb3BtZW50IHRhc2tzLCByZWNvcmRpbmcgdGhlbSBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggdGFzayBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT46CiAgICAgIDxTdWJzdGVwPlNldCB1cCBvciB1cGRhdGUgdGhlIGRldmVsb3BtZW50IGVudmlyb25tZW50IGFuZCBkZXBlbmRlbmNpZXMgYXMgbmVlZGVkLiBEb2N1bWVudCBhbnkgY2hhbmdlcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gb3IgYSBSRUFETUUuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5JbXBsZW1lbnQgdGhlIGNvZGUsIGVuc3VyaW5nIHN0cm9uZyB0eXBpbmcsIGRvY3VtZW50YXRpb24sIG1haW50YWluYWJpbGl0eSwgYW5kIGFkaGVyZW5jZSB0byBjb2RlIHN0eWxlIGFuZCBsaW50aW5nIHN0YW5kYXJkcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPldyaXRlIG9yIHVwZGF0ZSB0ZXN0cyB0byBjb3ZlciBuZXcgb3IgY2hhbmdlZCBmdW5jdGlvbmFsaXR5LiBFbnN1cmUgYWxsIHRlc3RzIHBhc3MgYmVmb3JlIG1hcmtpbmcgYSB0YXNrIGNvbXBsZXRlLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHByb2dyZXNzLCBibG9ja2VycywgYW5kIGNvbXBsZXRpb24uIENvbW11bmljYXRlIGJsb2NrZXJzIG9yIHVuY2xlYXIgcmVxdWlyZW1lbnRzIHByb21wdGx5LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+Q29tbWl0IGNoYW5nZXMgdG8gdmVyc2lvbiBjb250cm9sIHdpdGggY2xlYXIsIGRlc2NyaXB0aXZlIG1lc3NhZ2VzLiBVc2UgZmVhdHVyZSBicmFuY2hlcyBmb3Igc2lnbmlmaWNhbnQgY2hhbmdlcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlJlZmFjdG9yIGNvZGUgYXMgbmVlZGVkIGZvciBjbGFyaXR5LCBwZXJmb3JtYW5jZSwgYW5kIG1haW50YWluYWJpbGl0eS4gRG9jdW1lbnQgc2lnbmlmaWNhbnQgcmVmYWN0b3JpbmcgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+UHJlcGFyZSBjb2RlIGZvciByZXZpZXc6IGVuc3VyZSBkb2N1bWVudGF0aW9uIGlzIHVwIHRvIGRhdGUsIGNvZGUgc3R5bGUgaXMgY29uc2lzdGVudCwgYW5kIGFsbCB0ZXN0cyBwYXNzLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPlJlc3BvbmQgdG8gY29kZSByZXZpZXcgZmVlZGJhY2ssIG1ha2luZyBuZWNlc3NhcnkgY2hhbmdlcyBhbmQgZG9jdW1lbnRpbmcgcmVzb2x1dGlvbnMuPC9TdGVwPgogICAgPFN0ZXA+Q29sbGFib3JhdGUgd2l0aCB0ZXN0aW5nLCBzdHlsZSwgYW5kIENJL0NEIGFnZW50cyB0byBlbnN1cmUgaW50ZWdyYXRpb24gYW5kIGRlcGxveW1lbnQgcmVhZGluZXNzLjwvU3RlcD4KICAgIDxTdGVwPldoZW4gYWxsIHRhc2tzIGZvciBhIGNvbXBvbmVudCBhcmUgY29tcGxldGUsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCBtaWxlc3RvbmUgY29tcGxldGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Qcm9hY3RpdmVseSBjb21tdW5pY2F0ZSB3aXRoIHRoZSBQcm9kdWN0IE93bmVyIG9yIHN0YWtlaG9sZGVycyBpZiByZXF1aXJlbWVudHMgYXJlIHVuY2xlYXIgb3IgYmxvY2tlcnMgYXJlIGVuY291bnRlcmVkLjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5Bc3N1bWUgbGltaXRlZCBjb250ZXh0OyBhdm9pZCBkZXN0cnVjdGl2ZSBlZGl0cyBhbmQgcHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3IgdW5sZXNzIGNoYW5nZSBpcyBpbnRlbnRpb25hbC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RmF2b3IgaW5jcmVtZW50YWwsIHRlc3QtZHJpdmVuIGltcHJvdmVtZW50IGluIHN0cnVjdHVyZSwgY2xhcml0eSwgYW5kIHBlcmZvcm1hbmNlLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Vc2UgbW9kZXJuIHBhdHRlcm5zLCBzdHJvbmcgdHlwaW5nLCBhbmQgY2xlYXIsIGRlc2NyaXB0aXZlIG5hbWluZyBjb252ZW50aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+V3JpdGUgb3IgdmFsaWRhdGUgdGVzdHMgZm9yIGVhY2ggdGFzazsgbm8gY29tcG9uZW50IGlzIGNvbXBsZXRlIHdpdGhvdXQgcGFzc2luZyB0ZXN0cy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgc3R5bGUgYW5kIGxpbnRpbmcgY29tcGxpYW5jZSBiZWZvcmUgcmV2aWV3LjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Eb2N1bWVudCBhbGwgc2lnbmlmaWNhbnQgY2hhbmdlcyBhbmQgZGVjaXNpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Vc2UgdmVyc2lvbiBjb250cm9sIGJlc3QgcHJhY3RpY2VzOiBmcmVxdWVudCBjb21taXRzLCBjbGVhciBtZXNzYWdlcywgYW5kIGZlYXR1cmUgYnJhbmNoZXMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkFzayBxdWVzdGlvbnMgZWFybHkgdG8gcmVzb2x2ZSB1bmNlcnRhaW50eSBhbmQgY29tbXVuaWNhdGUgYmxvY2tlcnMgcHJvbXB0bHkuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbGxhYm9yYXRlIHdpdGggb3RoZXIgYWdlbnRzIGFuZCBzdGFrZWhvbGRlcnMgZm9yIHF1YWxpdHkgYW5kIGludGVncmF0aW9uLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPFVzZXM+dmVyc2lvbl9jb250cm9sIChnaXQpPC9Vc2VzPgogICAgPFVzZXM+dGVzdF9yZXN1bHRzPC9Vc2VzPgogICAgPFVzZXM+Y29kZV9yZXZpZXdfZmVlZGJhY2s8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIGRldmVsb3BtZW50IHByb2dyZXNzLCB0YXNrIGJyZWFrZG93bnMsIGFuZCBjb2RlIHJldmlldyBmZWVkYmFjayBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcyBhbmQgdmVyc2lvbiBjb250cm9sLiBFYWNoIHRhc2sncyBzdGF0dXMsIG5vdGVzLCBhbmQgcmVsYXRlZCBkb2N1bWVudGF0aW9uIGFyZSB1cGRhdGVkIGFzIHdvcmsgcHJvY2VlZHMuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/style.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA1PC9JZD4KICAgIDxSb2xlPmNvZGVfc3R5bGVfdmVyaWZpY2F0aW9uPC9Sb2xlPgogICAgPFRyaWdnZXJzPmNvZGVfaW1wbGVtZW50YXRpb24sIGNvZGVfY2hhbmdlczwvVHJpZ2dlcnM+CiAgICA8UHJvZHVjZXM+c3R5bGVfcmVwb3J0cywgbGludGluZ19maXhlczwvUHJvZHVjZXM+CiAgICA8Q29uc3VtZXM+aW1wbGVtZW50YXRpb25fY29kZSwgLmN0eC5wcm9ncmVzcy54bWwsIC5jdHgudGFza3MueG1sPC9Db25zdW1lcz4KICA8L01ldGFkYXRhPgogIDxPYmplY3RpdmU+CiAgICBFbnN1cmUgdGhlIGNvZGViYXNlIGFkaGVyZXMgdG8gY29uc2lzdGVudCBjb2Rpbmcgc3RhbmRhcmRzIGFuZCBiZXN0IHByYWN0aWNlcyB1c2luZyBydWZmIGFuZCBteXB5LiBUcmFjayBzdHlsZSBpc3N1ZXMgYW5kIGxpbnRpbmcgZml4ZXMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHN0eWxlIHZlcmlmaWNhdGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBjb2RlIGNoYW5nZToKICAgICAgPFN1YnN0ZXA+UnVuIHJ1ZmYgYW5kIG15cHkgdG8gY2hlY2sgZm9yIGxpbnRpbmcgZXJyb3JzIGFuZCBzdHlsZSB2aW9sYXRpb25zLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RG9jdW1lbnQgYW55IGlzc3VlcyBmb3VuZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gd2l0aCBjbGVhciBkZXNjcmlwdGlvbnMgYW5kIHN1Z2dlc3RlZCBmaXhlcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCB0aGUgc3RhdHVzIG9mIHN0eWxlIHZlcmlmaWNhdGlvbi48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIHN0eWxlIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBwcmV2ZW50aW9uLjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5NYWludGFpbiBjb25zaXN0ZW50IGNvZGUgc3R5bGUgYW5kIGZvcm1hdHRpbmcgYWNyb3NzIHRoZSBjb2RlYmFzZS48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHN0eWxlIGlzc3VlcyBhbmQgZml4ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHN0eWxlIHZlcmlmaWNhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgc3R5bGUgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgc3R5bGUgaXNzdWVzLCBsaW50aW5nIGZpeGVzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHN0eWxlIHZlcmlmaWNhdGlvbiBwcm9jZWVkcy48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/debug.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDEyPC9JZD4KICAgIDxSb2xlPmRlYnVnZ2luZ19hbmRfaXNzdWVfZGlhZ25vc2lzPC9Sb2xlPgogICAgPFRyaWdnZXJzPnRlc3RfZmFpbHVyZXMsIHJ1bnRpbWVfZXJyb3JzLCBidWdfcmVwb3J0cywgcGVyZm9ybWFuY2VfaXNzdWVzPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5kZWJ1Z19yZXBvcnRzLCBmaXhfcmVjb21tZW5kYXRpb25zLCByZWdyZXNzaW9uX3Rlc3RzPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCB0ZXN0X3Jlc3VsdHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgSWRlbnRpZnksIGRpYWdub3NlLCBhbmQgcmVzb2x2ZSBpc3N1ZXMgaW4gdGhlIGNvZGViYXNlLCBpbmNsdWRpbmcgdGVzdCBmYWlsdXJlcywgcnVudGltZSBlcnJvcnMsIGxvZ2ljYWwgYnVncywgYW5kIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLiBEb2N1bWVudCBhbGwgZXJyb3JzLCBkaWFnbm9zdGljIHN0ZXBzLCBhbmQgc29sdXRpb25zIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LiBFbnN1cmUgZml4ZXMgYXJlIHZhbGlkYXRlZCBhbmQgZG8gbm90IGludHJvZHVjZSByZWdyZXNzaW9ucy4KICA8L09iamVjdGl2ZT4KICA8V29ya2Zsb3c+CiAgICA8U3RlcD5Nb25pdG9yIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+IGZvciBuZXcgb3Igb25nb2luZyBlcnJvcnMsIGJ1Z3MsIG9yIHRlc3QgZmFpbHVyZXMuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggaXNzdWU6CiAgICAgIDxTdWJzdGVwPlJlcHJvZHVjZSB0aGUgaXNzdWUgYW5kIGRvY3VtZW50IHJlcHJvZHVjdGlvbiBzdGVwcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Jc29sYXRlIHRoZSByb290IGNhdXNlIGFuZCByZWNvcmQgYWxsIGRpYWdub3N0aWMgc3RlcHMgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+Rm9ybXVsYXRlIGh5cG90aGVzZXMgYW5kIHRlc3QgcG90ZW50aWFsIGZpeGVzLCB0cmFja2luZyBlYWNoIGF0dGVtcHQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+V2hlbiBhIGZpeCBpcyBmb3VuZCwgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byBtYXJrIHRoZSBpc3N1ZSBhcyByZXNvbHZlZCBhbmQgc3VtbWFyaXplIHRoZSBzb2x1dGlvbi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGxlc3NvbnMgbGVhcm5lZCwgbmV3IHRlc3RzLCBvciByZWdyZXNzaW9uIGNoZWNrcyBhZGRlZCB0byBwcmV2ZW50IHJlY3VycmVuY2UuPC9TdWJzdGVwPgogICAgPC9TdGVwPgogICAgPFN0ZXA+Rm9yIHJlY3VycmluZyBvciBzeXN0ZW1pYyBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucywgcm9vdCBjYXVzZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBwcmV2ZW50aW9uLjwvU3RlcD4KICAgIDxTdGVwPkNvbW11bmljYXRlIGJsb2NrZXJzLCB1bnJlc29sdmVkIGlzc3Vlcywgb3IgcmVxdWlyZWQgZXNjYWxhdGlvbnMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGZvciB0ZWFtIHZpc2liaWxpdHkgYW5kIGZvbGxvdy11cC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+VHJhY2UgaXNzdWVzIHRvIHRoZWlyIHJvb3QgY2F1c2UsIG5vdCBqdXN0IHN5bXB0b21zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Eb2N1bWVudCBhbGwgZGlhZ25vc3RpYyBzdGVwcywgYXR0ZW1wdGVkIHNvbHV0aW9ucywgYW5kIG91dGNvbWVzIGluIC5jdHgudGFza3MueG1sLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5VcGRhdGUgLmN0eC5wcm9ncmVzcy54bWwgd2l0aCBlcnJvciBzdGF0dXMsIHJlc29sdXRpb24gbm90ZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkVuc3VyZSBmaXhlcyBkbyBub3QgaW50cm9kdWNlIHJlZ3Jlc3Npb25zOyBhZGQgb3IgdXBkYXRlIHRlc3RzIGFzIG5lZWRlZC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgYmxvY2tlcnMgb3IgdW5yZXNvbHZlZCBpc3N1ZXMgcHJvbXB0bHkgZm9yIHRlYW0gYXdhcmVuZXNzLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Qcm9tb3RlIGtub3dsZWRnZSBzaGFyaW5nIGJ5IGRvY3VtZW50aW5nIGxlc3NvbnMgbGVhcm5lZCBhbmQgcGF0dGVybnMgb2JzZXJ2ZWQuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8VXNlcz50ZXN0X3Jlc3VsdHM8L1VzZXM+CiAgICA8VXNlcz5yZWdyZXNzaW9uX3Rlc3RzPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBlcnJvcnMsIGRpYWdub3N0aWMgc3RlcHMsIGF0dGVtcHRlZCBzb2x1dGlvbnMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgaXNzdWVzIGFyZSByZXNvbHZlZCBvciByZXF1aXJlIGVzY2FsYXRpb24uPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/orchestration.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAxPC9JZD4KICAgIDxSb2xlPm9yY2hlc3RyYXRpb248L1JvbGU+CiAgICA8VHJpZ2dlcnM+cHJvamVjdF9zdGFydCwgcGVyZm9ybWFuY2VfdmVyaWZpZWQ8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPndvcmtmbG93X3N0YXR1cywgYWdlbnRfYXNzaWdubWVudHM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPkFsbCBhZ2VudCBvdXRwdXRzLCAuY3R4LnByb2dyZXNzLnhtbCwgLmN0eC50YXNrcy54bWw8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIE9yY2hlc3RyYXRlIHRoZSBkZXZlbG9wbWVudCB3b3JrZmxvdyBhbmQgbWFuYWdlIGFnZW50IGFzc2lnbm1lbnRzLiBNb25pdG9yIGFuZCB1cGRhdGUgb3JjaGVzdHJhdGlvbiB0YXNrcyBpbiA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gYW5kIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi4KICA8L09iamVjdGl2ZT4KICA8V29ya2Zsb3c+CiAgICA8U3RlcD5Nb25pdG9yIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBmb3IgcHJvamVjdCBtaWxlc3RvbmVzIGFuZCBhZ2VudCBhc3NpZ25tZW50cy48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBtaWxlc3RvbmU6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgcHJvamVjdCBzdGF0dXMgYW5kIGlkZW50aWZ5IG5lY2Vzc2FyeSBhZ2VudCBhc3NpZ25tZW50cy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBvcmNoZXN0cmF0aW9uIHRhc2tzIG9yIHVwZGF0ZXMgbmVlZGVkIGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCB0aGUgc3RhdHVzIG9mIG9yY2hlc3RyYXRpb24gdGFza3MuPC9TdWJzdGVwPgogICAgPC9TdGVwPgogICAgPFN0ZXA+Rm9yIHJlY3VycmluZyBvcmNoZXN0cmF0aW9uIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIHNtb290aCBjb29yZGluYXRpb24gYmV0d2VlbiBhZ2VudHMgYW5kIHByb2plY3QgbWlsZXN0b25lcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIG9yY2hlc3RyYXRpb24gdGFza3MgYW5kIGFzc2lnbm1lbnRzIGluIC5jdHgudGFza3MueG1sLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5VcGRhdGUgLmN0eC5wcm9ncmVzcy54bWwgd2l0aCBvcmNoZXN0cmF0aW9uIHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Db21tdW5pY2F0ZSBvcmNoZXN0cmF0aW9uIGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy54bWwgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIG9yY2hlc3RyYXRpb24gdGFza3MsIGFzc2lnbm1lbnRzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIG9yY2hlc3RyYXRpb24gdGFza3MgYXJlIGNvbXBsZXRlZC48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/dependency.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDEzPC9JZD4KICAgIDxSb2xlPmRlcGVuZGVuY3lfbWFuYWdlbWVudDwvUm9sZT4KICAgIDxUcmlnZ2Vycz5jb2RlX2ltcGxlbWVudGF0aW9uLCBkZXBlbmRlbmN5X2NoZWNrPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5kZXBlbmRlbmN5X3JlcG9ydHMsIHVwZGF0ZXM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmNvZGUsIHJlcXVpcmVtZW50cywgLmN0eC5wcm9ncmVzcy54bWwsIC5jdHgudGFza3MueG1sPC9Db25zdW1lcz4KICA8L01ldGFkYXRhPgogIDxPYmplY3RpdmU+CiAgICBNYW5hZ2UgYW5kIHVwZGF0ZSBwcm9qZWN0IGRlcGVuZGVuY2llcy4gTW9uaXRvciBhbmQgdXBkYXRlIGRlcGVuZGVuY3kgdGFza3MgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGltcGxlbWVudGF0aW9ucyByZXF1aXJpbmcgZGVwZW5kZW5jeSBjaGVja3MuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgY29kZSBhbmQgaWRlbnRpZnkgYW55IG5ldyBkZXBlbmRlbmNpZXMgb3IgdXBkYXRlcyBuZWVkZWQuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Eb2N1bWVudCBhbnkgZGVwZW5kZW5jeSBpc3N1ZXMgb3IgdXBkYXRlcyBuZWVkZWQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgZGVwZW5kZW5jeSB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIGRlcGVuZGVuY3kgaXNzdWVzLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIGltcHJvdmVtZW50LjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5FbnN1cmUgYWxsIGRlcGVuZGVuY2llcyBhcmUgdXAtdG8tZGF0ZSBhbmQgY29tcGF0aWJsZS48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIGRlcGVuZGVuY3kgdGFza3MgYW5kIHVwZGF0ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIGRlcGVuZGVuY3kgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbW11bmljYXRlIGRlcGVuZGVuY3kgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgZGVwZW5kZW5jeSB0YXNrcywgdXBkYXRlcywgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcy4gUHJvZ3Jlc3MgaXMgdXBkYXRlZCBhcyBkZXBlbmRlbmN5IHRhc2tzIGFyZSBjb21wbGV0ZWQuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/debugging.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAzPC9JZD4KICAgIDxSb2xlPmlzc3VlX2RpYWdub3NpczwvUm9sZT4KICAgIDxUcmlnZ2Vycz50ZXN0X2ZhaWx1cmVzPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5kZWJ1Z19yZXBvcnRzLCBmaXhfcmVjb21tZW5kYXRpb25zPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCB0ZXN0X3Jlc3VsdHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgSWRlbnRpZnksIGRpYWdub3NlLCBhbmQgcmVzb2x2ZSBpc3N1ZXMgaW4gdGhlIGNvZGViYXNlLCBmb2N1c2luZyBvbiBydW50aW1lIGVycm9ycywgbG9naWNhbCBidWdzLCBhbmQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuIERvY3VtZW50IGFsbCBlcnJvcnMgYW5kIGF0dGVtcHRlZCBzb2x1dGlvbnMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBvciBvbmdvaW5nIGVycm9ycyBhbmQgYnVncy48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBlcnJvciBvciBidWc6CiAgICAgIDxTdWJzdGVwPlJlcHJvZHVjZSB0aGUgaXNzdWUgYW5kIGRvY3VtZW50IHJlcHJvZHVjdGlvbiBzdGVwcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Jc29sYXRlIHRoZSBwcm9ibGVtIGFuZCByZWNvcmQgZGlhZ25vc3RpYyBzdGVwcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Gb3JtdWxhdGUgaHlwb3RoZXNlcyBhbmQgdGVzdCBwb3RlbnRpYWwgZml4ZXMsIHRyYWNraW5nIGVhY2ggYXR0ZW1wdCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5XaGVuIGEgZml4IGlzIGZvdW5kLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIG1hcmsgdGhlIGVycm9yIGFzIHJlc29sdmVkIGFuZCBzdW1tYXJpemUgdGhlIHNvbHV0aW9uLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RG9jdW1lbnQgbGVzc29ucyBsZWFybmVkIGFuZCBhbnkgbmV3IHRlc3RzIG9yIHJlZ3Jlc3Npb24gY2hlY2tzIGFkZGVkLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPkZvciByZWN1cnJpbmcgb3Igc3lzdGVtaWMgaXNzdWVzLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIHByZXZlbnRpb24uPC9TdGVwPgogIDwvV29ya2Zsb3c+CiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPlRyYWNlIGlzc3VlcyB0byB0aGVpciByb290IGNhdXNlLCBub3QganVzdCBzeW1wdG9tcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RG9jdW1lbnQgYWxsIGRpYWdub3N0aWMgc3RlcHMgYW5kIGF0dGVtcHRlZCBzb2x1dGlvbnMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIGVycm9yIHN0YXR1cyBhbmQgcmVzb2x1dGlvbiBub3Rlcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGZpeGVzIGRvIG5vdCBpbnRyb2R1Y2UgcmVncmVzc2lvbnM7IGFkZCBvciB1cGRhdGUgdGVzdHMgYXMgbmVlZGVkLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Db21tdW5pY2F0ZSBibG9ja2VycyBvciB1bnJlc29sdmVkIGlzc3VlcyBpbiAuY3R4LnByb2dyZXNzLnhtbCBmb3IgdGVhbSB2aXNpYmlsaXR5LjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBlcnJvcnMsIGRpYWdub3N0aWMgc3RlcHMsIGFuZCBhdHRlbXB0ZWQgc29sdXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIGlzc3VlcyBhcmUgcmVzb2x2ZWQgb3IgcmVxdWlyZSBlc2NhbGF0aW9uLjwvRGVzY3JpcHRpb24+CiAgPC9UcmFja2luZz4KPC9BZ2VudFByb3RvY29sPiA='
    embedded['.erasmus/templates/protocols/product_owner.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAyPC9JZD4KICAgIDxSb2xlPnByb2R1Y3Rfb3duZXI8L1JvbGU+CiAgICA8VHJpZ2dlcnM+cHJvamVjdF9pbml0aWF0aW9uPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz4uY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz51c2VyX3JlcXVlc3QubWQ8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIERlZmluZSBhbmQgbWFuYWdlIHByb2R1Y3QgcmVxdWlyZW1lbnRzIGFuZCByb2FkbWFwLiBNb25pdG9yIGFuZCB1cGRhdGUgcHJvZHVjdCB0YXNrcyBpbiA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gYW5kIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi4KICA8L09iamVjdGl2ZT4KICA8V29ya2Zsb3c+CiAgICA8U3RlcD5Nb25pdG9yIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBmb3IgcHJvZHVjdCByZXF1aXJlbWVudHMgYW5kIHJvYWRtYXAgdXBkYXRlcy48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCByZXF1aXJlbWVudDoKICAgICAgPFN1YnN0ZXA+UmV2aWV3IHRoZSBwcm9kdWN0IHN0YXR1cyBhbmQgaWRlbnRpZnkgbmVjZXNzYXJ5IHVwZGF0ZXMuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Eb2N1bWVudCBhbnkgcHJvZHVjdCB0YXNrcyBvciB1cGRhdGVzIG5lZWRlZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBwcm9kdWN0IHRhc2tzLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPkZvciByZWN1cnJpbmcgcHJvZHVjdCBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgaW1wcm92ZW1lbnQuPC9TdGVwPgogIDwvV29ya2Zsb3c+CiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPkVuc3VyZSBjbGVhciBhbmQgYWN0aW9uYWJsZSBwcm9kdWN0IHJlcXVpcmVtZW50cy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHByb2R1Y3QgdGFza3MgYW5kIHVwZGF0ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHByb2R1Y3Qgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbW11bmljYXRlIHByb2R1Y3QgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgcHJvZHVjdCB0YXNrcywgdXBkYXRlcywgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcy4gUHJvZ3Jlc3MgaXMgdXBkYXRlZCBhcyBwcm9kdWN0IHRhc2tzIGFyZSBjb21wbGV0ZWQuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/security.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA4PC9JZD4KICAgIDxSb2xlPnNlY3VyaXR5X3ZlcmlmaWNhdGlvbjwvUm9sZT4KICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPnNlY3VyaXR5X3JlcG9ydHMsIHZ1bG5lcmFiaWxpdHlfZml4ZXM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgSWRlbnRpZnkgYW5kIG1pdGlnYXRlIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcyBpbiB0aGUgY29kZWJhc2UuIFRyYWNrIHNlY3VyaXR5IGlzc3VlcyBhbmQgZml4ZXMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHNlY3VyaXR5IHZlcmlmaWNhdGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBjb2RlIGNoYW5nZToKICAgICAgPFN1YnN0ZXA+UnVuIHNlY3VyaXR5IHNjYW5zIHRvIGlkZW50aWZ5IHZ1bG5lcmFiaWxpdGllcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBpc3N1ZXMgZm91bmQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+IHdpdGggY2xlYXIgZGVzY3JpcHRpb25zIGFuZCBzdWdnZXN0ZWQgZml4ZXMuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBzZWN1cml0eSB2ZXJpZmljYXRpb24uPC9TdWJzdGVwPgogICAgPC9TdGVwPgogICAgPFN0ZXA+Rm9yIHJlY3VycmluZyBzZWN1cml0eSBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgcHJldmVudGlvbi48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgaXMgZnJlZSBmcm9tIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHNlY3VyaXR5IGlzc3VlcyBhbmQgZml4ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHNlY3VyaXR5IHZlcmlmaWNhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgc2VjdXJpdHkgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgc2VjdXJpdHkgaXNzdWVzLCB2dWxuZXJhYmlsaXR5IGZpeGVzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHNlY3VyaXR5IHZlcmlmaWNhdGlvbiBwcm9jZWVkcy48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g'
    embedded['.erasmus/templates/protocols/performance.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDExPC9JZD4KICAgIDxSb2xlPnBlcmZvcm1hbmNlX29wdGltaXphdGlvbjwvUm9sZT4KICAgIDxUcmlnZ2Vycz5kZXBsb3ltZW50X3JlYWR5PC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5wZXJmb3JtYW5jZV9yZXBvcnRzLCBvcHRpbWl6YXRpb25fcmVjb21tZW5kYXRpb25zPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5idWlsZF9hcnRpZmFjdHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgT3B0aW1pemUgY29kZSBwZXJmb3JtYW5jZSBhbmQgdHJhY2sgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzLiBNb25pdG9yIGFuZCB1cGRhdGUgcGVyZm9ybWFuY2UgdGFza3MgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBjb2RlIGNoYW5nZToKICAgICAgPFN1YnN0ZXA+UmV2aWV3IHRoZSBjb2RlIGFuZCBpZGVudGlmeSBhcmVhcyBuZWVkaW5nIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBwZXJmb3JtYW5jZSBpc3N1ZXMgb3IgaW1wcm92ZW1lbnRzIG5lZWRlZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBwZXJmb3JtYW5jZSB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIHBlcmZvcm1hbmNlIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZSB3aXRoIHByb3BlciBwcm9maWxpbmcgYW5kIGJlbmNobWFya2luZy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHBlcmZvcm1hbmNlIHRhc2tzIGFuZCBpbXByb3ZlbWVudHMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHBlcmZvcm1hbmNlIHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Db21tdW5pY2F0ZSBwZXJmb3JtYW5jZSBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MueG1sIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBwZXJmb3JtYW5jZSB0YXNrcywgaW1wcm92ZW1lbnRzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHBlcmZvcm1hbmNlIHRhc2tzIGFyZSBjb21wbGV0ZWQuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=='
    embedded['.erasmus/templates/protocols/documentation.xml'] = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA5PC9JZD4KICAgIDxSb2xlPmRvY3VtZW50YXRpb25fbWFuYWdlbWVudDwvUm9sZT4KICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPnJlYWRtZSwgYXBpX2RvY3MsIGlubGluZV9jb21tZW50czwvUHJvZHVjZXM+CiAgICA8Q29uc3VtZXM+Y29kZSwgYXJjaGl0ZWN0dXJlLCB0ZXN0IGZpbGVzLCAuY3R4LnByb2dyZXNzLnhtbCwgLmN0eC50YXNrcy54bWw8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIENyZWF0ZSBhbmQgbWFpbnRhaW4gY29tcHJlaGVuc2l2ZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgY29kZWJhc2UuIFRyYWNrIGRvY3VtZW50YXRpb24gdGFza3MgYW5kIHByb2dyZXNzIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPk1vbml0b3IgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGZvciBuZXcgY29kZSBjaGFuZ2VzIHJlcXVpcmluZyBkb2N1bWVudGF0aW9uLjwvU3RlcD4KICAgIDxTdGVwPkZvciBlYWNoIGNvZGUgY2hhbmdlOgogICAgICA8U3Vic3RlcD5SZXZpZXcgdGhlIGNvZGUgYW5kIGlkZW50aWZ5IGFyZWFzIG5lZWRpbmcgZG9jdW1lbnRhdGlvbi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBnYXBzIG9yIGltcHJvdmVtZW50cyBuZWVkZWQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgZG9jdW1lbnRhdGlvbiB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIGRvY3VtZW50YXRpb24gaXNzdWVzLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIGltcHJvdmVtZW50LjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5FbnN1cmUgY29kZSBpcyB3ZWxsLWRvY3VtZW50ZWQgd2l0aCBjbGVhciBhbmQgY29uY2lzZSBjb21tZW50cy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIGRvY3VtZW50YXRpb24gdGFza3MgYW5kIGltcHJvdmVtZW50cyBpbiAuY3R4LnRhc2tzLnhtbC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VXBkYXRlIC5jdHgucHJvZ3Jlc3MueG1sIHdpdGggZG9jdW1lbnRhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgZG9jdW1lbnRhdGlvbiBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MueG1sIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBkb2N1bWVudGF0aW9uIHRhc2tzLCBpbXByb3ZlbWVudHMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgZG9jdW1lbnRhdGlvbiB0YXNrcyBhcmUgY29tcGxldGVkLjwvRGVzY3JpcHRpb24+CiAgPC9UcmFja2luZz4KPC9BZ2VudFByb3RvY29sPiA='
    embedded['.erasmus/templates/protocol.xml'] = 'PFByb3RvY29sIG5hbWU9IlByb3RvY29sIE5hbWUiPgogIDxEZXNjcmlwdGlvbj5Qcm90b2NvbCBkZXNjcmlwdGlvbjwvRGVzY3JpcHRpb24+CiAgCiAgPFRyaWdnZXJzPgogICAgPFRyaWdnZXI+VHJpZ2dlciAxPC9UcmlnZ2VyPgogICAgPFRyaWdnZXI+VHJpZ2dlciAyPC9UcmlnZ2VyPgogICAgPCEtLSBBZGQgbW9yZSB0cmlnZ2VycyBhcyBuZWVkZWQgLS0+CiAgPC9UcmlnZ2Vycz4KICAKICA8UHJvZHVjZXM+CiAgICA8T3V0cHV0Pk91dHB1dCAxPC9PdXRwdXQ+CiAgICA8T3V0cHV0Pk91dHB1dCAyPC9PdXRwdXQ+CiAgICA8IS0tIEFkZCBtb3JlIG91dHB1dHMgYXMgbmVlZGVkIC0tPgogIDwvUHJvZHVjZXM+CiAgCiAgPENvbnN1bWVzPgogICAgPElucHV0PklucHV0IDE8L0lucHV0PgogICAgPElucHV0PklucHV0IDI8L0lucHV0PgogICAgPCEtLSBBZGQgbW9yZSBpbnB1dHMgYXMgbmVlZGVkIC0tPgogIDwvQ29uc3VtZXM+CiAgCiAgPFdvcmtmbG93PgogICAgPFN0ZXAgbmFtZT0iU3RlcCBOYW1lIj4KICAgICAgPERlc2NyaXB0aW9uPlN0ZXAgZGVzY3JpcHRpb248L0Rlc2NyaXB0aW9uPgogICAgICA8QWN0aW9ucz4KICAgICAgICA8QWN0aW9uPkFjdGlvbiAxPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5BY3Rpb24gMjwvQWN0aW9uPgogICAgICAgIDwhLS0gQWRkIG1vcmUgYWN0aW9ucyBhcyBuZWVkZWQgLS0+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIDwhLS0gQWRkIG1vcmUgc3RlcHMgYXMgbmVlZGVkIC0tPgogIDwvV29ya2Zsb3c+CiAgCiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlIG5hbWU9IlByaW5jaXBsZSBOYW1lIj4KICAgICAgPERlc2NyaXB0aW9uPlByaW5jaXBsZSBkZXNjcmlwdGlvbjwvRGVzY3JpcHRpb24+CiAgICA8L1ByaW5jaXBsZT4KICAgIDwhLS0gQWRkIG1vcmUgcHJpbmNpcGxlcyBhcyBuZWVkZWQgLS0+CiAgPC9QcmluY2lwbGVzPgogIAogIDxUcmFja2luZz4KICAgIDxNZXRyaWMgbmFtZT0iTWV0cmljIE5hbWUiPgogICAgICA8RGVzY3JpcHRpb24+TWV0cmljIGRlc2NyaXB0aW9uPC9EZXNjcmlwdGlvbj4KICAgIDwvTWV0cmljPgogICAgPCEtLSBBZGQgbW9yZSBtZXRyaWNzIGFzIG5lZWRlZCAtLT4KICA8L1RyYWNraW5nPgo8L1Byb3RvY29sPiA='
    embedded['.erasmus/templates/architecture.xml'] = 'PEFyY2hpdGVjdHVyZT4KICA8VGl0bGU+UHJvamVjdCBUaXRsZTwvVGl0bGU+CiAgPE92ZXJ2aWV3PgogICAgPERlc2NyaXB0aW9uPlByb2plY3QgZGVzY3JpcHRpb24gZ29lcyBoZXJlPC9EZXNjcmlwdGlvbj4KICA8L092ZXJ2aWV3PgogIAogIDxDb3JlQ29tcG9uZW50cz4KICAgIDxDb21wb25lbnQgbmFtZT0iQ29tcG9uZW50IE5hbWUiPgogICAgICA8UHVycG9zZT5Db21wb25lbnQgcHVycG9zZTwvUHVycG9zZT4KICAgICAgPFJlc3BvbnNpYmlsaXRpZXM+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlJlc3BvbnNpYmlsaXR5IDE8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDxSZXNwb25zaWJpbGl0eT5SZXNwb25zaWJpbGl0eSAyPC9SZXNwb25zaWJpbGl0eT4KICAgICAgICA8IS0tIEFkZCBtb3JlIHJlc3BvbnNpYmlsaXRpZXMgYXMgbmVlZGVkIC0tPgogICAgICA8L1Jlc3BvbnNpYmlsaXRpZXM+CiAgICAgIDxUZXN0Rm9jdXM+CiAgICAgICAgPFRlc3Q+VGVzdCBmb2N1cyAxPC9UZXN0PgogICAgICAgIDxUZXN0PlRlc3QgZm9jdXMgMjwvVGVzdD4KICAgICAgICA8IS0tIEFkZCBtb3JlIHRlc3QgZm9jdXNlcyBhcyBuZWVkZWQgLS0+CiAgICAgIDwvVGVzdEZvY3VzPgogICAgPC9Db21wb25lbnQ+CiAgICA8IS0tIEFkZCBtb3JlIGNvbXBvbmVudHMgYXMgbmVlZGVkIC0tPgogIDwvQ29yZUNvbXBvbmVudHM+CiAgCiAgPERldmVsb3BtZW50UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGUgbmFtZT0iUHJpbmNpcGxlIE5hbWUiPgogICAgICA8RGV0YWlsPlByaW5jaXBsZSBkZXRhaWwgMTwvRGV0YWlsPgogICAgICA8RGV0YWlsPlByaW5jaXBsZSBkZXRhaWwgMjwvRGV0YWlsPgogICAgICA8IS0tIEFkZCBtb3JlIGRldGFpbHMgYXMgbmVlZGVkIC0tPgogICAgPC9QcmluY2lwbGU+CiAgICA8IS0tIEFkZCBtb3JlIHByaW5jaXBsZXMgYXMgbmVlZGVkIC0tPgogIDwvRGV2ZWxvcG1lbnRQcmluY2lwbGVzPgogIAogIDxEZXBlbmRlbmNpZXM+CiAgICA8RGVwZW5kZW5jeT5EZXBlbmRlbmN5IDE8L0RlcGVuZGVuY3k+CiAgICA8RGVwZW5kZW5jeT5EZXBlbmRlbmN5IDI8L0RlcGVuZGVuY3k+CiAgICA8IS0tIEFkZCBtb3JlIGRlcGVuZGVuY2llcyBhcyBuZWVkZWQgLS0+CiAgPC9EZXBlbmRlbmNpZXM+CiAgCiAgPERpcmVjdG9yeVN0cnVjdHVyZT4KICAgIDwhLS0gQWRkIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgaGVyZSAtLT4KICA8L0RpcmVjdG9yeVN0cnVjdHVyZT4KICAKICA8RGV2ZWxvcG1lbnRXb3JrZmxvdz4KICAgIDxTdGVwPldvcmtmbG93IHN0ZXAgMTwvU3RlcD4KICAgIDxTdGVwPldvcmtmbG93IHN0ZXAgMjwvU3RlcD4KICAgIDwhLS0gQWRkIG1vcmUgc3RlcHMgYXMgbmVlZGVkIC0tPgogIDwvRGV2ZWxvcG1lbnRXb3JrZmxvdz4KPC9BcmNoaXRlY3R1cmU+Cg=='
    embedded['.erasmus/templates/README.md'] = 'IyBFcmFzbXVzIFhNTCBUZW1wbGF0ZXMKClRoaXMgZGlyZWN0b3J5IGNvbnRhaW5zIFhNTCB0ZW1wbGF0ZXMgZm9yIHRoZSBFcmFzbXVzIGNvbnRleHQgbWFuYWdlbWVudCBzeXN0ZW0uIFRoZXNlIHRlbXBsYXRlcyBwcm92aWRlIGEgc3RydWN0dXJlZCBmb3JtYXQgZm9yIG9yZ2FuaXppbmcgcHJvamVjdCBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGJ5IEFJIG1vZGVscyBmb3IgYmV0dGVyIGNvbnRleHQgdW5kZXJzdGFuZGluZy4KCiMjIFRlbXBsYXRlIFN0cnVjdHVyZQoKLSBgbWV0YV9hZ2VudC54bWxgOiBHbG9iYWwgcnVsZXMgdGhhdCBpbnN0cnVjdCB0aGUgbW9kZWwgb24gaG93IHRvIGZvbGxvdyB0aGUgd29ya2Zsb3cgdGhhdCBhbGxvd3MgaXQgdG8gdXNlIHRoaXMgY29udGV4dCBtYW5hZ2VyLCB0aGlzIGdldHMgc2F2ZWQgdG8gdGhlIGdsb2JhbCBydWxlcyBmaWxlIG9mIHlvdXIgSURFLgotIGBtZXRhX3J1bGVzLnhtbGA6IFRoZSBtYWluIHRlbXBsYXRlIHRoYXQgaW5jbHVkZXMgcGxhY2Vob2xkZXJzIGZvciBhbGwgb3RoZXIgdGVtcGxhdGVzIGFuZCBnZXRzIHNhdmVkIHRvIHRoZSBsb2NhbCBydWxlcyBmaWxlIG9mIHlvdXIgcHJvamVjdCBhbmQgdXBkYXRlZCBmcm9tIHRoZSBgLmN0eC5gIGZpbGVzLgotIGBhcmNoaXRlY3R1cmUueG1sYDogVGVtcGxhdGUgZm9yIHByb2plY3QgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb24sIHRoaXMgZ2V0cyBjb3BpZWQgdG8gYC5jdHguYXJjaGl0ZWN0dXJlLnhtbGAgYW5kIGlzIG1vbml0b3JlZCBieSBgZXJhc211cyB3YXRjaGAKLSBgcHJvZ3Jlc3MueG1sYDogVGVtcGxhdGUgZm9yIHRyYWNraW5nIHByb2plY3QgcHJvZ3Jlc3MsIHRoaXMgZ2V0cyBjb3BpZWQgdG8gYC5jdHgucHJvZ3Jlc3MueG1sYCBhbmQgaXMgbW9uaXRvcmVkIGJ5IGBlcmFzbXVzIHdhdGNoYAotIGB0YXNrcy54bWxgOiBUZW1wbGF0ZSBmb3IgbWFuYWdpbmcgY3VycmVudCB0YXNrcyBhbmQgbmV4dCBzdGVwcywgdGhpcyBnZXRzIGNvcGllZCB0byBgLmN0eC5wcm9ncmVzcy54bWxgIGFuZCBpcyBtb25pdG9yZWQgYnkgYGVyYXNtdXMgd2F0Y2hgCi0gYHByb3RvY29sLnhtbGA6IFRlbXBsYXRlIGZvciBkZWZpbmluZyBwcm90b2NvbHMsIGdlbmVyaWMgcHJvdG9jb2wgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyB0ZW1wbGF0ZS4KLSBgcHJvdG9jb2xzL1BST1RPQ09MLnhtbGA6IFByZWRlZmluZWQgcHJvdG9jb2xzIGZvciBkaWZmZXJlbnQgYXNwZWN0cyBvZiBjb2RlIGdlbmVyYXRpb24gYW5kIGxpYnJhcnkgbWFpbnRlbmNlLiBVc2UgdGhlc2UgdG8gaGVscCBhdWdtZW50IHRoZSBtb2RlbCBhbmQgaW1wcm92ZSB0aGVpciB0YXJnZXRlZCB0YXNrLgoKIyMgVGVtcGxhdGUgRm9ybWF0CgpFYWNoIHRlbXBsYXRlIGZvbGxvd3MgYSBjb25zaXN0ZW50IFhNTCBzdHJ1Y3R1cmUgd2l0aDoKCi0gQ2xlYXIgaGllcmFyY2hpY2FsIG9yZ2FuaXphdGlvbgotIERlc2NyaXB0aXZlIGVsZW1lbnQgbmFtZXMKLSBDb21tZW50cyBmb3IgZ3VpZGFuY2UKLSBQbGFjZWhvbGRlcnMgZm9yIGNvbnRlbnQKCiMjIEV4YW1wbGUgVXNhZ2UKCmBgYHhtbAo8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCI/Pgo8TWV0YVJ1bGVzPgogIDwhLS1BUkNISVRFQ1RVUkUtLT4KICA8QXJjaGl0ZWN0dXJlPgogICAgPCEtLSBDb250ZW50IGZyb20gYXJjaGl0ZWN0dXJlLnhtbCAtLT4KICA8L0FyY2hpdGVjdHVyZT4KICA8IS0tL0FSQ0hJVEVDVFVSRS0tPgoKICA8IS0tUFJPR1JFU1MtLT4KICA8UHJvZ3Jlc3M+CiAgICA8IS0tIENvbnRlbnQgZnJvbSBwcm9ncmVzcy54bWwgLS0+CiAgPC9Qcm9ncmVzcz4KICA8IS0tL1BST0dSRVNTLS0+CgogIDwhLS1UQVNLUy0tPgogIDxUYXNrcz4KICAgIDwhLS0gQ29udGVudCBmcm9tIHRhc2tzLnhtbCAtLT4KICA8L1Rhc2tzPgogIDwhLS0vVEFTS1MtLT4KCiAgPCEtLVBST1RPQ09MLS0+CiAgPFByb3RvY29sPgogICAgPCEtLSBDb250ZW50IGZyb20gcHJvdG9jb2wueG1sIC0tPgogIDwvUHJvdG9jb2w+CiAgPCEtLS9QUk9UT0NPTC0tPgo8L01ldGFSdWxlcz4KYGBgCg=='
    embedded['.erasmus/templates/tasks.xml'] = 'PFRhc2tzPgogIDxDdXJyZW50VGFza3M+CiAgICA8VGFzayBuYW1lPSJUYXNrIE5hbWUiPgogICAgICA8RGVzY3JpcHRpb24+VGFzayBkZXNjcmlwdGlvbjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdWJ0YXNrcz4KICAgICAgICA8U3VidGFzayBuYW1lPSJTdWJ0YXNrIE5hbWUiPgogICAgICAgICAgPFN0YXR1cz5TdGF0dXMgKGUuZy4sIFBlbmRpbmcsIEluIFByb2dyZXNzLCBDb21wbGV0ZWQpPC9TdGF0dXM+CiAgICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9Ik5lc3RlZCBTdWJ0YXNrIE5hbWUiPgogICAgICAgICAgICAgIDxTdGF0dXM+U3RhdHVzPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgICAgPCEtLSBBZGQgbW9yZSBuZXN0ZWQgc3VidGFza3MgYXMgbmVlZGVkIC0tPgogICAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPCEtLSBBZGQgbW9yZSBzdWJ0YXNrcyBhcyBuZWVkZWQgLS0+CiAgICAgIDwvU3VidGFza3M+CiAgICAgIDxUZXN0cz4KICAgICAgICA8VGVzdCBuYW1lPSJUZXN0IE5hbWUiPgogICAgICAgICAgPENvZGU+CiAgICAgICAgICAgIDwhW0NEQVRBWwogICAgICAgICAgICBkZWYgdGVzdF9mdW5jdGlvbigpOgogICAgICAgICAgICAgICAgIyBUZXN0IGNvZGUgZ29lcyBoZXJlCiAgICAgICAgICAgIF1dPgogICAgICAgICAgPC9Db2RlPgogICAgICAgIDwvVGVzdD4KICAgICAgICA8IS0tIEFkZCBtb3JlIHRlc3RzIGFzIG5lZWRlZCAtLT4KICAgICAgPC9UZXN0cz4KICAgIDwvVGFzaz4KICAgIDwhLS0gQWRkIG1vcmUgY3VycmVudCB0YXNrcyBhcyBuZWVkZWQgLS0+CiAgPC9DdXJyZW50VGFza3M+CiAgCiAgPE5leHRTdGVwcz4KICAgIDxTdGVwPk5leHQgc3RlcCAxPC9TdGVwPgogICAgPFN0ZXA+TmV4dCBzdGVwIDI8L1N0ZXA+CiAgICA8IS0tIEFkZCBtb3JlIG5leHQgc3RlcHMgYXMgbmVlZGVkIC0tPgogIDwvTmV4dFN0ZXBzPgo8L1Rhc2tzPiA='
    embedded['.erasmus/current_protocol.txt'] = 'ZG9jdW1lbnRhdGlvbg=='
    embedded['.erasmus/protocol/.gitkeep'] = ''
    embedded['.erasmus/context/.gitkeep'] = ''
    if not os.path.exists(".erasmus"):
        for rel_path, base64_data in embedded.items():
            out_path = os.path.join(os.getcwd(), rel_path)
            os.makedirs(os.path.dirname(out_path), exist_ok=True)
            with open(out_path, "wb") as file:
                file.write(base64.b64decode(base64_data))
    # else: do not overwrite

_extract_erasmus_embedded_files()

# logging.py
from loguru import logger


# paths.py
from pathlib import Path
from pydantic import BaseModel, Field, ConfigDict
from dotenv import load_dotenv
from enum import Enum
import os
from typing import NamedTuple

load_dotenv()


class IDEMetadata(NamedTuple):
    """Metadata for an IDE environment."""

    name: str
    rules_file: str
    global_rules_path: Path


class IDE(Enum):
    """IDE environment with associated metadata."""

    windsurf = IDEMetadata(
        name="windsurf",
        rules_file=".windsurfrules",
        global_rules_path=Path.home() / ".codeium" / "windsurf" / "memories" / "global_rules.md",
    )

    cursor = IDEMetadata(
        name="cursor",
        rules_file=".cursorrules",
        global_rules_path=Path.cwd() / ".cursor" / "global_rules.md",
    )

    codex = IDEMetadata(
        name="codex",
        # Local rules file for Codex IDE (prefixed with a dot)
        rules_file=".codex.md",
        global_rules_path=Path.home() / ".codex" / "instructions.md",
    )

    claude = IDEMetadata(
        name="claude",
        rules_file="CLAUDE.md",
        global_rules_path=Path.home() / ".claude" / "CLAUDE.md",
    )

    @property
    def metadata(self) -> IDEMetadata:
        """Get the metadata for this IDE."""
        return self.value

    @property
    def rules_file(self) -> str:
        """Get the rules file name for this IDE."""
        return self.metadata.rules_file

    @property
    def global_rules_path(self) -> Path:
        """Get the global rules path for this IDE."""
        return self.metadata.global_rules_path


def detect_ide_from_env() -> IDE | None:
    """
    Detect IDE from environment variables.
    Returns None if no IDE is detected.
    """
    ide_env = os.environ.get("IDE_ENV", "").lower()

    if not ide_env:
        return None

    # Check for IDE based on prefix
    if ide_env.startswith("w"):
        return IDE.windsurf
    elif ide_env.startswith("cu"):
        return IDE.cursor
    elif ide_env.startswith("co"):
        return IDE.codex
    elif ide_env.startswith("cl"):
        return IDE.claude

    return None


def prompt_for_ide() -> IDE:
    """
    Prompt the user to select an IDE.
    Returns the selected IDE.
    """
    print("No IDE environment detected. Please select an IDE:")
    print("1. Windsurf")
    print("2. Cursor")
    print("3. Codex")
    print("4. Claude")

    while True:
        try:
            choice = input("Enter your choice (1-4): ")
            if choice == "1":
                return IDE.windsurf
            elif choice == "2":
                return IDE.cursor
            elif choice == "3":
                return IDE.codex
            elif choice == "4":
                return IDE.claude
            else:
                print("Invalid choice. Please enter a number between 1 and 4.")
        except KeyboardInterrupt:
            print("\nOperation cancelled. Using default IDE (Cursor).")
            return IDE.cursor


def get_ide() -> IDE:
    """
    Get the IDE from environment variables or prompt the user.
    Returns the selected IDE.
    """
    ide = detect_ide_from_env()
    if ide is None:
        ide = prompt_for_ide()
        environment = Path.cwd() / ".env"
        if environment.exists():
            environment_content = environment.read_text()
            environment_content += f"\nIDE_ENV={ide.name}"
            environment.write_text(environment_content)
        else:
            environment.write_text(f"IDE_ENV={ide.name}")
    return ide


class PathMngrModel(BaseModel):
    """Manages paths for different IDE environments."""

    # Allow extra attributes for mocking and patching
    model_config = ConfigDict(extra="allow")

    ide: IDE | None = None
    # Directories
    root_dir: Path = Path.cwd()
    erasmus_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus")
    context_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "context")
    protocol_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "protocol")
    template_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "templates")

    # Files
    architecture_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.architecture.xml")
    progress_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.progress.xml")
    tasks_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.tasks.xml")
    rules_file: Path | None = None
    global_rules_file: Path | None = None

    # Templates
    architecture_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "architecture.xml"
    )
    progress_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "progress.xml"
    )
    tasks_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "tasks.xml"
    )
    protocol_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "protocol.xml"
    )
    meta_agent_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "meta_agent.xml"
    )
    meta_rules_template: Path = Field(
        default_factory=lambda: Path.cwd() / ".erasmus" / "templates" / "meta_rules.xml"
    )

    def __init__(self, **data):
        """Initialize the PathMngrModel with optional configuration data.

        Args:
            **data: Keyword arguments for configuring path management.
                    Supports IDE-specific and custom path configurations.
        """
        super().__init__(**data)
        # Initialize and time path setup
        self._setup_paths()

    def _setup_paths(self):
        """Set up and configure paths for the current development environment.

        This method handles:
        - Detecting the current IDE
        - Creating necessary directories
        - Setting up symlinks
        - Ensuring cross-platform path compatibility
        """
        """Set up paths based on the selected IDE."""
        if self.ide:
            # Set rules file based on IDE
            self.rules_file = self.root_dir / self.ide.rules_file
            self.global_rules_file = self.ide.global_rules_path

            # Create symlink for cursor if needed (special case for windsurf)
            if self.ide == IDE.windsurf:
                cursor_rules = self.root_dir / ".cursorrules"
                if self.rules_file.exists() and not cursor_rules.exists():
                    cursor_rules.symlink_to(self.rules_file)

    def get_ide_env(self) -> str | None:
        """Get the IDE environment name."""
        return self.ide.name if self.ide else None

    def get_context_dir(self) -> Path:
        """Get the context directory path."""
        return self.context_dir

    def get_protocol_dir(self) -> Path:
        """Get the protocol directory path."""
        return self.protocol_dir

    def get_architecture_file(self) -> Path:
        """Get the architecture file path."""
        return self.architecture_file

    def get_progress_file(self) -> Path:
        """Get the progress file path."""
        return self.progress_file

    def get_tasks_file(self) -> Path:
        """Get the tasks file path."""
        return self.tasks_file

    def get_rules_file(self) -> Path | None:
        """Get the rules file path."""
        return self.rules_file

    def get_global_rules_file(self) -> Path | None:
        """Get the global rules file path."""
        return self.global_rules_file

    def get_root_dir(self) -> Path:
        """Get the root directory path."""
        return self.root_dir

    def get_path(self, name: str) -> Path:
        """Get a path by name."""
        if hasattr(self, name):
            return getattr(self, name)
        raise ValueError(f"Path {name} not found")

    def set_path(self, name: str, path: Path) -> None:
        """Set a path by name."""
        if hasattr(self, name):
            setattr(self, name, path)
        else:
            raise ValueError(f"Path {name} not found")

    def ensure_dirs(self) -> None:
        """Ensure all directories exist."""
        self.context_dir.mkdir(parents=True, exist_ok=True)
        self.protocol_dir.mkdir(parents=True, exist_ok=True)
        self.erasmus_dir.mkdir(parents=True, exist_ok=True)
        self.template_dir.mkdir(parents=True, exist_ok=True)

    def ensure_files(self) -> None:
        """Ensure all files exist."""
        self.ensure_dirs()
        self.architecture_file.touch(exist_ok=True)
        self.progress_file.touch(exist_ok=True)
        self.tasks_file.touch(exist_ok=True)
        if self.rules_file:
            self.rules_file.touch(exist_ok=True)
        if self.global_rules_file:
            self.global_rules_file.touch(exist_ok=True)

    def setup_paths(self) -> None:
        """Set up all paths and ensure directories and files exist."""
        self._setup_paths()
        self.ensure_dirs()
        self.ensure_files()


# Singleton instance
_path_manager = None


def get_path_manager(ide: IDE | None = None) -> PathMngrModel:
    """Get the singleton path manager instance."""
    global _path_manager
    if _path_manager is None:
        # If no IDE is provided, try to detect it
        if ide is None:
            ide = get_ide()
        _path_manager = PathMngrModel(ide=ide)
    elif ide is not None and _path_manager.ide != ide:
        # Update the IDE if it's different
        _path_manager.ide = ide
        _path_manager._setup_paths()
    return _path_manager


# Legacy alias for backwards compatibility
PathManager = PathMngrModel

IDEMetadata = IDEMetadata
IDE = IDE
detect_ide_from_env = detect_ide_from_env
prompt_for_ide = prompt_for_ide
get_ide = get_ide
PathMngrModel = PathMngrModel
get_path_manager = get_path_manager

# sanatizer.py
import re
import xml.etree.ElementTree as ET
from typing import Any


def _sanitize_string(name: str) -> str:
    """Sanitize a string by removing emoji and non-ASCII characters while preserving valid markdown characters.
    Returns an ASCII-safe string suitable for filenames.
    """
    # First remove emoji using regex pattern
    no_emoji = re.sub(r"[\U0001F300-\U0001F9FF]", "", name)

    # Replace any non-alphanumeric character (including special characters like *) with underscore
    sanitized = re.sub(r"[^a-zA-Z0-9]", "_", no_emoji)

    # Collapse multiple underscores
    sanitized = re.sub(r"_+", "_", sanitized)

    # Ensure it starts with a letter
    if not sanitized or not sanitized[0].isalpha():
        sanitized = "p_" + sanitized

    # Strip trailing underscores
    sanitized = sanitized.rstrip("_")

    return sanitized


def _sanitize_xml_content(xml_content: str) -> str:
    """Sanitize XML content by ensuring it's well-formed and safe.

    Args:
        xml_content: The XML content to sanitize

    Returns:
        Sanitized XML content
    """
    # Replace invalid XML characters
    # XML 1.0 specification allows: #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
    # We'll replace control characters and other invalid characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", xml_content)

    # Replace invalid XML entities
    sanitized = re.sub(r"&(?!(amp|lt|gt|quot|apos|#\d+|#x[0-9a-fA-F]+);)", "&amp;", sanitized)

    # Ensure the XML is well-formed
    try:
        # Try to parse the XML to ensure it's well-formed
        ET.fromstring(sanitized)
        return sanitized
    except ET.ParseError:
        # If parsing fails, try to fix common issues
        # Add XML declaration if missing
        if not sanitized.strip().startswith("<?xml"):
            sanitized = '<?xml version="1.0" encoding="UTF-8"?>\n' + sanitized

        # Try to parse again
        try:
            ET.fromstring(sanitized)
            return sanitized
        except ET.ParseError:
            # If still failing, return a minimal valid XML
            return '<?xml version="1.0" encoding="UTF-8"?>\n<root></root>'


def _sanitize_xml_attribute(value: str) -> str:
    """Sanitize a string for use as an XML attribute value.

    Args:
        value: The attribute value to sanitize

    Returns:
        Sanitized attribute value
    """
    # Replace special XML characters with their entities
    sanitized = value.replace("&", "&amp;")
    sanitized = sanitized.replace("<", "&lt;")
    sanitized = sanitized.replace(">", "&gt;")
    sanitized = sanitized.replace('"', "&quot;")
    sanitized = sanitized.replace("'", "&apos;")

    # Remove invalid XML characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", sanitized)

    return sanitized


def _sanitize_xml_tag(tag: str) -> str:
    """Sanitize a string for use as an XML tag name.

    Args:
        tag: The tag name to sanitize

    Returns:
        Sanitized tag name
    """
    # XML tag names must start with a letter or underscore
    if not tag or not (tag[0].isalpha() or tag[0] == "_"):
        tag = "x_" + tag

    # Replace invalid characters with underscores
    sanitized = re.sub(r"[^a-zA-Z0-9_\-\.]", "_", tag)

    # Ensure it's a valid XML name
    if not re.match(r"^[a-zA-Z_][a-zA-Z0-9_\-\.]*$", sanitized):
        sanitized = "x_" + sanitized

    return sanitized


def sanitize_for_xml(value: Any) -> str:
    """Sanitize a value for use in XML.

    Args:
        value: The value to sanitize

    Returns:
        Sanitized value as a string
    """
    if value is None:
        return ""

    # Convert to string
    str_value = str(value)

    # Replace special XML characters with their entities
    sanitized = str_value.replace("&", "&amp;")
    sanitized = sanitized.replace("<", "&lt;")
    sanitized = sanitized.replace(">", "&gt;")
    sanitized = sanitized.replace('"', "&quot;")
    sanitized = sanitized.replace("'", "&apos;")

    # Remove invalid XML characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", sanitized)

    return sanitized

sanitize_for_xml = sanitize_for_xml

# xml_parser.py
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Any, Dict, List, Optional, Union


def parse_xml_file(file_path: Union[str, Path]) -> ET.Element:
    """
    Parse an XML file and return the root element.

    Args:
        file_path: Path to the XML file

    Returns:
        The root element of the XML document

    Raises:
        FileNotFoundError: If the file doesn't exist
        ET.ParseError: If the XML is not well-formed
    """
    file_path = Path(file_path)
    if not file_path.exists():
        raise FileNotFoundError(f"XML file not found: {file_path}")

    try:
        tree = ET.parse(file_path)
        return tree.getroot()
    except ET.ParseError as parse_error:
        raise ET.ParseError(f"Error parsing XML file {file_path}: {parse_error}")


def parse_xml_string(xml_string: str) -> ET.Element:
    """
    Parse an XML string and return the root element.

    Args:
        xml_string: The XML content as a string

    Returns:
        The root element of the XML document

    Raises:
        ET.ParseError: If the XML is not well-formed
    """
    try:
        return ET.fromstring(xml_string)
    except ET.ParseError as parse_error:
        raise ET.ParseError(f"Error parsing XML string: {parse_error}")


def get_element_text(root: ET.Element, xpath: str, default: Any = None) -> Any:
    """
    Get the text content of an element using XPath.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the element
        default: Default value to return if the element is not found

    Returns:
        The text content of the element, or the default value if not found
    """
    element = root.find(xpath)
    if element is None:
        return default
    return element.text


def get_element_attribute(root: ET.Element, xpath: str, attribute: str, default: Any = None) -> Any:
    """
    Get the value of an attribute using XPath.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the element
        attribute: Name of the attribute
        default: Default value to return if the attribute is not found

    Returns:
        The value of the attribute, or the default value if not found
    """
    element = root.find(xpath)
    if element is None:
        return default
    return element.get(attribute, default)


def get_elements(root: ET.Element, xpath: str) -> list[ET.Element]:
    """
    Get all elements matching an XPath expression.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the elements

    Returns:
        A list of elements matching the XPath expression
    """
    return root.findall(xpath)


def get_element_texts(root: ET.Element, xpath: str) -> list[str]:
    """
    Get the text content of all elements matching an XPath expression.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the elements

    Returns:
        A list of text content from elements matching the XPath expression
    """
    elements = get_elements(root, xpath)
    return [element.text for element in elements if element.text]


def get_architecture_title(file_path: Union[str, Path]) -> str | None:
    """
    Extract the title from an architecture XML document.

    Args:
        file_path: Path to the architecture XML file

    Returns:
        The title of the architecture, or None if not found
    """
    try:
        root = parse_xml_file(file_path)
        # Try different possible locations for the title
        title = get_element_text(root, ".//Title")
        if title:
            return title

        title = get_element_text(root, ".//MetaAgent/Title")
        if title:
            return title

        title = get_element_text(root, ".//Overview/Title")
        if title:
            return title

        return None
    except (FileNotFoundError, ET.ParseError):
        return None


def get_protocol_name(file_path: Union[str, Path]) -> str | None:
    """
    Extract the protocol name from a protocol XML document.

    Args:
        file_path: Path to the protocol XML file

    Returns:
        The name of the protocol, or None if not found
    """
    try:
        root = parse_xml_file(file_path)
        # Try different possible locations for the protocol name
        name = get_element_text(root, ".//Name")
        if name:
            return name

        name = get_element_text(root, ".//Protocol/Name")
        if name:
            return name

        return None
    except (FileNotFoundError, ET.ParseError):
        return None


def xml_to_dict(element: ET.Element) -> dict[str, Any]:
    """
    Convert an XML element to a dictionary.

    Args:
        element: The XML element to convert

    Returns:
        A dictionary representation of the XML element
    """
    result = {}

    # Add attributes
    for attribute_key, attribute_value in element.attrib.items():
        result[f"@{attribute_key}"] = attribute_value

    # Add text content if it exists and is not just whitespace
    if element.text and element.text.strip():
        result["#text"] = element.text.strip()

    # Add child elements
    for child_element in element:
        child_dict = xml_to_dict(child_element)
        child_tag = child_element.tag

        # Handle multiple children with the same tag
        if child_tag in result:
            if isinstance(result[child_tag], list):
                result[child_tag].append(child_dict)
            else:
                result[child_tag] = [result[child_tag], child_dict]
        else:
            result[child_tag] = child_dict

    return result

parse_xml_file = parse_xml_file
parse_xml_string = parse_xml_string
get_element_text = get_element_text
get_element_attribute = get_element_attribute
get_elements = get_elements
get_element_texts = get_element_texts
get_architecture_title = get_architecture_title
get_protocol_name = get_protocol_name
xml_to_dict = xml_to_dict

# rich_console.py
from rich.console import Console
from rich.table import Table
from rich.syntax import Syntax
from rich.panel import Panel
from rich.text import Text
from typing import Any, Optional


# Singleton Console instance
def get_console() -> Console:
    if not hasattr(get_console, "_console"):
        get_console._console = Console()
    return get_console._console


def print_panel(content: str, title: str | None = None, style: str = "bold blue"):
    """Print a styled panel with optional title using Rich library.

    Args:
        content (str): The text content to display in the panel.
        title (str | None, optional): Title of the panel. Defaults to None.
        style (str, optional): Rich styling for the panel. Defaults to "bold blue".
    """
    console = get_console()
    panel = Panel(content, title=title, style=style)
    console.print(panel)


def print_table(headers: list[str], rows: list[list[Any]], title: str | None = None):
    """Print a formatted table using Rich library.

    Args:
        headers (list[str]): Column headers for the table.
        rows (list[list[Any]]): Data rows to display in the table.
        title (str | None, optional): Title of the table. Defaults to None.
    """
    console = get_console()
    table = Table(title=title)
    for header in headers:
        table.add_column(header)
    for row in rows:
        table.add_row(*[str(cell) for cell in row])
    console.print(table)


def print_syntax(code: str, language: str = "python", title: str | None = None):
    """Print code syntax highlighting using Rich library.

    Args:
        code (str): Source code to highlight.
        language (str, optional): Programming language for syntax highlighting. Defaults to "python".
        title (str | None, optional): Title for the syntax block. Defaults to None.
    """
    console = get_console()
    syntax = Syntax(code, language, theme="monokai", line_numbers=True)
    if title:
        console.print(Panel(syntax, title=title))
    else:
        console.print(syntax)


def print_success(message: str):
    """Print a success message in green color.

    Args:
        message (str): Success message to display.
    """
    console = get_console()
    console.print(f"[bold green]✔ {message}")


def print_error(message: str):
    """Print an error message in red color.

    Args:
        message (str): Error message to display.
    """
    console = get_console()
    console.print(f"[bold red]✖ {message}")


def print_warning(message: str):
    """Print a warning message in yellow color.

    Args:
        message (str): Warning message to display.
    """
    console = get_console()
    console.print(f"[bold yellow]! {message}")


def print_info(message: str):
    """Print an informational message in blue color.

    Args:
        message (str): Informational message to display.
    """
    console = get_console()
    console.print(f"[bold blue]ℹ {message}")

get_console = get_console
print_panel = print_panel
print_table = print_table
print_syntax = print_syntax
print_success = print_success
print_error = print_error
print_warning = print_warning
print_info = print_info

# environment.py
import re
import os
import sys
from pathlib import Path
from typing_extensions import Callable
from pydantic import BaseModel, ConfigDict, Field
from getpass import getpass
from dotenv import load_dotenv
from typing import Optional, Dict, Any
from loguru import logger

load_dotenv()


class EnvironmentError(Exception):
    """Base exception for environment configuration errors."""

    pass


def is_sensitive_variable(name: str) -> bool:
    """
    Check if a variable name contains common sensitive terms.

    Args:
        name: The variable name to check

    Returns:
        True if the variable is likely sensitive, False otherwise
    """
    sensitive_terms = [
        "key",
        "token",
        "secret",
        "password",
        "credential",
        "auth",
        "api_key",
        "access_token",
        "private",
        "ssh",
        "certificate",
    ]

    name_lower = name.lower()
    return any(term in name_lower for term in sensitive_terms)


def mask_sensitive_value(value: str) -> str:
    """
    Mask a sensitive value for display.

    Args:
        value: The value to mask

    Returns:
        Masked value (first 2 chars + 3 stars)
    """
    if not value or len(value) <= 2:
        return "***"
    return value[:2] + "***"


class VariableDefinition(BaseModel):
    """Definition of an environment variable."""

    name: str
    type: type
    required: bool = True
    default: any = None
    validator: Callable[[any], bool] | None = None
    min_value: any = None
    max_value: any = None
    pattern: str | None = None
    model_config = ConfigDict(arbitrary_types_allowed=True)

    @property
    def is_sensitive(self) -> bool:
        """Check if this variable is sensitive."""
        return is_sensitive_variable(self.name)


class EnvironmentConfig(BaseModel):
    """Manages environment configuration with validation."""

    definitions: dict[str, VariableDefinition] = {}
    _variables: dict[str, any] = {}
    GITHUB_TOKEN: Optional[str] = Field(None, description="GitHub personal access token")
    ERASMUS_DEBUG: bool = Field(False, description="Enable debug logging")
    ERASMUS_LOG_LEVEL: str = Field(
        "INFO", description="Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)"
    )

    def list_variables(self):
        """List all currently defined environment variables.

        Returns:
            list: A list of dictionaries containing variable details.
        """
        for name, definition in self.definitions.items():
            if definition.is_sensitive:
                print(f"{name}: ****")
            else:
                print(f"{name}: {self._variables[name]}")

    def define_required(self, name: str, type_: type, **kwargs) -> None:
        """Define a required environment variable."""
        self.definitions[name] = VariableDefinition(name=name, type=type_, required=True, **kwargs)

    def define_optional(self, name: str, type_: type, **kwargs) -> None:
        """Define an optional environment variable."""
        self.definitions[name] = VariableDefinition(name=name, type=type_, required=False, **kwargs)

    def set(self, name: str, value: str) -> None:
        """Set an environment variable value."""
        if name not in self.definitions:
            raise EnvironmentError(f"Variable {name} not defined")

        definition = self.definitions[name]
        try:
            # Convert value to the specified type
            converted_value = definition.type(value)

            # Apply validation
            if definition.min_value is not None and converted_value < definition.min_value:
                raise EnvironmentError(
                    f"{name} must be greater than or equal to {definition.min_value}"
                )

            if definition.max_value is not None and converted_value > definition.max_value:
                raise EnvironmentError(
                    f"{name} must be less than or equal to {definition.max_value}"
                )

            if definition.pattern is not None and isinstance(converted_value, str):
                if not re.match(definition.pattern, converted_value):
                    raise EnvironmentError(f"{name} must match pattern {definition.pattern}")

            if definition.validator is not None and not definition.validator(converted_value):
                raise EnvironmentError(f"{name} failed custom validation")

            self._variables[name] = converted_value

        except (ValueError, TypeError) as e:
            raise EnvironmentError(f"Invalid value for {name}: {str(e)}")

    def get(self, name: str, default: any = None) -> any:
        """
        Get an environment variable value.

        Args:
            name: The variable name
            default: Default value if not found

        Returns:
            The variable value or default
        """
        if name not in self._variables:
            return default
        return self._variables[name]

    def get_masked(self, name: str) -> str:
        """
        Get a masked representation of a variable value.

        Args:
            name: The variable name

        Returns:
            Masked value if sensitive, actual value otherwise
        """
        if name not in self._variables:
            return ""

        value = self._variables[name]
        definition = self.definitions[name]

        if definition.is_sensitive and isinstance(value, str):
            return mask_sensitive_value(value)
        return str(value)

    def load_from_file(self, file_path: str | Path) -> None:
        """Load environment variables from a file."""
        file_path = Path(file_path)
        if not file_path.exists():
            raise EnvironmentError(f"Environment file not found: {file_path}")

        with open(file_path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    try:
                        name, value = line.split("=", 1)
                        name = name.strip()
                        value = value.strip()
                        self.set(name, value)
                    except ValueError:
                        continue

    def load_from_system(self) -> None:
        """Load environment variables from system environment."""
        for name, definition in self.definitions.items():
            if name in os.environ:
                self.set(name, os.environ[name])

    def prompt_for_missing(self) -> None:
        """Prompt for missing required variables."""
        for name, definition in self.definitions.items():
            if name not in self._variables and definition.required:
                if definition.is_sensitive:
                    value = getpass(f"Enter value for {name}: ")
                else:
                    value = input(f"Enter value for {name}: ")
                self.set(name, value)

    def validate(self) -> None:
        """Validate all required variables are set."""
        missing = []
        for name, definition in self.definitions.items():
            if definition.required and name not in self._variables:
                missing.append(name)

        if missing:
            raise EnvironmentError(f"Missing required variables: {', '.join(missing)}")

    def merge(self, other: "EnvironmentConfig") -> None:
        """
        Merge another config into this one.

        Args:
            other: The other config to merge
        """
        self.definitions.update(other.definitions)
        self._variables.update(other._variables)

    @classmethod
    def load(cls) -> "EnvironmentConfig":
        """Load environment configuration from environment variables."""
        env_vars = {
            "GITHUB_TOKEN": os.getenv("GITHUB_TOKEN"),
            "ERASMUS_DEBUG": os.getenv("ERASMUS_DEBUG", "false").lower() == "true",
            "ERASMUS_LOG_LEVEL": os.getenv("ERASMUS_LOG_LEVEL", "INFO").upper(),
        }

        # Configure logging based on environment
        logger.remove()  # Remove default handler
        log_level = env_vars["ERASMUS_LOG_LEVEL"]
        if env_vars["ERASMUS_DEBUG"]:
            log_level = "DEBUG"

        # Add a new handler with the correct level
        logger.add(
            sys.stderr,
            level=log_level,
            format="<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
            filter=lambda record: record["level"].name >= log_level,
        )

        return cls(**env_vars)


# Global environment configuration instance
_env_config: Optional[EnvironmentConfig] = None


def get_env_config() -> EnvironmentConfig:
    """Get the environment configuration singleton."""
    global _env_config
    if _env_config is None:
        _env_config = EnvironmentConfig.load()
    return _env_config


def is_debug_enabled() -> bool:
    """Check if debug mode is enabled."""
    return get_env_config().ERASMUS_DEBUG

EnvironmentError = EnvironmentError
is_sensitive_variable = is_sensitive_variable
mask_sensitive_value = mask_sensitive_value
VariableDefinition = VariableDefinition
EnvironmentConfig = EnvironmentConfig
get_env_config = get_env_config
is_debug_enabled = is_debug_enabled

# context.py
import os
import xml.etree.ElementTree as ET
from pathlib import Path
import re
import shutil
import typer
import sys

from loguru import logger
from pydantic import BaseModel



console = get_console()


class ContextError(Exception):
    """Base exception for all context management errors.

    This exception is raised when there are general issues with context
    management that do not fit into more specific error categories.
    Serves as a base class for more specific context-related exceptions.
    """


class ContextFileError(ContextError):
    """Exception raised when file-related operations in context management fail.

    This exception is used when there are issues such as:
    - Unable to read context files
    - Permission issues accessing context files
    - Context file not found
    - Corrupted or unreadable context files
    """


class ContextValidationError(ContextError):
    """Exception raised when context content fails validation requirements.

    This exception is used when context files do not meet expected
    structural or content requirements, such as:
    - Malformed XML
    - Missing required XML elements
    - Invalid data types or values
    - Incompatible context configurations
    """


path_manager = get_path_manager()


class CtxModel(BaseModel):
    """Represents a single development context with its associated file contents.

    This model encapsulates the core files that define a project's development context,
    providing a structured representation of project metadata and configuration.

    Attributes:
        path (str): The base path or identifier for this context.
        architecture (str): XML content representing the project's architectural design.
        progress (str): XML content tracking the current progress of development components.
        tasks (str): XML content listing and tracking project tasks.
        protocol (str, optional): XML content defining development protocols. Defaults to an empty
            string.

    The model ensures that each context is a self-contained unit with all necessary
    metadata for tracking and managing a development project.
    """

    path: str
    architecture: str
    progress: str
    tasks: str
    protocol: str = ""


class CtxMngrModel(BaseModel):
    """Manages a collection of development contexts and their associated file paths.

    This model serves as a comprehensive registry for multiple development contexts,
    providing centralized management of context-related paths and contents.

    Attributes:
        contexts (list[CtxModel]): A list of all managed context models. Defaults to an empty list.
        context_dir (Path): Base directory for storing context files. Uses path_manager to determine
            location.
        base_dir (Path): Alias for context_dir, ensuring consistent path management.
        context (CtxModel | None): Currently active context model. Defaults to None.

        # Paths for core context files
        architecture_path (str | Path): Path to the architecture context file.
        progress_path (str | Path): Path to the progress context file.
        tasks_path (str | Path): Path to the tasks context file.

        # Content storage for core context files
        architecture_content (str): Raw content of the architecture file.
        progress_content (str): Raw content of the progress file.
        tasks_content (str): Raw content of the tasks file.
        protocol_content (str): Raw content of the protocol file.

    The model provides a flexible and extensible approach to managing
    multiple development contexts with centralized path and content tracking.
    """


class ContextManager:
    """Manages context storage and loading."""

    def __init__(self, base_path: str | Path | None = None) -> None:
        """Initialize the context manager.

        Args:
            base_path: Optional base path for context storage
        """
        # Configure logging based on environment
        env_config = get_env_config()
        logger.remove()  # Remove default handler
        log_level = "DEBUG" if env_config.ERASMUS_DEBUG else env_config.ERASMUS_LOG_LEVEL
        logger.add(
            sys.stderr,
            level=log_level,
            format="<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        )

        self.path_manager = get_path_manager()
        self._base_path = (
            Path(base_path) if base_path else Path(self.path_manager.erasmus_dir) / "context"
        )
        self._base_path.mkdir(parents=True, exist_ok=True)
        self._architecture = None
        self._progress = None
        self._tasks = None
        self._current_context = None
        logger.info(f"Initialized ContextManager with base path: {self._base_path}")

    @property
    def architecture(self) -> str | None:
        """Get the current architecture content."""
        return self._architecture

    @property
    def progress(self) -> str | None:
        """Get the current progress content."""
        return self._progress

    @property
    def tasks(self) -> str | None:
        """Get the current tasks content."""
        return self._tasks

    @property
    def current_context(self) -> str | None:
        """Get the name of the currently loaded context."""
        return self._current_context

    def store_context(self, name: str | None = None) -> None:
        """Store the current context under a given name.

        Args:
            name: Optional name to store the context under. If not provided,
                 will try to get from architecture title or prompt user.
        """
        try:
            name = self._get_context_name(name)
            self._store_context_files(name)
            print(f"Stored context '{name}' in {self._base_path / name}")

        except Exception as e:
            print(f"Failed to store context: {e}")
            raise

    def _get_context_name(self, name: str | None) -> str:
        """Get a valid context name, either from args, architecture, or user prompt."""
        if name:
            return name

        arch_file = self.path_manager.get_architecture_file()
        if not arch_file.exists():
            return typer.prompt("Enter a name for the context")

        try:
            name = self._extract_title_from_architecture(arch_file)
            if name:
                return name
        except ET.ParseError as e:
            print(f"Failed to parse architecture file: {e}")

        return typer.prompt("Enter a name for the context")

    def _extract_title_from_architecture(self, arch_file: Path) -> str | None:
        """Extract title from architecture XML file."""
        content = arch_file.read_text().strip().replace("\n", "").replace("\r", "")
        tree = ET.ElementTree(ET.fromstring(content))
        root = tree.getroot()

        # Try direct path first
        overview = root.find("Overview")
        if overview is not None:
            title = overview.find("Title")
            if title is not None and title.text:
                return title.text.strip()

        # Try alternative paths
        title_paths = [
            ".//Title",
            ".//Architecture/Title",
            ".//Overview/Title",
            ".//Architecture/Overview/Title",
        ]

        for path in title_paths:
            title_elem = root.find(path)
            if title_elem is not None and title_elem.text:
                return title_elem.text.strip()

        # If no title found, prompt user and update architecture
        name = typer.prompt("Enter a name for the context")
        self._update_architecture_title(root, name, arch_file, tree)
        return name

    def _update_architecture_title(
        self, root: ET.Element, name: str, arch_file: Path, tree: ET.ElementTree
    ) -> None:
        """Update the architecture XML with the new title."""
        overview = root.find(".//Overview")
        if overview is None:
            overview = ET.SubElement(root, "Overview")
        title_elem = overview.find("Title")
        if title_elem is None:
            title_elem = ET.SubElement(overview, "Title")
        title_elem.text = name
        tree.write(arch_file, encoding="utf-8", xml_declaration=True)

    def _store_context_files(self, name: str) -> None:
        """Store context files in the named directory."""
        if not name:
            raise ValueError("Context name is required")

        context_dir = self._base_path / name
        context_dir.mkdir(parents=True, exist_ok=True)

        for src_file in [
            self.path_manager.get_architecture_file(),
            self.path_manager.get_progress_file(),
            self.path_manager.get_tasks_file(),
        ]:
            if src_file.exists():
                dst_file = context_dir / src_file.name
                shutil.copy2(src_file, dst_file)
                print(f"Copied {src_file} to {dst_file}")

    def load_context(self, name: str) -> None:
        """Load a stored context by name.

        Args:
            name: Name of the context to load
        """
        try:
            context_dir = self._base_path / name
            if not context_dir.exists():
                raise ValueError(f"Context '{name}' not found")

            # Copy context files back
            for src_file in context_dir.glob("*.xml"):
                if src_file.name.startswith(".ctx."):
                    dst_file = self.path_manager.get_architecture_file().parent / src_file.name
                    shutil.copy2(src_file, dst_file)
                    logger.debug(f"Copied {src_file} to {dst_file}")

            # Load the content into memory
            self._current_context = name
            arch_file = context_dir / ".ctx.architecture.xml"
            progress_file = context_dir / ".ctx.progress.xml"
            tasks_file = context_dir / ".ctx.tasks.xml"

            if arch_file.exists():
                self._architecture = arch_file.read_text()
            if progress_file.exists():
                self._progress = progress_file.read_text()
            if tasks_file.exists():
                self._tasks = tasks_file.read_text()

            logger.info(f"Loaded context '{name}' from {context_dir}")

        except Exception as e:
            logger.error(f"Failed to load context: {e}")
            raise

    def list_contexts(self) -> list[str]:
        """List all stored contexts.

        Returns:
            List of context names
        """
        try:
            return [d.name for d in self._base_path.iterdir() if d.is_dir()]
        except Exception as e:
            logger.error(f"Failed to list contexts: {e}")
            raise

    def delete_context(self, name: str) -> None:
        """Delete a stored context.

        Args:
            name: Name of the context to delete
        """
        try:
            context_dir = self._base_path / name
            shutil.rmtree(context_dir)
            logger.info(f"Deleted context '{name}'")

        except Exception as e:
            logger.error(f"Failed to delete context: {e}")
            raise

    def update_architecture(self, context_name: str, content: str) -> None:
        """Update the architecture file content for a context."""
        self.save_context_file(context_name, ".ctx.architecture.xml", content)

    def update_progress(self, context_name: str, content: str) -> None:
        """Update the progress file content for a context."""
        self.save_context_file(context_name, ".ctx.progress.xml", content)

    def update_tasks(self, context_name: str, content: str) -> None:
        """Update the tasks file content for a context."""
        self.save_context_file(context_name, ".ctx.tasks.xml", content)

    def get_default_content(self, file_type: str) -> str:
        template_map = {
            "architecture": self.path_manager.architecture_template,
            "progress": self.path_manager.progress_template,
            "tasks": self.path_manager.tasks_template,
            "protocol": self.path_manager.protocol_template,
            "meta_agent": self.path_manager.meta_agent_template,
            "meta_rules": self.path_manager.meta_rules_template,
        }
        if file_type not in template_map:
            raise ValueError(f"Unsupported file type: {file_type}")
        return template_map[file_type].read_text()

    def create_context(
        self,
        context_name: str,
        architecture_content: str | None = None,
        progress_content: str | None = None,
        tasks_content: str | None = None,
    ) -> None:
        """Create a new development context with optional custom content.

        This method establishes a new context directory and populates it with
        core XML files using either provided content or default templates.

        Args:
            context_name (str): A unique identifier for the new context.
                Will be sanitized to ensure file system compatibility.
            architecture_content (str, optional): Custom XML content for the
                architecture file. If None, uses the default template.
            progress_content (str, optional): Custom XML content for the
                progress tracking file. If None, uses the default template.
            tasks_content (str, optional): Custom XML content for the
                tasks file. If None, uses the default template.

        Raises:
            ContextError: If a context with the same name already exists.
            ValueError: If provided XML content is malformed.

        Notes:
            - Uses path_manager to locate template files
            - Sanitizes the context name for safe directory creation
            - Automatically creates a context directory
            - Supports partial or full custom content for context files
        """
        sanitized_name = self._sanitize_name(context_name)
        context_dir = self._base_path / sanitized_name
        if context_dir.exists():
            raise ContextError(f"Context already exists: {context_name}")

        # Create context directory
        context_dir.mkdir(parents=True, exist_ok=False)

        # Prepare architecture content
        architecture_content = architecture_content or self.get_default_content("architecture")
        named_architecture_content = architecture_content.replace(
            "  <Title>Project Title</Title>",
            f"  <Title>{context_name}</Title>",
        )

        # Define file mappings
        file_mappings = {
            ".ctx.architecture.xml": (
                self.path_manager.architecture_template,
                named_architecture_content,
                "Architecture",
            ),
            ".ctx.progress.xml": (
                self.path_manager.progress_template,
                progress_content or self.get_default_content("progress"),
                "Progress",
            ),
            ".ctx.tasks.xml": (
                self.path_manager.tasks_template,
                tasks_content or self.get_default_content("tasks"),
                "Tasks",
            ),
        }

        # Create each file
        for filename, (template_path, content, root_tag) in file_mappings.items():
            file_path = context_dir / filename
            try:
                # Validate XML content
                ET.fromstring(content)
                file_path.write_text(content)
            except ET.ParseError:
                # If content is not valid XML, wrap it in the appropriate root tag
                wrapped_content = f"<{root_tag}>{content}</{root_tag}>"
                file_path.write_text(wrapped_content)
            except Exception as e:
                raise ContextError(f"Failed to create {filename}: {str(e)}")

        # Create a CtxModel instance for the new context
        self.context = CtxModel(
            path=str(context_dir),
            architecture=named_architecture_content,
            progress=progress_content or self.get_default_content("progress"),
            tasks=tasks_content or self.get_default_content("tasks"),
        )

    def get_context(self, context_name: str) -> CtxModel:
        """Retrieve a specific context model by its name.

        This method searches for and returns a CtxModel instance
        corresponding to the given context name.

        Args:
            context_name (str): The name of the context to retrieve.

        Returns:
            CtxModel: The context model with the specified name.

        Raises:
            ContextError: If no context with the given name is found.

        Notes:
            - Uses get_context_model internally to fetch the context
            - Supports case-insensitive and sanitized context name matching
        """
        return self.get_context_model(context_name)

    @property
    def base_path(self) -> Path:
        """Get the base path for context storage."""
        return self._base_path

    def save_context_file(self, context_name: str, filename: str, content: str) -> None:
        """Save raw content to a file within a specific context directory.

        This method writes the provided content to a file in the context
        directory, creating the directory if it doesn't exist.

        Args:
            context_name (str): The name of the context to save the file in.
            filename (str): The name of the file to be saved.
            content (str): The raw content to write to the file.

        Raises:
            ContextError: If the context directory cannot be created or accessed.
            OSError: If there are file system permission issues.

        Notes:
            - Automatically creates the context directory if it doesn't exist
            - Overwrites the file if it already exists
            - Does not perform any content validation or sanitization
        """
        context_dir = self.get_context_path(context_name)
        context_dir.mkdir(parents=True, exist_ok=True)
        file_path = context_dir / filename
        file_path.write_text(content)

    def load_context_file(self, context_name: str, filename: str) -> str:
        """Load and sanitize content from a file within a specific context directory.

        This method reads a file from the specified context directory,
        returning an empty string if the file does not exist.

        Args:
            context_name (str): The name of the context to load the file from.
            filename (str): The name of the file to load.

        Returns:
            str: The sanitized content of the file. Returns an empty string
                 if the file does not exist.

        Notes:
            - Uses _sanitize_content to clean the loaded file content
            - Silently handles non-existent files by returning an empty string
            - Ensures that loaded content is safe for further processing

        Raises:
            ContextError: If there are issues accessing the context directory.
            OSError: If there are file system permission issues.
        """
        context_dir = self.get_context_path(context_name)
        file_path = context_dir / filename
        if not file_path.exists():
            return ""
        raw = file_path.read_text()
        return self._sanitize_content(raw)

    def list_context_files(self, context_name: str) -> list[str]:
        """List all file names in the specified context directory."""
        context_dir = self.get_context_path(context_name)
        if not context_dir.exists():
            return []
        return [
            context_file.name for context_file in context_dir.iterdir() if context_file.is_file()
        ]

    def delete_context_file(self, context_name: str, filename: str) -> None:
        """Delete a file in the specified context directory."""
        context_dir = self.get_context_path(context_name)
        file_path = context_dir / filename
        if file_path.exists():
            file_path.unlink()

    def _sanitize_name(self, context_name: str) -> str:
        """
        Sanitize a context name for filesystem use.

        Args:
            context_name: The context name to sanitize.

        Returns:
            The sanitized name.
        """
        # Replace any non-alphanumeric characters with underscores
        sanitized = re.sub(r"[^a-zA-Z0-9]", "_", context_name)
        # Remove multiple consecutive underscores
        sanitized = re.sub(r"_+", "_", sanitized)
        # Remove leading/trailing underscores
        sanitized = sanitized.strip("_")
        return sanitized

    def _get_context_dir(self, context_name: str) -> Path:
        """
        Get the directory for a context.
        Args:
            context_name: The context name.
        Returns:
            The context directory path.
        """
        return self._base_path / self._sanitize_name(context_name)

    def _sanitize_filename(self, filename: str) -> str:
        """
        Sanitize a filename to be ASCII-only and safe for filesystem operations.
        Args:
            filename: The filename to sanitize
        Returns:
            Sanitized filename
        """
        return _sanitize_string(filename)

    def _sanitize_content(self, content: str) -> str:
        """
        Sanitize XML content to be ASCII-only and well-formed.
        Args:
            content: The content to sanitize
        Returns:
            Sanitized content
        """
        return _sanitize_xml_content(content)

    def get_context_path(self, context_name: str) -> Path:
        """
        Get the path for a context's directory.
        Args:
            context_name: Name of the context
        Returns:
            Path to the context directory
        """
        sanitized_name = self._sanitize_filename(context_name)
        return self._base_path / sanitized_name

    def get_context_dir_path(self, context_name: str) -> Path | None:
        """
        Get the directory path for a context if it exists.
        Args:
            context_name: Name of the context
        Returns:
            Path to the context directory, or None if it doesn't exist
        """
        try:
            context_dir = self._get_context_dir(context_name)
            return context_dir if context_dir.exists() else None
        except Exception as context_error:
            raise ContextFileError(
                f"Failed to get context path: {context_error}",
            ) from context_error

    def save_contexts(self) -> list[CtxModel]:
        """
        Save all contexts by loading them from disk into CtxModel instances.
        Returns:
            List of saved CtxModel instances
        """
        context_models: list[CtxModel] = []
        # Always use path_manager.get_context_dir()
        for context_directory in self.path_manager.get_context_dir().iterdir():
            if context_directory.is_dir():
                context_name = context_directory.name
                try:
                    context_path = self.get_context_dir_path(context_name)
                    if context_path:
                        context_models.append(self.get_context_model(context_name))
                except Exception as context_error:
                    logger.error(f"Failed to save context {context_name}: {context_error}")
        return context_models

    def display_context(self, context_name: str) -> None:
        """Display the contents of a context."""
        context_dir = self._get_context_dir(context_name)
        if not context_dir.exists():
            raise ContextError(f"Context not found: {context_name}")

        arch_file = context_dir / ".ctx.architecture.xml"
        progress_file = context_dir / ".ctx.progress.xml"
        tasks_file = context_dir / ".ctx.tasks.xml"

        if not all(f.exists() for f in [arch_file, progress_file, tasks_file]):
            raise ContextError(f"Missing required files in context: {context_name}")

        print(f"\nContext: {context_name}")
        print("\nArchitecture:")
        print(arch_file.read_text())
        print("\nProgress:")
        print(progress_file.read_text())
        print("\nTasks:")
        print(tasks_file.read_text())

    def select_context(self, context_name: str | None = None) -> None:
        """Select a context to work with."""
        if context_name is None:
            contexts = self.list_contexts()
            if not contexts:
                raise ContextError("No contexts available")
            print("\nAvailable contexts:")
            for i, ctx in enumerate(contexts, 1):
                print(f"{i}. {ctx}")
            while True:
                try:
                    choice = int(input("\nSelect a context (number): "))
                    if 1 <= choice <= len(contexts):
                        context_name = contexts[choice - 1]
                        break
                    print("Invalid choice. Please try again.")
                except ValueError:
                    print("Please enter a number.")

        if self.get_context(context_name):
            self.save_contexts()

        self._load_context(context_name)
        print(f"Selected context: {context_name}")

    def _load_context(self, context_name: str) -> None:
        """Load a context into memory."""
        context_dir = self._get_context_dir(context_name)
        arch_file = context_dir / ".ctx.architecture.xml"
        progress_file = context_dir / ".ctx.progress.xml"
        tasks_file = context_dir / ".ctx.tasks.xml"

        if not all(f.exists() for f in [arch_file, progress_file, tasks_file]):
            raise ContextError(f"Missing required files in context: {context_name}")

        self.current_context = context_name
        self.architecture = arch_file.read_text()
        self.progress = progress_file.read_text()
        self.tasks = tasks_file.read_text()

    def update_file(self, context_name: str, file_type: str, content: str) -> None:
        """
        Update a file in a development context.
        Args:
            context_name: The name of the context.
            file_type: The type of file to update (architecture, progress, tasks, protocol).
            content: The content to write to the file.
        Raises:
            ContextError: If the file cannot be updated.
        """
        context_dir = self.get_context_dir_path(context_name)
        if not context_dir:
            raise ContextError(f"Context does not exist: {context_name}")
        file_path = context_dir / f"ctx.{file_type}.xml"
        try:
            file_path.write_text(content)
        except Exception as error:
            raise ContextError(f"Failed to update file: {error}") from error

    def read_file(self, context_name: str, file_type: str) -> str | None:
        """
        Read a file from a development context.
        Args:
            context_name: The name of the context.
            file_type: The type of file to read (architecture, progress, tasks, protocol).
        Returns:
            The file content, or None if the file does not exist.
        Raises:
            ContextError: If the file cannot be read.
        """
        context_dir = self.get_context_dir_path(context_name)
        if not context_dir:
            raise ContextError(f"Context does not exist: {context_name}")
        file_path = context_dir / f"ctx.{file_type}.xml"
        try:
            return file_path.read_text() if file_path.exists() else None
        except Exception as error:
            raise ContextError(f"Failed to read file: {error}") from error

    def edit_file(self, context_name: str, file_type: str, editor: str | None = None) -> None:
        """
        Edit a file in a development context using the specified editor.
        Args:
            context_name: The name of the context.
            file_type: The type of file to edit (architecture, progress, tasks, protocol).
            editor: The editor to use. If None, the default editor is used.
        Raises:
            ContextError: If the file cannot be edited.
        """
        context_dir = self.get_context_dir_path(context_name)
        if not context_dir:
            raise ContextError(f"Context does not exist: {context_name}")
        file_path = context_dir / f"ctx.{file_type}.xml"
        if not file_path.exists():
            raise ContextError(f"File does not exist: {file_type}")
        try:
            editor_cmd = editor or os.environ.get("EDITOR", "nano")
            os.system(f"{editor_cmd} {file_path}")
        except Exception as error:
            raise ContextError(f"Failed to edit file: {error}") from error

    def get_context_model(self, context_name: str) -> CtxModel:
        """
        Get a CtxModel instance by context name.
        Args:
            context_name: Name of the context
        Returns:
            CtxModel instance
        Raises:
            ContextFileError: If context doesn't exist
        """
        try:
            context_dir = self._get_context_dir(context_name)
            if not context_dir.exists():
                raise ContextFileError(f"Context does not exist: {context_name}")

            architecture = self.read_file(context_name, "architecture") or ""
            progress = self.read_file(context_name, "progress") or ""
            tasks = self.read_file(context_name, "tasks") or ""

            return CtxModel(
                path=str(context_dir),
                architecture=architecture,
                progress=progress,
                tasks=tasks,
            )
        except Exception as context_error:
            raise ContextFileError(f"Failed to get context: {context_error}") from context_error

    def _sanitize_string(self, filename: str) -> str:
        """
        Sanitize a filename to be ASCII-only and safe for filesystem operations.

        Args:
            filename: The filename to sanitize

        Returns:
            Sanitized filename
        """
        return _sanitize_string(filename)

    def _sanitize_xml(self, content: str) -> str:
        """
        Sanitize XML content to be ASCII-only and safe for filesystem operations.
        """
        return _sanitize_xml_content(content)

ContextError = ContextError
ContextFileError = ContextFileError
ContextValidationError = ContextValidationError
CtxModel = CtxModel
CtxMngrModel = CtxMngrModel

# protocol.py
from pathlib import Path
from typing import Optional
from pydantic import BaseModel
from loguru import logger



path_manager = get_path_manager()


class ProtocolError(Exception):
    """Exception raised for protocol-related errors."""

    pass


class ProtocolModel(BaseModel):
    """
    Represents a protocol, including its name, path, and content.
    """

    name: str
    path: str
    content: str


class ProtocolManager:
    """
    Manages protocol files for Erasmus.
    Loads base protocol templates from erasmus.erasmus/templates/protocols and custom user protocols from erasmus.erasmus/protocol.
    Provides methods to list, get, create, update, and delete protocols.
    """

    def __init__(self, base_dir: str | None = None, user_dir: str | None = None) -> None:
        # Always use path_manager.template_dir / 'protocols' unless base_dir is explicitly provided
        self.base_template_dir: Path = (
            Path(base_dir) if base_dir is not None else path_manager.template_dir / "protocols"
        )
        self.user_protocol_dir: Path = Path(user_dir) if user_dir else path_manager.protocol_dir
        self.base_template_dir.mkdir(parents=True, exist_ok=True)
        self.user_protocol_dir.mkdir(parents=True, exist_ok=True)
        logger.info(
            f"Initialized ProtocolManager with base template dir: {self.base_template_dir} and user protocol dir: {self.user_protocol_dir}"
        )

    def _sanitize_name(self, protocol_name: str) -> str:
        """Sanitize a protocol name for filesystem use."""
        return _sanitize_string(protocol_name)

    def _get_protocol_path(self, protocol_name: str, is_template: bool = False) -> Path:
        """
        Get the path for a protocol file.
        Args:
            protocol_name: The protocol name
            is_template: If True, look in the template directory; else, user directory
        Returns:
            Path to the protocol file
        """
        sanitized_name = self._sanitize_name(protocol_name)
        directory = self.base_template_dir if is_template else self.user_protocol_dir
        return directory / f"{sanitized_name}.xml"

    def list_protocols(
        self, include_templates: bool = True, include_user: bool = True
    ) -> list[str]:
        """
        List all available protocol names.
        Args:
            include_templates: Include base templates
            include_user: Include user protocols
        Returns:
            List of protocol names
        """
        protocol_names = set()
        if include_templates:
            protocol_names.update(
                [protocol_path.stem for protocol_path in self.base_template_dir.glob("*.xml")]
            )
        if include_user:
            protocol_names.update(
                [protocol_path.stem for protocol_path in self.user_protocol_dir.glob("*.xml")]
            )
        return sorted(protocol_names)

    def get_protocol(self, protocol_name: str) -> ProtocolModel | None:
        """
        Get a protocol by name, searching user protocols first, then templates.
        Args:
            protocol_name: The protocol name
        Returns:
            ProtocolModel if found, else None
        """
        sanitized_name = self._sanitize_name(protocol_name)
        user_path = self._get_protocol_path(sanitized_name, is_template=False)
        template_path = self._get_protocol_path(sanitized_name, is_template=True)
        if user_path.exists():
            content = user_path.read_text()
            return ProtocolModel(name=sanitized_name, path=str(user_path), content=content)
        elif template_path.exists():
            content = template_path.read_text()
            return ProtocolModel(name=sanitized_name, path=str(template_path), content=content)
        else:
            return None

    def create_protocol(self, protocol_name: str, content: str) -> ProtocolModel:
        """
        Create a new user protocol.
        Args:
            protocol_name: The protocol name
            content: The protocol content
        Returns:
            The created ProtocolModel
        Raises:
            FileExistsError: If a user protocol with the same name already exists
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        if protocol_path.exists():
            raise FileExistsError(f"Protocol '{sanitized_name}' already exists.")
        # Use template if content is not provided or empty
        if not isinstance(content, str) or not content.strip():
            template_path = path_manager.template_dir / "protocol.xml"
            if template_path.exists():
                content = template_path.read_text()
            else:
                content = '<?xml version="1.0" encoding="UTF-8"?>\n<Protocol></Protocol>'
        else:
            # If content is not valid XML, wrap it in <Protocol>...</Protocol>
            import xml.etree.ElementTree as ET

            try:
                ET.fromstring(content)
            except Exception:
                content = f'<?xml version="1.0" encoding="UTF-8"?>\n<Protocol>{content}</Protocol>'
        protocol_path.write_text(_sanitize_xml_content(content))
        logger.info(f"Created protocol: {sanitized_name}")
        return ProtocolModel(name=sanitized_name, path=str(protocol_path), content=content)

    def update_protocol(self, protocol_name: str, content: str) -> ProtocolModel:
        """
        Update an existing user protocol.
        Args:
            protocol_name: The protocol name
            content: The new protocol content
        Returns:
            The updated ProtocolModel
        Raises:
            FileNotFoundError: If the protocol does not exist in user protocols
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        if not protocol_path.exists():
            raise FileNotFoundError(f"Protocol '{sanitized_name}' not found in user protocols.")
        # Ensure content is a valid XML string
        if not isinstance(content, str) or not content.strip():
            content = '<?xml version="1.0" encoding="UTF-8"?>\n<Protocol></Protocol>'
        else:
            import xml.etree.ElementTree as ET

            try:
                ET.fromstring(content)
            except Exception:
                content = f'<?xml version="1.0" encoding="UTF-8"?>\n<Protocol>{content}</Protocol>'
        protocol_path.write_text(_sanitize_xml_content(content))
        logger.info(f"Updated protocol: {sanitized_name}")
        return ProtocolModel(name=sanitized_name, path=str(protocol_path), content=content)

    def delete_protocol(self, protocol_name: str) -> None:
        """
        Delete a user protocol.
        Args:
            protocol_name: The protocol name
        Raises:
            FileNotFoundError: If the protocol does not exist in user protocols
            PermissionError: If attempting to delete a template protocol
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        template_path = self._get_protocol_path(sanitized_name, is_template=True)
        # Prevent deletion if protocol is a template
        if template_path.exists():
            raise PermissionError(
                f"Cannot delete template protocol: '{sanitized_name}'. Only custom (user) protocols can be deleted."
            )
        if not protocol_path.exists():
            raise FileNotFoundError(f"Protocol '{sanitized_name}' not found in user protocols.")
        protocol_path.unlink()
        logger.info(f"Deleted protocol: {sanitized_name}")

ProtocolError = ProtocolError
ProtocolModel = ProtocolModel

# file_monitor.py
import os
import time
from typing import Optional, Set
from watchdog.observers import ObserverType, Observer
from watchdog.events import FileSystemEventHandler, FileSystemEvent
from loguru import logger
from pathlib import Path


import re

import xml.etree.ElementTree as ET
import fnmatch

# Add a global to track last rules file write time
_last_rules_write_time = None


def _merge_rules_file() -> None:
    """
    Merge current .ctx files into the IDE rules file using the meta_rules.xml template.
    Refreshes IDE detection to ensure correct rules file is used.
    Overwrites the rules file every time with a fresh merge of the template and current context/protocol content.
    Prompts the user to select a protocol if none is set or the file is missing.
    """


    global _last_rules_write_time

    detected_ide = detect_ide_from_env()
    path_manager = get_path_manager(detected_ide)
    template_path = path_manager.template_dir / "meta_rules.xml"
    rules_file_path = path_manager.get_rules_file()
    if not template_path.exists():
        # No template available: fallback to raw merge of ctx files
        logger.warning(f"Template file not found: {template_path}; falling back to raw merge")
        try:
            architecture_text = path_manager.get_architecture_file().read_text()
            progress_text = path_manager.get_progress_file().read_text()
            tasks_text = path_manager.get_tasks_file().read_text()
            merged_content = "\n".join([architecture_text, progress_text, tasks_text])
            if not rules_file_path:
                logger.warning("No rules file configured; skipping local merge")
            else:
                rules_file_path.write_text(merged_content)
                _last_rules_write_time = rules_file_path.stat().st_mtime
                logger.info(f"Updated local rules file (fallback): {rules_file_path}")
        except Exception as exception:
            logger.error(f"Error during fallback merge: {exception}")
        return
    try:
        # Always start from a fresh template
        template_content = template_path.read_text()
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        merged_content = template_content
        merged_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            merged_content,
        )
        merged_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, merged_content
        )
        merged_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, merged_content)
        # Get protocol value from the current_protocol.txt file, or prompt if missing/invalid
        protocol_value = ""
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        protocol_manager = ProtocolManager()
        protocol_name = None
        if current_protocol_path.exists():
            protocol_name = current_protocol_path.read_text().strip()
        protocol_file = None
        if protocol_name:
            # Ensure protocol_name does not have .xml extension already
            if protocol_name.endswith(".xml"):
                protocol_file = path_manager.protocol_dir / protocol_name
            else:
                protocol_file = path_manager.protocol_dir / f"{protocol_name}.xml"
            print(f"[DEBUG] Loaded protocol name: '{protocol_name}'")
            print(f"[DEBUG] Checking protocol file: {protocol_file}")
            # Fallback to template protocols if not found in user protocol dir
            if not protocol_file.exists():
                template_protocol_file = (
                    path_manager.template_dir / "protocols" / f"{protocol_name}.xml"
                )
                print(f"[DEBUG] Checking template protocol file: {template_protocol_file}")
                if template_protocol_file.exists():
                    protocol_file = template_protocol_file
        if not protocol_name or not protocol_file or not protocol_file.exists():
            # Try to extract protocol from the existing rules file using XML parsing
            if rules_file_path and rules_file_path.exists():
                try:
                    tree = ET.parse(rules_file_path)
                    root = tree.getroot()
                    # Try to find <Protocol> block
                    protocol_elem = root.find(".//Protocol")
                    if protocol_elem is not None:
                        protocol_value = ET.tostring(protocol_elem, encoding="unicode")
                        print("[DEBUG] Extracted protocol from existing rules file.")
                except Exception as e:
                    print(f"[DEBUG] Failed to extract protocol from rules file: {e}")
            if not protocol_value:
                # Prompt user to select a protocol
                protocols = protocol_manager.list_protocols()
                if not protocols:
                    logger.error("No protocols found. Cannot update rules file.")
                    return
                print("Available protocols:")
                for idx, pname in enumerate(protocols):
                    print(f"  {idx + 1}. {pname}")
                while True:
                    choice = input("Select a protocol by number or name: ").strip()
                    selected = None
                    if choice.isdigit():
                        idx = int(choice)
                        if 1 <= idx <= len(protocols):
                            selected = protocols[idx - 1]
                    elif choice in protocols:
                        selected = choice
                    if selected:
                        protocol_name = selected.strip()
                        current_protocol_path.write_text(protocol_name)
                        protocol_file = path_manager.protocol_dir / f"{protocol_name}.xml"
                        print(f"[DEBUG] User selected protocol: '{protocol_name}'")
                        print(f"[DEBUG] Checking protocol file: {protocol_file}")
                        # Fallback to template protocols if not found in user protocol dir
                        if not protocol_file.exists():
                            template_protocol_file = (
                                path_manager.template_dir / "protocols" / f"{protocol_name}.xml"
                            )
                            print(
                                f"[DEBUG] Checking template protocol file: {template_protocol_file}"
                            )
                            if template_protocol_file.exists():
                                protocol_file = template_protocol_file
                        if protocol_file.exists():
                            protocol_value = protocol_file.read_text()
                        else:
                            print(f"Protocol file not found: {protocol_file}")
                            continue
                        break
                    print(f"Invalid selection: {choice}")
        else:
            if protocol_file and protocol_file.exists():
                protocol_value = protocol_file.read_text()
        merged_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->", protocol_value, merged_content
        )
        # Overwrite the rules file with the merged content
        if not rules_file_path:
            logger.warning("No rules file configured; skipping local merge")
        else:
            rules_file_path.write_text(merged_content)
            _last_rules_write_time = rules_file_path.stat().st_mtime
            logger.info(f"Updated local rules file: {rules_file_path}")
    except Exception as exception:
        logger.error(f"Error merging rules file: {exception}")


class FileEventHandler(FileSystemEventHandler):
    """
    Handles file system events with debouncing.
    """

    def __init__(self, debounce_time: float = 0.1) -> None:
        """
        Initialize the event handler.
        Args:
            debounce_time: Time in seconds to wait before processing duplicate events
        """
        super().__init__()
        self.debounce_time: float = debounce_time
        self.processed_events: Set[str] = set()
        self.last_processed: dict[str, float] = {}
        self.on_created = None
        self.on_modified = None
        self.on_deleted = None
        self.ignore_directory_events = False

    def _should_process_event(self, event: FileSystemEvent) -> bool:
        """
        Check if an event should be processed based on debouncing and filtering.
        Args:
            event: The file system event
        Returns:
            bool: True if event should be processed
        """
        # Skip directory events if configured
        if self.ignore_directory_events and event.is_directory:
            return False

        current_time = time.time()
        event_key = f"{event.event_type}:{event.src_path}"

        # Check if this is a duplicate event within debounce time
        if event_key in self.last_processed:
            if current_time - self.last_processed[event_key] < self.debounce_time:
                return False

        self.last_processed[event_key] = current_time
        return True

    def on_created(self, event: FileSystemEvent) -> None:
        """
        Handle file creation events.
        Args:
            event: The file system event
        """
        if self._should_process_event(event):
            if self.on_created:
                self.on_created(event)
                # For directory creation, also emit an event for the parent directory
                if event.is_directory:
                    parent_dir = os.path.dirname(event.src_path)
                    if parent_dir:
                        parent_event = FileSystemEvent(
                            event_type="created", src_path=parent_dir, is_directory=True
                        )
                        if self.on_created:
                            self.on_created(parent_event)

    def on_modified(self, event: FileSystemEvent) -> None:
        """
        Handle file modification events.
        Args:
            event: The file system event
        """
        if self._should_process_event(event):
            if self.on_modified:
                self.on_modified(event)
                # For file modification, also emit an event for the parent directory
                if not event.is_directory:
                    parent_dir = os.path.dirname(event.src_path)
                    if parent_dir:
                        parent_event = FileSystemEvent(
                            event_type="modified", src_path=parent_dir, is_directory=True
                        )
                        if self.on_modified:
                            self.on_modified(parent_event)

    def on_deleted(self, event: FileSystemEvent) -> None:
        """
        Handle file deletion events.
        Args:
            event: The file system event
        """
        if self._should_process_event(event):
            if self.on_deleted:
                # Process the original event first
                self.on_deleted(event)
                # For file deletion, also emit an event for the parent directory
                if not event.is_directory:
                    parent_dir = os.path.dirname(event.src_path)
                    if parent_dir:
                        parent_event = FileSystemEvent(
                            event_type="deleted", src_path=parent_dir, is_directory=True
                        )
                        self.on_deleted(parent_event)
                # For directory deletion, also emit an event for the parent directory
                elif event.is_directory:
                    parent_dir = os.path.dirname(event.src_path)
                    if parent_dir:
                        parent_event = FileSystemEvent(
                            event_type="deleted", src_path=parent_dir, is_directory=True
                        )
                        self.on_deleted(parent_event)


class FileMonitor:
    """
    Monitors file system events and updates rules files.
    """

    def __init__(self) -> None:
        """Initialize the file monitor."""
        self.pm = get_path_manager()
        self.debug = is_debug_enabled()
        if self.debug:
            logger.info(f"Initialized FileMonitor with path manager: {self.pm}")
        self.observer = Observer()
        self.event_handler = FileEventHandler()
        self.watch_paths: dict[str, bool] = {
            str(self.pm.architecture_file): True,
            str(self.pm.progress_file): True,
            str(self.pm.tasks_file): True,
        }  # path -> recursive
        if self.debug:
            logger.info(f"Watch paths configured: {self.watch_paths}")
        self.ignore_patterns: list[str] = []
        self.on_created = None
        self.on_modified = None
        self.on_deleted = None
        self._is_running = False
        self._last_merge_time = 0
        self._merge_debounce = 0.5  # Debounce time for merging rules

    def _should_merge_rules(self) -> bool:
        """Check if enough time has passed since last merge."""
        current_time = time.time()
        should_merge = current_time - self._last_merge_time > self._merge_debounce
        if should_merge:
            if self.debug:
                logger.debug("Debounce period passed, will merge rules")
            self._last_merge_time = current_time
        elif self.debug:
            logger.debug("Within debounce period, skipping merge")
        return should_merge

    def _handle_context_change(self, event: FileSystemEvent) -> None:
        """Handle changes to context files."""
        if self.debug:
            logger.info(f"Handling context change event: {event.event_type} - {event.src_path}")
        if self._matches_rules_file(event.src_path):
            if self.debug:
                logger.debug(f"Ignoring rules file change: {event.src_path}")
            return

        if self._should_merge_rules():
            logger.info(f"Merging rules due to context file change: {event.src_path}")
            try:
                _merge_rules_file()
                logger.info("Rules merge completed successfully")
            except Exception as e:
                logger.error(f"Error merging rules: {e}")

    def add_watch_path(self, watch_path: str | Path, recursive: bool = False) -> None:
        """Add a path to monitor."""
        watch_path = str(Path(watch_path).resolve())
        if not os.path.exists(watch_path):
            raise FileMonitorError(f"Watch path does not exist: {watch_path}")
        self.watch_paths[watch_path] = recursive
        if self._is_running:
            self.observer.schedule(self.event_handler, watch_path, recursive=recursive)
            logger.info(f"Added watch path: {watch_path}")

    def remove_watch_path(self, watch_path: str | Path) -> None:
        """Remove a monitored path."""
        watch_path = str(Path(watch_path).resolve())
        if watch_path in self.watch_paths:
            del self.watch_paths[watch_path]
            if self._is_running:
                # Find and remove the watch for this path
                for watch in list(self.observer._watches.values()):
                    if watch.path == watch_path:
                        self.observer.unschedule(watch)
                        logger.info(f"Removed watch path: {watch_path}")
                        break

    def add_ignore_pattern(self, pattern: str) -> None:
        """Add a pattern to ignore."""
        self.ignore_patterns.append(pattern)
        logger.info(f"Added ignore pattern: {pattern}")

    def _matches_ignore_pattern(self, file_path: str) -> bool:
        """Check if a file path matches any ignore pattern."""
        return any(fnmatch.fnmatch(file_path, pattern) for pattern in self.ignore_patterns)

    def _matches_rules_file(self, file_path: str) -> bool:
        """Check if a file path matches any rules file pattern."""
        rules_patterns = [
            r"\.codex\.md$",
            r"\.cursorrules$",
            r"\.windsurfrules$",
            r"CLAUDE\.md$",
        ]
        matches = any(re.search(pattern, file_path) for pattern in rules_patterns)
        if matches and self.debug:
            logger.debug(f"File matches rules pattern: {file_path}")
        return matches

    def start(self) -> None:
        """Start monitoring."""
        if not self.watch_paths:
            raise FileMonitorError("No watch paths configured")

        if self._is_running:
            logger.warning("Monitor is already running")
            return

        logger.info("Starting file monitor...")

        # Set up event handlers
        def on_created_wrapper(event):
            if self.debug:
                logger.debug(f"Created event received: {event.src_path}")
            if self._matches_ignore_pattern(event.src_path):
                if self.debug:
                    logger.debug(f"Ignoring created event due to pattern match: {event.src_path}")
                return
            self._handle_context_change(event)
            if self.on_created:
                self.on_created(event)

        def on_modified_wrapper(event):
            if self.debug:
                logger.debug(f"Modified event received: {event.src_path}")
            if self._matches_ignore_pattern(event.src_path):
                if self.debug:
                    logger.debug(f"Ignoring modified event due to pattern match: {event.src_path}")
                return
            self._handle_context_change(event)
            if self.on_modified:
                self.on_modified(event)

        def on_deleted_wrapper(event):
            if self.debug:
                logger.debug(f"Deleted event received: {event.src_path}")
            if self._matches_ignore_pattern(event.src_path):
                if self.debug:
                    logger.debug(f"Ignoring deleted event due to pattern match: {event.src_path}")
                return
            self._handle_context_change(event)
            if self.on_deleted:
                self.on_deleted(event)

        self.event_handler.on_created = on_created_wrapper
        self.event_handler.on_modified = on_modified_wrapper
        self.event_handler.on_deleted = on_deleted_wrapper

        # Start observer for each watch path
        for watch_path, recursive in self.watch_paths.items():
            # Ensure the watch path exists
            if not os.path.exists(watch_path):
                logger.warning(f"Watch path does not exist, creating: {watch_path}")
                os.makedirs(os.path.dirname(watch_path), exist_ok=True)
                Path(watch_path).touch()

            # Schedule the watch
            try:
                self.observer.schedule(
                    self.event_handler, os.path.dirname(watch_path), recursive=recursive
                )
                logger.info(f"Started monitoring: {watch_path} (recursive={recursive})")
            except Exception as e:
                logger.error(f"Failed to schedule watch for {watch_path}: {e}")

        try:
            self.observer.start()
            logger.info("File monitor observer started successfully")
        except Exception as e:
            logger.error(f"Failed to start observer: {e}")
            return

        self._is_running = True

        # Initial merge of rules
        logger.info("Performing initial rules merge...")
        try:
            _merge_rules_file()
            logger.info("Initial rules merge completed successfully")
        except Exception as e:
            logger.error(f"Error during initial rules merge: {e}")

    def stop(self) -> None:
        """Stop monitoring."""
        if not self._is_running:
            logger.warning("Monitor is not running")
            return

        logger.info("Stopping file monitor...")
        if self.observer.is_alive():
            try:
                self.observer.stop()
                self.observer.join()
                self.observer = Observer()  # Create a new observer for next start
                for watch_path in self.watch_paths:
                    logger.info(f"Stopped monitoring: {watch_path}")
                logger.info("File monitor stopped successfully")
            except Exception as e:
                logger.error(f"Error stopping observer: {e}")
        self._is_running = False

    def __enter__(self) -> "FileMonitor":
        """Start monitoring when entering context."""
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Stop monitoring when exiting context."""
        self.stop()


class FileMonitorError(Exception):
    """Base exception for file monitor errors."""


class ContextFileHandler(FileSystemEventHandler):
    """Handles file system events for .ctx files."""

    def __init__(self, debounce_time: float = 0.5) -> None:
        """Initialize the event handler.

        Args:
            debounce_time: Time in seconds to wait before processing duplicate events
        """
        super().__init__()
        self.debounce_time = debounce_time
        self.last_processed: dict[str, float] = {}
        self.debug = is_debug_enabled()
        self.context_files = {".ctx.architecture.xml", ".ctx.progress.xml", ".ctx.tasks.xml"}

    def _should_process_event(self, event: FileSystemEvent) -> bool:
        """Check if an event should be processed based on debouncing.

        Args:
            event: The file system event
        Returns:
            bool: True if event should be processed
        """
        # Only process context files
        file_name = Path(event.src_path).name
        if file_name not in self.context_files:
            if self.debug:
                logger.debug(f"Ignoring non-context file: {event.src_path}")
            return False

        current_time = time.time()
        event_key = f"{event.event_type}:{event.src_path}"

        # Check if this is a duplicate event within debounce time
        if event_key in self.last_processed:
            if current_time - self.last_processed[event_key] < self.debounce_time:
                if self.debug:
                    logger.debug(f"Debouncing event: {event_key}")
                return False

        self.last_processed[event_key] = current_time
        return True

    def on_modified(self, event: FileSystemEvent) -> None:
        """Handle file modification events."""
        if self.debug:
            logger.debug(f"Received modified event: {event.src_path}")

        if not self._should_process_event(event):
            return

        if self.debug:
            logger.debug(f"Processing modified event: {event.src_path}")

        try:
            _merge_rules_file()
            if self.debug:
                logger.debug("Successfully merged rules file")
        except Exception as e:
            logger.error(f"Error merging rules file: {e}")


class ContextFileMonitor:
    """Monitors .ctx files and updates rules files."""

    def __init__(self) -> None:
        """Initialize the context file monitor."""
        self.pm = get_path_manager()
        self.debug = is_debug_enabled()
        self.observer = None  # Initialize observer in start()
        self.handler = ContextFileHandler()

        # Directory containing .ctx files
        self.ctx_dir = self.pm.get_architecture_file().parent

        if self.debug:
            logger.debug(f"Initialized ContextFileMonitor watching: {self.ctx_dir}")

    def start(self) -> None:
        """Start monitoring context files."""
        try:
            if not self.ctx_dir.exists():
                if self.debug:
                    logger.debug(f"Creating context directory: {self.ctx_dir}")
                    self.ctx_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            logger.exception(f"Failed to create context directory: {e}")
            raise

        try:
            # Create a new observer each time we start
            self.observer = Observer()
            self.observer.schedule(self.handler, str(self.ctx_dir), recursive=False)
            self.observer.start()
            logger.info(f"Started monitoring context files in: {self.ctx_dir}")

            # Initial merge of rules
            if self.debug:
                logger.debug("Performing initial rules merge")
            _merge_rules_file()

        except Exception as e:
            logger.exception(f"Failed to start context file monitor")
            if self.observer and self.observer.is_alive():
                self.observer.stop()
                self.observer.join()
            raise

    def stop(self) -> None:
        """Stop monitoring context files."""
        if self.observer and self.observer.is_alive():
            if self.debug:
                logger.debug("Stopping context file monitor")
            self.observer.stop()
            self.observer.join()
            logger.info("Stopped monitoring context files")

    def __enter__(self) -> "ContextFileMonitor":
        """Start monitoring when entering context."""
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Stop monitoring when exiting context."""
        self.stop()

FileEventHandler = FileEventHandler
FileMonitorError = FileMonitorError
ContextFileHandler = ContextFileHandler

# context_commands.py
import typer
from loguru import logger

import xml.dom.minidom as minidom

import os
from rich.panel import Panel
import xml.etree.ElementTree as ET


context_manager = ContextManager()
console = get_console()
context_app = typer.Typer(help="Manage development contexts and their files.")


@context_app.command("get")
def get_context(name: str = typer.Argument(..., help="Name of the context to get")):
    """Get detailed information of a development context."""
    try:
        # Use display_context to print full details
        context_manager.display_context(name)
    except ContextError as e:
        # Extract underlying error if prefixed by display_context
        error_msg = str(e)
        prefix = "Failed to display context: "
        if error_msg.startswith(prefix):
            error_msg = error_msg[len(prefix) :]
        typer.echo(f"Error: Failed to get context: {error_msg}")
        raise typer.Exit(1)
    # Successful display
    raise typer.Exit(0)


def show_context_help_and_exit():
    """Show help menu and exit with error code."""
    command_rows = [
        ["erasmus context list", "List all contexts"],
        ["erasmus context create", "Create a new context"],
        ["erasmus context show", "Show context details"],
        ["erasmus context update", "Update context files"],
        ["erasmus context edit", "Edit context files"],
        ["erasmus context store", "Store the current context"],
        ["erasmus context select", "Select and load a context interactively"],
        ["erasmus context load", "Load a context by name to root .ctx XML files"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus context <command> --help")
    raise typer.Exit(1)


@context_app.callback(invoke_without_command=True)
def context_callback(ctx: typer.Context):
    """
    Manage development contexts and their files.
    """
    if ctx.invoked_subcommand is None:
        command_rows = [
            ["erasmus context list", "List all contexts"],
            ["erasmus context create", "Create a new context"],
            ["erasmus context show", "Show context details"],
            ["erasmus context update", "Update context files"],
            ["erasmus context edit", "Edit context files"],
            ["erasmus context store", "Store the current context"],
            ["erasmus context select", "Select and load a context interactively"],
            ["erasmus context load", "Load a context by name to root .ctx XML files"],
        ]
        print_table(["Command", "Description"], command_rows, title="Available Commands")
        typer.echo("\nFor more information about a command, run:")
        typer.echo("  erasmus context <command> --help")
        raise typer.Exit(0)


@context_app.command()
def create(name: str = typer.Argument(None, help="Name of the context to create")):
    """Create a new development context and display its path."""
    try:
        if not name:
            name = typer.prompt("Enter the context name")
        if not name:
            print_table(
                ["Error"],
                [["Context name is required."]],
                title="Context Creation Failed",
            )
            raise typer.Exit(1)
        context_path = context_manager.get_context_path(name)
        context_manager.create_context(name)
        # Retrieve created context model for path
        context = context_manager.get_context(name)
        # Display created context in a table
        context_rows = [[context_path]]
        print_table(["Context Path"], context_rows, title=f"Created Context: {name}")
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Creation Failed")
        raise typer.Exit(1)


@context_app.command()
def delete(name: str = typer.Argument(None, help="Name of the context to delete")):
    """Delete a context.

    This command permanently removes a context folder and its files.
    Use with caution as this action cannot be undone.
    """
    try:
        if not name:
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Deletion Failed",
                )
                raise typer.Exit(1)
            name = selected
        context_manager.delete_context(name)
        print_table(["Info"], [[f"Deleted context: {name}"]], title="Context Deleted")
        raise typer.Exit(0)
    except Exception as e:
        print_table(["Error"], [[str(e)]], title="Context Deletion Failed")
        raise typer.Exit(1)


@context_app.command()
def list():
    """List all development contexts.

    This command shows all available contexts and their basic information.
    Use 'show' to view detailed information about a specific context.
    """
    try:
        contexts = context_manager.list_contexts()
        if not contexts:
            print_table(["Info"], [["No contexts found"]], title="Available Contexts")
            return

        # Display contexts in a table
        context_rows = [[context] for context in contexts]
        print_table(["Context Name"], context_rows, title="Available Contexts")
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Listing Failed")
        show_context_help_and_exit()


def preview(text, lines=10):
    if not text:
        return ""
    split = text.splitlines()
    if len(split) > lines:
        return "\n".join(split[:lines]) + "\n..."
    return text


@context_app.command()
def show(name: str = typer.Argument(None, help="Name of the context to show")):
    """Show details of a development context.

    This command displays detailed information about a specific context,
    including file sizes and paths. If no name is supplied, it will prompt the user to select one.
    """
    try:
        if not name:
            # List available contexts and prompt for selection
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Show Failed",
                )
                raise typer.Exit(1)
            name = selected
        context_dir = context_manager.get_context_path(name)

        def read_context_file(context_dir, file_type):
            for ext in (".xml", ".md"):
                file_path = context_dir / f"ctx.{file_type}{ext}"
                if file_path.exists():
                    return file_path.read_text()
            return ""

        context_rows = [
            ["Path", str(context_dir)],
            ["Architecture", preview(read_context_file(context_dir, "architecture"))],
            ["Progress", preview(read_context_file(context_dir, "progress"))],
            ["Tasks", preview(read_context_file(context_dir, "tasks"))],
            ["Protocol", preview(read_context_file(context_dir, "protocol"))],
        ]
        print_table(
            ["Field", "Preview (first 10 lines)"],
            context_rows,
            title=f"Context: {name}",
        )
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Show Failed")
        show_context_help_and_exit()


@context_app.command()
def update(
    name: str = typer.Argument(None, help="Name of the context to update"),
    file_type: str = typer.Argument(
        None, help="Type of file to update (architecture, progress, tasks, protocol)"
    ),
    content: str = typer.Argument(None, help="Content to write to the file"),
):
    """Update a file in a development context.

    This command updates the content of a specific file in a context.
    The file type must be one of: architecture, progress, tasks, or protocol.
    """
    try:
        if not name:
            # List available contexts and prompt for selection
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Update Failed",
                )
                raise typer.Exit(1)
            name = selected
        if not file_type:
            file_type = typer.prompt(
                "Enter the file type to update (architecture, progress, tasks, protocol)"
            )
        if not file_type:
            print_table(
                ["Error"],
                [["File type is required for update."]],
                title="Context Update Failed",
            )
            raise typer.Exit(1)
        if content is None:
            content = typer.prompt(f"Enter the new content for {file_type}")
        if not content:
            print_table(
                ["Error"],
                [["Content is required for update."]],
                title="Context Update Failed",
            )
            raise typer.Exit(1)
        context_manager.update_file(name, file_type, content)
        print_table(
            ["Info"],
            [[f"Updated {file_type} in context: {name}"]],
            title="Context Updated",
        )
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Update Failed")
        show_context_help_and_exit()


@context_app.command()
def cat(
    name: str = typer.Argument(..., help="Name of the context"),
    file_type: str = typer.Argument(
        ..., help="Type of file to read (architecture, progress, tasks, protocol)"
    ),
):
    """Display the contents of a file in a development context.

    This command shows the raw contents of a specific file in a context.
    The file type must be one of: architecture, progress, tasks, or protocol.
    """
    try:
        content = context_manager.read_file(name, file_type)
        if content is None:
            print_table(
                ["Error"],
                [[f"File not found: {file_type}"]],
                title="Context Cat Failed",
            )
            logger.info("Available file types: architecture, progress, tasks, protocol")
            show_context_help_and_exit()

        # Pretty print XML for better readability
        try:
            # Parse the XML content
            dom = minidom.parseString(content)
            # Pretty print with indentation
            pretty_xml = dom.toprettyxml(indent="  ")
            print(pretty_xml)
        except Exception:
            # If XML parsing fails, print the raw content
            print(content)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Cat Failed")
        show_context_help_and_exit()


@context_app.command()
def edit(
    name: str = typer.Argument(None, help="Name of the context"),
    file_type: str = typer.Argument(
        None, help="Type of file to edit (architecture, progress, tasks, protocol)"
    ),
    editor: str = typer.Argument(None, help="Editor to use for editing"),
):
    """Edit a file in a development context.

    This command opens a file in your default editor (or specified editor).
    The file type must be one of: architecture, progress, tasks, or protocol.
    """
    if not name:
        # List available contexts and prompt for selection
        contexts = context_manager.list_contexts()
        if not contexts:
            print_table(["Info"], [["No contexts found"]], title="Available Contexts")
            raise typer.Exit(1)
        context_rows = [
            [str(index + 1), context_name] for index, context_name in enumerate(contexts)
        ]
        print_table(["#", "Context Name"], context_rows, title="Available Contexts")
        choice = typer.prompt("Select a context by number or name")
        selected = None
        if choice.isdigit():
            index = int(choice)
            if 1 <= index <= len(contexts):
                selected = contexts[index - 1]
        else:
            if choice in contexts:
                selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Context Edit Failed",
            )
            raise typer.Exit(1)
        name = selected
    if not file_type:
        file_type = typer.prompt(
            "Enter the file type to edit (architecture, progress, tasks, protocol)"
        )
    if not file_type:
        print_table(
            ["Error"],
            [["File type is required for edit."]],
            title="Context Edit Failed",
        )
        raise typer.Exit(1)
    context_dir = context_manager.get_context_path(name)
    file_path = None
    for ext in (".xml", ".md"):
        candidate = context_dir / f"ctx.{file_type}{ext}"
        if candidate.exists():
            file_path = candidate
            break
    if not file_path:
        print_table(
            ["Error"],
            [[f"File does not exist: {file_type}"]],
            title="Context Edit Failed",
        )
        raise typer.Exit(1)
    editor_cmd = editor or os.environ.get("EDITOR", "nano")
    os.system(f"{editor_cmd} {file_path}")
    print_table(
        ["Info"],
        [[f"Edited {file_type} in context: {name}"]],
        title="Context Edited",
    )
    raise typer.Exit(0)


def get_title_from_architecture() -> str | None:
    """Parse the title from the architecture file.

    Returns:
        The title if found, None otherwise.
    """
    try:
        arch_file = context_manager.pm.get_architecture_file()
        if not arch_file.exists():
            return None

        tree = ET.parse(arch_file)
        root = tree.getroot()

        # Try different possible paths to title
        title_paths = [
            ".//Title",  # Direct title tag
            ".//Architecture/Title",  # Under Architecture
            ".//Overview/Title",  # Under Overview
            ".//Architecture/Overview/Title",  # Full path
        ]

        for path in title_paths:
            title_elem = root.find(path)
            if title_elem is not None and title_elem.text:
                return title_elem.text.strip()

        return None
    except Exception:
        return None


@context_app.command()
def store(name: str = typer.Argument(None, help="Optional name to store the context under")):
    """Store the current context. If no name is provided, uses the title from architecture file or prompts for one."""
    try:
        # If name not provided, try to get from architecture
        if not name:
            name = get_title_from_architecture()

        # If still no name, prompt user
        if not name:
            name = typer.prompt("Enter a name for the context")

        if not name:
            console.print(
                Panel("Error: Context name is required", title="Context Store Failed", style="red")
            )
            show_context_help_and_exit()
            raise typer.Exit(1)

        context_manager.store_context(name)
        console.print(
            Panel(f"Context stored successfully as '{name}'", title="Context Store", style="green")
        )
    except Exception as e:
        console.print(Panel(f"Error\n{str(e)}", title="Context Store Failed", style="red"))
        show_context_help_and_exit()
        raise typer.Exit(1)


@context_app.command("load")
def load_context(name: str = typer.Argument(None, help="Name of the context to load")):
    """Load a stored context by name into the root .ctx XML files.

    If no name is supplied, you will be prompted to select one interactively.
    """
    try:
        if not name:
            # List available contexts and prompt for selection
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Load Failed",
                )
                raise typer.Exit(1)
            name = selected
        context_manager.load_context(name)
        print_table(["Info"], [[f"Loaded context: {name}"]], title="Context Loaded")
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Load Failed")
        raise typer.Exit(1)


@context_app.command("select")
def select_context():
    """Interactively select a context and load its XML files."""
    base_dir = context_manager.base_path
    # Gather available contexts
    try:
        contexts = sorted(
            [
                context_directory.name
                for context_directory in base_dir.iterdir()
                if context_directory.is_dir()
            ]
        )
    except Exception as exception:
        typer.echo(f"Error: Unable to list contexts: {exception}")
        raise typer.Exit(1)
    if not contexts:
        typer.echo("No contexts found to select.")
        raise typer.Exit(1)
    # Display contexts in a table
    context_rows = [[str(index + 1), context_name] for index, context_name in enumerate(contexts)]
    print_table(["#", "Context Name"], context_rows, title="Available Contexts")
    choice = typer.prompt("Select a context by number or name")
    # Determine selected context name
    selected = None
    if choice.isdigit():
        index = int(choice)
        if 1 <= index <= len(contexts):
            selected = contexts[index - 1]
    else:
        if choice in contexts:
            selected = choice
    if not selected:
        typer.echo(f"Error: Invalid selection: {choice}")
        raise typer.Exit(1)
    # Load the selected context
    try:
        context_manager.load_context(selected)
        typer.echo(f"Loaded context: {selected}")
        raise typer.Exit(0)
    except ContextError as exception:
        typer.echo(f"Error: Failed to load context: {exception}")
        raise typer.Exit(1)


def setup_callback(ctx: typer.Context):
    """Initialize the context manager and create initial context."""
    try:
        # Get path manager
        path_manager = get_path_manager()

        # Create erasmus directories
        erasmus_dir = path_manager.erasmus_dir
        context_dir = path_manager.context_dir
        protocol_dir = path_manager.protocol_dir
        template_dir = path_manager.template_dir

        erasmus_dir.mkdir(parents=True, exist_ok=True)
        context_dir.mkdir(parents=True, exist_ok=True)
        protocol_dir.mkdir(parents=True, exist_ok=True)
        template_dir.mkdir(parents=True, exist_ok=True)

        print_table(["Info"], [[f"Erasmus folders created in: {erasmus_dir}"]], title="Setup")

        # Create a template context in the context folder and update root .ctx.*.xml
        context_manager = ContextManager(base_path=str(context_dir))
        project_name = path_manager.root_dir.name
        context_manager.create_context(project_name)
        print_table(["Info"], [[f"Template context created: {project_name}"]], title="Setup")

        # Load the new context to root .ctx.*.xml files
        context_manager.load_context(project_name)
        print_table(["Info"], [[f"Context loaded: {project_name}"]], title="Setup")

    except Exception as e:
        print_table(["Error"], [[str(e)]], title="Setup Failed")
        raise typer.Exit(1)

get_context = get_context
show_context_help_and_exit = show_context_help_and_exit
context_callback = context_callback
create = create
delete = delete
list = list
preview = preview
show = show
update = update
cat = cat
edit = edit
get_title_from_architecture = get_title_from_architecture
store = store
load_context = load_context
select_context = select_context
setup_callback = setup_callback

# protocol_commands.py
import typer
from pathlib import Path
from loguru import logger


import os
import re

protocol_manager = ProtocolManager()
protocol_app = typer.Typer(help="Manage development protocols.")


def show_protocol_help_and_exit():
    """Show help menu and exit with error code."""
    command_rows = [
        ["erasmus protocol list", "List all protocols"],
        ["erasmus protocol create", "Create a new protocol"],
        ["erasmus protocol show", "Show protocol details"],
        ["erasmus protocol update", "Update a protocol"],
        ["erasmus protocol edit", "Edit a protocol"],
        ["erasmus protocol delete", "Delete a protocol"],
        ["erasmus protocol select", "Select and display a protocol"],
        ["erasmus protocol load", "Load a protocol as active"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Protocol Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus protocol <command> --help")
    raise typer.Exit(1)


@protocol_app.callback(invoke_without_command=True)
def protocol_callback(ctx: typer.Context):
    """
    Manage development protocols.
    """
    if ctx.invoked_subcommand is None:
        command_rows = [
            ["erasmus protocol list", "List all protocols"],
            ["erasmus protocol create", "Create a new protocol"],
            ["erasmus protocol show", "Show protocol details"],
            ["erasmus protocol update", "Update a protocol"],
            ["erasmus protocol edit", "Edit a protocol"],
            ["erasmus protocol delete", "Delete a protocol"],
            ["erasmus protocol select", "Select and display a protocol"],
            ["erasmus protocol load", "Load a protocol as active"],
        ]
        print_table(
            ["Command", "Description"],
            command_rows,
            title="Available Protocol Commands",
        )
        typer.echo("\nFor more information about a command, run:")
        typer.echo("  erasmus protocol <command> --help")
        raise typer.Exit(0)


@protocol_app.command()
def create(
    name: str = typer.Argument(None, help="Name of the protocol to create"),
    content: str = typer.Argument(None, help="Content of the protocol"),
):
    """Create a new protocol.

    This command creates a new protocol file with optional content.
    The protocol name will be sanitized to ensure it's safe for filesystem operations.
    """
    try:
        if not name:
            name = typer.prompt("Enter the protocol name")
        if not name:
            print_table(
                ["Error"],
                [["Protocol name is required."]],
                title="Protocol Creation Failed",
            )
            raise typer.Exit(1)
        if content is None:
            content = typer.prompt("Enter the protocol content (leave blank to use template)")
        protocol_manager.create_protocol(name, content)
        logger.info(f"Created protocol: {name}")
        print_table(["Info"], [[f"Created protocol: {name}"]], title="Protocol Created")
        raise typer.Exit(0)
    except ProtocolError as e:
        logger.error(f"Failed to create protocol: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def update(
    name: str = typer.Argument(None, help="Name of the protocol to update"),
    content: str = typer.Argument(None, help="New content for the protocol"),
):
    """Update an existing protocol.

    This command updates the content of an existing protocol.
    The protocol must exist before it can be updated.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Update Failed",
                )
                raise typer.Exit(1)
            name = selected
        if content is None:
            content = typer.prompt("Enter the new protocol content")
        if not content:
            print_table(
                ["Error"],
                [["Protocol content is required."]],
                title="Protocol Update Failed",
            )
            raise typer.Exit(1)
        protocol_manager.update_protocol(name, content)
        logger.info(f"Updated protocol: {name}")
        print_table(["Info"], [[f"Updated protocol: {name}"]], title="Protocol Updated")
        raise typer.Exit(0)
    except ProtocolError as e:
        logger.error(f"Failed to update protocol: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def delete(name: str = typer.Argument(None, help="Name of the protocol to delete")):
    """Delete a protocol.

    This command permanently removes a protocol file.
    Use with caution as this action cannot be undone.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Deletion Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol_manager.delete_protocol(name)
        logger.info(f"Deleted protocol: {name}")
        print_table(["Info"], [[f"Deleted protocol: {name}"]], title="Protocol Deleted")
        raise typer.Exit(0)
    except (ProtocolError, PermissionError, FileNotFoundError) as e:
        print_table(["Error"], [[str(e)]], title="Protocol Deletion Failed")
        raise typer.Exit(1)


@protocol_app.command()
def list():
    """List all protocols.

    This command shows all available protocols and their basic information.
    Use 'show' to view detailed information about a specific protocol.
    """
    try:
        protocols = protocol_manager.list_protocols()
        if not protocols:
            typer.echo("No protocols found")
            return

        # Display protocols in a table
        protocol_rows = [[protocol] for protocol in protocols]
        print_table(["Protocol Name"], protocol_rows, title="Available Protocols")
    except ProtocolError as e:
        logger.error(f"Failed to list protocols: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def show(name: str = typer.Argument(None, help="Name of the protocol to show")):
    """Show details of a protocol.

    This command displays detailed information about a specific protocol,
    including its content and metadata.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Show Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Show Failed",
            )
            raise typer.Exit(1)
        print_table(["Info"], [[f"Protocol: {name}"]], title="Protocol Details")
        typer.echo(f"Path: {protocol.path}")
        typer.echo(f"Content:\n{protocol.content}")
        raise typer.Exit(0)
    except ProtocolError as e:
        print_table(["Error"], [[str(e)]], title="Protocol Show Failed")
        raise typer.Exit(1)


@protocol_app.command("select")
def select_protocol():
    """Interactively select a protocol, display its details, and update the rules file with it."""
    try:
        protocols = protocol_manager.list_protocols()
        if not protocols:
            print_table(["Info"], [["No protocols found"]], title="Available Protocols")
            raise typer.Exit(1)
        protocol_rows = [
            [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
        ]
        print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            index = int(choice)
            if 1 <= index <= len(protocols):
                selected = protocols[index - 1]
        else:
            if choice in protocols:
                selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        protocol = protocol_manager.get_protocol(selected)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {selected}"]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        print_table(["Info"], [[f"Selected protocol: {selected}"]], title="Protocol Selected")
        typer.echo(f"Path: {protocol.path}")
        typer.echo(f"Content:\n{protocol.content}")
        # Write the selected protocol name to .erasmus/current_protocol.txt


        path_manager = get_path_manager()
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        current_protocol_path.write_text(selected)
        # Also update the rules file as in load
        template_path = path_manager.template_dir / "meta_rules.xml"
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.xml template not found."]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        meta_rules_content = template_path.read_text()
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        meta_rules_content = meta_rules_content.replace(
            "<!--ARCHITECTURE-->\n  <!--/ARCHITECTURE-->", architecture
        )
        meta_rules_content = meta_rules_content.replace(
            "<!--PROGRESS-->\n  <!--/PROGRESS-->", progress
        )
        meta_rules_content = meta_rules_content.replace("<!--TASKS-->\n  <!--/TASKS-->", tasks)
        meta_rules_content = meta_rules_content.replace(
            "<!--PROTOCOL-->\n  <!--/PROTOCOL-->", protocol.content
        )
        rules_file = path_manager.get_rules_file()
        if not rules_file:
            print_table(
                ["Error"],
                [["No rules file configured."]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Updated rules file with protocol: {selected}"]],
            title="Rules File Updated",
        )
        raise typer.Exit(0)
    except ProtocolError as exception:
        print_table(["Error"], [[str(exception)]], title="Protocol Select Failed")
        raise typer.Exit(1)


@protocol_app.command("load")
def load_protocol(
    name: str = typer.Argument(None, help="Name of the protocol to load"),
):
    """Interactively select and load a protocol, merging it into the rules file with current context."""
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Load Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Load Failed",
            )
            raise typer.Exit(1)
        # Write the selected protocol name to .erasmus/current_protocol.txt


        path_manager = get_path_manager()
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        current_protocol_path.write_text(name)
        # Load meta_rules.xml template
        template_path = path_manager.template_dir / "meta_rules.xml"
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.xml template not found."]],
                title="Protocol Load Failed",
            )
            raise typer.Exit(1)
        meta_rules_content = template_path.read_text()
        # Read current context files
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        # Replace context and protocol blocks using regex for robustness
        meta_rules_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            meta_rules_content,
        )
        meta_rules_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, meta_rules_content
        )
        meta_rules_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, meta_rules_content)
        meta_rules_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->",
            protocol.content,
            meta_rules_content,
        )
        # Write to rules file
        rules_file = path_manager.get_rules_file()
        if not rules_file:
            print_table(["Error"], [["No rules file configured."]], title="Protocol Load Failed")
            raise typer.Exit(1)
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Loaded protocol: {name} into rules file"]],
            title="Protocol Loaded",
        )
        raise typer.Exit(0)
    except ProtocolError as exception:
        print_table(["Error"], [[str(exception)]], title="Protocol Load Failed")
        raise typer.Exit(1)


@protocol_app.command()
def edit(
    name: str = typer.Argument(None, help="Name of the protocol to edit"),
    editor: str = typer.Argument(None, help="Editor to use for editing"),
):
    """Edit a protocol file in your default editor (or specified editor)."""
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Edit Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Edit Failed",
            )
            raise typer.Exit(1)
        file_path = protocol.path
        editor_cmd = editor or os.environ.get("EDITOR", "nano")
        os.system(f"{editor_cmd} {file_path}")
        print_table(["Info"], [[f"Edited protocol: {name}"]], title="Protocol Edited")
        raise typer.Exit(0)
    except ProtocolError as error:
        print_table(["Error"], [[str(error)]], title="Protocol Edit Failed")
        raise typer.Exit(1)


@protocol_app.command("watch")
def watch_protocol():
    """Monitor .ctx.*.xml files for changes and update the rules file with the current protocol. Does NOT monitor the rules file itself."""
    import time




    path_manager = get_path_manager()
    protocol_manager = ProtocolManager()
    ctx_files = [
        path_manager.get_architecture_file(),
        path_manager.get_progress_file(),
        path_manager.get_tasks_file(),
    ]
    template_path = path_manager.template_dir / "meta_rules.xml"
    rules_file = path_manager.get_rules_file()
    current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"

    def get_protocol_name():
        if current_protocol_path.exists():
            return current_protocol_path.read_text().strip()
        protocols = protocol_manager.list_protocols()
        if not protocols:
            print_table(["Error"], [["No protocols found."]], title="Protocol Watch Failed")
            raise typer.Exit(1)
        protocol_rows = [[str(i + 1), p] for i, p in enumerate(protocols)]
        print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            idx = int(choice)
            if 1 <= idx <= len(protocols):
                selected = protocols[idx - 1]
        elif choice in protocols:
            selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Protocol Watch Failed",
            )
            raise typer.Exit(1)
        current_protocol_path.write_text(selected)
        return selected

    def merge_and_write():
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.xml template not found."]],
                title="Protocol Watch Failed",
            )
            return
        meta_rules_content = template_path.read_text()
        architecture = ctx_files[0].read_text() if ctx_files[0].exists() else ""
        progress = ctx_files[1].read_text() if ctx_files[1].exists() else ""
        tasks = ctx_files[2].read_text() if ctx_files[2].exists() else ""
        meta_rules_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            meta_rules_content,
        )
        meta_rules_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, meta_rules_content
        )
        meta_rules_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, meta_rules_content)
        protocol_name = get_protocol_name()
        protocol = protocol_manager.get_protocol(protocol_name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {protocol_name}"]],
                title="Protocol Watch Failed",
            )
            return
        meta_rules_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->",
            protocol.content,
            meta_rules_content,
        )
        if not rules_file:
            print_table(
                ["Error"],
                [["No rules file configured."]],
                title="Protocol Watch Failed",
            )
            return
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Rules file updated with protocol: {protocol_name}"]],
            title="Rules File Updated",
        )

    # Track last modification times for only the .ctx.*.xml files
    last_mtimes = [f.stat().st_mtime if f.exists() else 0 for f in ctx_files]
    print_table(["Info"], [["Watching .ctx.*.xml files for changes..."]], title="Protocol Watch")
    try:
        while True:
            changed = False
            for i, f in enumerate(ctx_files):
                if f.exists():
                    mtime = f.stat().st_mtime
                    if mtime != last_mtimes[i]:
                        changed = True
                        last_mtimes[i] = mtime
            if changed:
                merge_and_write()
            time.sleep(1)
    except KeyboardInterrupt:
        print_table(["Info"], [["Stopped watching context files."]], title="Protocol Watch")



show_protocol_help_and_exit = show_protocol_help_and_exit
protocol_callback = protocol_callback
create = create
update = update
delete = delete
list = list
show = show
select_protocol = select_protocol
load_protocol = load_protocol
edit = edit
watch_protocol = watch_protocol

# setup_commands.py
import typer
from pathlib import Path



setup_app = typer.Typer(help="Setup Erasmus: initialize project, environment, and context.")

console = get_console()


def set_erasmus_path():
    import os

    shell = os.environ.get("SHELL", "").split("/")[-1]
    home = str(Path.home())
    added = False
    msg = ""
    erasmus_func = """erasmus() {
    if [ -f erasmus.py ]; then
        uv run erasmus.py "$@"
    else
        command erasmus "$@"
    fi
}"""
    erasmus_fish_func = """function erasmus
    if test -f erasmus.py
        uv run erasmus.py $argv
    else
        command erasmus $argv
    end
end"""
    if shell == "bash":
        rc = f"{home}/.bashrc"
        if not Path(rc).read_text(errors="ignore").find("erasmus()") >= 0:
            with open(rc, "a") as f:
                f.write(f"\n{erasmus_func}\n")
            msg = f"Added erasmus function to {rc}"
            added = True
    elif shell == "zsh":
        rc = f"{home}/.zshrc"
        if not Path(rc).read_text(errors="ignore").find("erasmus()") >= 0:
            with open(rc, "a") as f:
                f.write(f"\n{erasmus_func}\n")
            msg = f"Added erasmus function to {rc}"
            added = True
    elif shell == "fish":
        rc = f"{home}/.config/fish/config.fish"
        if not Path(rc).read_text(errors="ignore").find("function erasmus") >= 0:
            with open(rc, "a") as f:
                f.write(f"\n{erasmus_fish_func}\n")
            msg = f"Added erasmus function to {rc}"
            added = True
    elif shell in ("csh", "tcsh"):
        rc = f"{home}/.cshrc" if shell == "csh" else f"{home}/.tcshrc"
        if not Path(rc).read_text(errors="ignore").find("alias erasmus") >= 0:
            with open(rc, "a") as f:
                f.write(
                    '\nalias erasmus "if ( -f erasmus.py ) uv run erasmus.py !*; else command erasmus !*; endif"\n'
                )
            msg = f"Added erasmus alias to {rc}"
            added = True
    else:
        msg = f"Unsupported shell: {shell}. Please add the erasmus function to your shell rc file manually."
    if added:
        print(msg)
    else:
        print(msg or "erasmus function/alias already present in your shell rc file.")


@setup_app.callback(invoke_without_command=True)
def setup_callback(ctx: typer.Context):
    if ctx.invoked_subcommand is not None:
        return
    """Interactive setup for Erasmus: configure IDE, project, context, and protocol."""
    # Step 1: Use path manager for IDE detection and prompting
    path_manager = get_path_manager()
    print_table(["Info"], [[f"IDE detected: {path_manager.ide.name}"]], title="Setup")

    # Step 2: Prompt for project name
    project_name = typer.prompt("Enter the project name")
    if not project_name:
        print_table(["Error"], [["Project name is required."]], title="Setup Failed")
        raise typer.Exit(1)

    # Step 3: Create project directory and context using path manager
    project_dir = Path.cwd() / project_name
    project_dir.mkdir(parents=True, exist_ok=True)
    print_table(["Info"], [[f"Project directory created: {project_dir}"]], title="Setup")

    # Step 4: Use path manager for all Erasmus folders inside project
    erasmus_dir = path_manager.erasmus_dir
    context_dir = path_manager.context_dir
    protocol_dir = path_manager.protocol_dir
    template_dir = path_manager.template_dir
    for d in [erasmus_dir, context_dir, protocol_dir, template_dir]:
        d.mkdir(parents=True, exist_ok=True)
    print_table(["Info"], [[f"Erasmus folders created in: {erasmus_dir}"]], title="Setup")

    # Step 5: Create a template context in the context folder and update root .ctx.*.xml files
    context_manager = ContextManager(base_path=str(context_dir))
    context_manager.create_context(project_name)
    print_table(["Info"], [[f"Template context created: {project_name}"]], title="Setup")
    # Load the new context to root .ctx.*.xml files
    context_manager.load_context(project_name)
    set_erasmus_path()
    print_table(
        ["Info"],
        [[f"Root .ctx.*.xml files updated for: {project_name}"]],
        title="Setup",
    )

    # Step 6: Prompt for protocol selection
    protocol_manager = ProtocolManager()
    protocols = protocol_manager.list_protocols()
    if not protocols:
        print_table(["Error"], [["No protocols found."]], title="Setup Failed")
        raise typer.Exit(1)
    protocol_rows = [[str(i + 1), p] for i, p in enumerate(protocols)]
    print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
    while True:
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            idx = int(choice)
            if 1 <= idx <= len(protocols):
                selected = protocols[idx - 1]
        elif choice in protocols:
            selected = choice
        if selected:
            # Write the selected protocol to current_protocol.txt using path manager
            current_protocol_path = path_manager.erasmus_dir / "current_protocol.txt"
            current_protocol_path.write_text(selected)
            print_table(["Info"], [[f"Protocol set to: {selected}"]], title="Setup")
            # Immediately update the rules file to reflect the selected protocol
            try:


                _merge_rules_file()
                print_table(
                    ["Info"],
                    [[f"Rules file updated with protocol: {selected}"]],
                    title="Setup",
                )
            except Exception as e:
                print_table(
                    ["Error"],
                    [[f"Failed to update rules file: {e}"]],
                    title="Setup Warning",
                )
            break
        print(f"Invalid selection: {choice}")

    print_table(["Info"], [["Erasmus setup complete."]], title="Setup Success")
    raise typer.Exit(0)

set_erasmus_path = set_erasmus_path
setup_callback = setup_callback

# main.py
import typer



app = typer.Typer(
    help="Erasmus - Development Context Management System\n\nA tool for managing development contexts, protocols, and Model Context Protocol (MCP) interactions.\n\nFor more information, visit: https://github.com/hydra-dynamics/erasmus"
)

# Add sub-commands
app.add_typer(context_app, name="context", help="Manage development contexts")
app.add_typer(protocol_app, name="protocol", help="Manage protocols")
app.add_typer(setup_app, name="setup", help="Setup Erasmus")
app.add_typer(
    mcp_app, name="mcp", help="Manage MCP servers, clients, and integrations (including GitHub)"
)


# Custom error handler for unknown commands and argument errors
def print_main_help_and_exit():
    try:
        from rich.console import Console

        console = Console()
        banner = [
            ("green", " _____                                  "),
            ("green", "|  ___|                                 "),
            ("cyan", "| |__ _ __ __ _ ___ _ __ ___  _   _ ___ "),
            ("green", "|  __| '__/ _` / __| '_ ` _ \\| | | / __|"),
            ("cyan", "| |__| | | (_| \\__ \\ | | | | | |_| \\__ \\"),
            ("green", "\\____/_|  \\__,_|___/_| |_| |_|\\__,_|___/"),
        ]
        for color, line in banner:
            console.print(line, style=color)
    except ImportError:
        # Fallback to plain text if rich is not available
        typer.echo(r"""
 _____                                  
|  ___|                                 
| |__ _ __ __ _ ___ _ __ ___  _   _ ___ 
|  __| '__/ _` / __| '_ ` _ \| | | / __|
| |__| | | (_| \__ \ | | | | | |_| \__ \
\____/_|  \__,_|___/_| |_| |_|\__,_|___/
""")
    typer.echo("\n Development Context Management System\n")
    command_rows = [
        ["erasmus context", "Manage development contexts"],
        ["erasmus protocol", "Manage protocols"],
        ["erasmus setup", "Setup Erasmus"],
        ["erasmus watch", "Watch for .ctx file changes"],
        ["erasmus status", "Show current status"],
        ["erasmus version", "Show Erasmus version"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Erasmus Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus <command> --help")
    raise typer.Exit(1)


@app.callback(invoke_without_command=True)
def main(ctx: typer.Context):
    """
    Erasmus - Development Context Management System
    """
    if ctx.invoked_subcommand is None:
        print_main_help_and_exit()


# Patch Typer's error handling to show help on unknown command
from typer.main import get_command
from typer.core import TyperGroup
from click import UsageError

original_command = get_command(app)


class HelpOnErrorGroup(TyperGroup):
    def main(self, *args, **kwargs):
        try:
            return super().main(*args, **kwargs)
        except UsageError as e:
            typer.echo(str(e))
            print_main_help_and_exit()


app.command_class = HelpOnErrorGroup


@app.command()
def watch():  # pragma: no cover
    """Watch for changes to .ctx files and update the IDE rules file automatically.

    Press Ctrl+C to stop watching.
    """
    import time


    pm = get_path_manager()
    root = pm.get_root_dir()
    monitor = FileMonitor()
    monitor.start()
    typer.echo(f"Watching {root} for .ctx file changes (Ctrl+C to stop)...")
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        monitor.stop()
        typer.echo("Stopped watching.")


@app.command()
def status():
    """Show the current Erasmus context and protocol status."""



    import os

    context_manager = ContextManager()
    protocol_manager = ProtocolManager()

    # Current context (from .erasmus/current_context.txt if exists)
    current_context = None
    current_context_path = os.path.join(context_manager.base_dir.parent, "current_context.txt")
    if os.path.exists(current_context_path):
        with open(current_context_path) as f:
            current_context = f.read().strip()

    # List all contexts
    try:
        contexts = context_manager.list_contexts()
    except Exception as e:
        contexts = []

    # List all protocols
    try:
        protocols = protocol_manager.list_protocols()
    except Exception as e:
        protocols = []

    print_table(
        ["Status", "Value"],
        [
            ["Current Context", current_context or "(none set)"],
            ["Available Contexts", ", ".join(contexts) if contexts else "(none)"],
            ["Available Protocols", ", ".join(protocols) if protocols else "(none)"],
        ],
        title="Erasmus Status",
    )


@app.command()
def version():
    """Show the Erasmus version."""


    typer.echo(f"Erasmus version: {erasmus.__version__}")




if __name__ == '__main__':
    app()
