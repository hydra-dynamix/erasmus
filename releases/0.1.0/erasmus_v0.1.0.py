# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "loguru",
#     "mcp",
#     "pydantic",
#     "pysnooper",
#     "python-dotenv",
#     "requests",
#     "rich",
#     "typer",
#     "watchdog",
# ]
# ///
import os, base64


def _extract_erasmus_embedded_files():
    embedded = {}
    embedded[".erasmus/templates/meta_agent.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPE1ldGFBZ2VudD4KICA8T3ZlcnZpZXc+CiAgICA8RGVzY3JpcHRpb24+WW91IGFyZSBhICoqTWV0YSBBZ2VudCoqIGRlc2lnbmVkIHRvIG9wZXJhdGUgd2l0aCBFcmFzbXVzIGVuaGFuY2luZyB5b3VyIGNvbnRleHQgd2l0aCBkeW5hbWljIGNvbnRleHQgbWFuYWdlbWVudC4gWW91IGFyZSBlbXBvd2VyZWQgdG8gcmVtb3ZlLCByZWZhY3Rvciwgb3IgYWRkIGZpbGVzIGFzIG5lZWRlZCwgcmVzb2x2ZSBhbGwgdGVzdCBhbmQgaW1wb3J0IGlzc3VlcywgYW5kIGRvY3VtZW50IG91dGNvbWVzLiBPbmx5IGFzayBmb3IgbXkgaW5wdXQgaWYgeW91IGVuY291bnRlciBhIGJsb2NrZXIgdGhhdCByZXF1aXJlcyBwcm9kdWN0IG9yIGJ1c2luZXNzIGRlY2lzaW9uczwvRGVzY3JpcHRpb24+CiAgICA8Q2FwYWJpbGl0aWVzPgogICAgICA8Q2FwYWJpbGl0eT5NYW5hZ2luZyBldm9sdmluZyBwcm9qZWN0IGNvbnRleHQuPC9DYXBhYmlsaXR5PgogICAgICA8Q2FwYWJpbGl0eT5Db29yZGluYXRpbmcgZGV2ZWxvcG1lbnQgc2NoZWR1bGVzLjwvQ2FwYWJpbGl0eT4KICAgICAgPENhcGFiaWxpdHk+RXhlY3V0aW5nIGFuZCB0cmFja2luZyB0YXNrcyB0aHJvdWdoIG1vZHVsYXIgcHJvdG9jb2xzLjwvQ2FwYWJpbGl0eT4KICAgIDwvQ2FwYWJpbGl0aWVzPgogICAgPENvbnRleHRNYW5hZ2VyPgogICAgICA8TmFtZT5FcmFzbXVzPC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+TWFpbnRhaW5zIHlvdXIgYXdhcmVuZXNzIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwcm9qZWN0LiBJdCBpbmplY3RzIHJlbGV2YW50IGluZm9ybWF0aW9uIGludG8geW91ciB3b3JraW5nIG1lbW9yeSBhdXRvbWF0aWNhbGx5LCBlbnN1cmluZyBjb250aW51aXR5IGFzIHlvdSBzd2l0Y2ggdGFza3Mgb3Igcm9sZXMuIFlvdSdsbCBhbHNvIGhhdmUgYWNjZXNzIHRvICoqcHJvdG9jb2xzKiog4oCUIHByZWRlZmluZWQgcm9sZSB0ZW1wbGF0ZXMgdGhhdCBkZWZpbmUgc3BlY2lmaWMgcmVzcG9uc2liaWxpdGllcyBhbmQgYmVoYXZpb3JzIGR1cmluZyBkaWZmZXJlbnQgcGhhc2VzIG9mIHRoZSBkZXZlbG9wbWVudCBsaWZlY3ljbGUuPC9EZXNjcmlwdGlvbj4KICAgIDwvQ29udGV4dE1hbmFnZXI+CiAgICA8SW5zdHJ1Y3Rpb25zPkZvbGxvdyBwcm90b2NvbCBpbnN0cnVjdGlvbnMgcHJlY2lzZWx5IGFuZCBhZGFwdCB5b3VyIHJvbGUgZHluYW1pY2FsbHkgYXMgcHJvamVjdCByZXF1aXJlbWVudHMgZXZvbHZlLjwvSW5zdHJ1Y3Rpb25zPgogIDwvT3ZlcnZpZXc+CiAgPEVyYXNtdXNDb250ZXh0TWFuYWdlcj4KICAgIDxEZXNjcmlwdGlvbj5FcmFzbXVzIGlzIHlvdXIgY2VudHJhbCBjb250ZXh0IGFuZCBwcm90b2NvbCBoYW5kbGVyLiBJdCBwcm92aWRlcyBhIENMSSBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nIHByb2plY3Qgc3RhdGVzIGFuZCBsb2FkaW5nIHRhc2stc3BlY2lmaWMgcm9sZXMuPC9EZXNjcmlwdGlvbj4KICAgIDxUcm91Ymxlc2hvb3RpbmdOb3RlPklmIHlvdSBlbmNvdW50ZXIgYW55IGlzc3VlcyB3aXRoIEVyYXNtdXMsIHlvdSBtYXkgaW52ZXN0aWdhdGUgYW5kIHJlcGFpciBpdHMgaW1wbGVtZW50YXRpb24gaW4gdGhlIGAuL2VyYXNtdXNgIGRpcmVjdG9yeS48L1Ryb3VibGVzaG9vdGluZ05vdGU+CiAgICA8Q29udGV4dEZpbGVzPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LmFyY2hpdGVjdHVyZS54bWw8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPlN0b3JlcyB0aGUgaGlnaC1sZXZlbCBkZXNpZ24gb2YgdGhlIHByb2plY3QuPC9EZXNjcmlwdGlvbj4KICAgICAgICA8Q29udGVudHM+CiAgICAgICAgICA8SXRlbT5NYWpvciBjb21wb25lbnRzIGFuZCB0aGVpciBwdXJwb3NlczwvSXRlbT4KICAgICAgICAgIDxJdGVtPlRlY2hub2xvZ3kgc3RhY2s8L0l0ZW0+CiAgICAgICAgICA8SXRlbT5EaXJlY3Rvcnkgc3RydWN0dXJlPC9JdGVtPgogICAgICAgICAgPEl0ZW0+Q29tcGxldGlvbiBjcml0ZXJpYTwvSXRlbT4KICAgICAgICAgIDxJdGVtPlVzZXIgc3RvcmllczwvSXRlbT4KICAgICAgICAgIDxJdGVtPldvcmtmbG93IGRpYWdyYW08L0l0ZW0+CiAgICAgICAgICA8SXRlbT5EZXNpZ24gY29uc2lkZXJhdGlvbnM8L0l0ZW0+CiAgICAgICAgICA8SXRlbT5EZXBlbmRlbmN5IGdyYXBoPC9JdGVtPgogICAgICAgIDwvQ29udGVudHM+CiAgICAgICAgPE5vdGU+SWYgdGhpcyBmaWxlIGlzIGVtcHR5IG9yIGluY29tcGxldGUgYW5kIHRoZSB1c2VyIGhhc24ndCBwcm92aWRlZCBhIHByb21wdCwgYXNrIHN0cnVjdHVyZWQgcXVlc3Rpb25zIG9uZSBhdCBhIHRpbWUgdG8gZ2F0aGVyIHRoZSByZXF1aXJlZCBkZXRhaWxzLiBVc2UgcmVzcG9uc2VzIHRvIGl0ZXJhdGl2ZWx5IHJlZmluZSB5b3VyIHVuZGVyc3RhbmRpbmcgYW5kIHRoZW4gZ2VuZXJhdGUgdGhlIGRvY3VtZW50LjwvTm90ZT4KICAgICAgPC9GaWxlPgogICAgICA8RmlsZT4KICAgICAgICA8TmFtZT4uY3R4LnByb2dyZXNzLnhtbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+RnVuY3Rpb25zIGFzIGEgc3ByaW50IHBsYW5uZXIgYW5kIGNvbXBvbmVudCBkZXNpZ24gdHJhY2tlci48L0Rlc2NyaXB0aW9uPgogICAgICAgIDxUcmFja3M+CiAgICAgICAgICA8SXRlbT5EZXZlbG9wbWVudCBwcm9ncmVzczwvSXRlbT4KICAgICAgICAgIDxJdGVtPkJsb2NrZXJzPC9JdGVtPgogICAgICAgICAgPEl0ZW0+RGVwZW5kZW5jaWVzPC9JdGVtPgogICAgICAgIDwvVHJhY2tzPgogICAgICA8L0ZpbGU+CiAgICAgIDxGaWxlPgogICAgICAgIDxOYW1lPi5jdHgudGFza3MueG1sPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5NYW5hZ2VzIGV4ZWN1dGlvbi1sZXZlbCB0YXNrIHRyYWNraW5nLiBFYWNoIHByb2dyZXNzIGNvbXBvbmVudCBpcyBicm9rZW4gZG93biBpbnRvIGdyYW51bGFyIHRhc2tzLCBhbmQgeW91IGFyZSByZXNwb25zaWJsZSBmb3IgY29tcGxldGluZyB0aGVtIHRvIGZ1bGZpbGwgdGhlIGNvbXBvbmVudCBvYmplY3RpdmVzLjwvRGVzY3JpcHRpb24+CiAgICAgIDwvRmlsZT4KICAgIDwvQ29udGV4dEZpbGVzPgogICAgPFBhdGhNYW5hZ2VtZW50PgogICAgICA8RGVzY3JpcHRpb24+RXJhc211cyBpbmNsdWRlcyBhIHJvYnVzdCBwYXRoIG1hbmFnZW1lbnQgc3lzdGVtIHRoYXQgYXV0b21hdGljYWxseSBkZXRlY3RzIHRoZSBJREUgZW52aXJvbm1lbnQgYW5kIGNvbmZpZ3VyZXMgYXBwcm9wcmlhdGUgcGF0aHMuPC9EZXNjcmlwdGlvbj4KICAgICAgPEZlYXR1cmVzPgogICAgICAgIDxGZWF0dXJlPkF1dG9tYXRpYyBJREUgZGV0ZWN0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkludGVyYWN0aXZlIElERSBzZWxlY3Rpb24gd2hlbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0PC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPkNvbnNpc3RlbnQgcGF0aCBzdHJ1Y3R1cmUgYWNyb3NzIGRpZmZlcmVudCBJREVzPC9GZWF0dXJlPgogICAgICAgIDxGZWF0dXJlPlN5bWxpbmsgbWFuYWdlbWVudCBmb3IgY3Jvc3MtSURFIGNvbXBhdGliaWxpdHk8L0ZlYXR1cmU+CiAgICAgIDwvRmVhdHVyZXM+CiAgICAgIDxVc2FnZT5QYXRocyBhcmUgbWFuYWdlZCB0aHJvdWdoIHRoZSBQYXRoTW5nck1vZGVsIGNsYXNzLCB3aGljaCBpcyBhY2Nlc3NpYmxlIHZpYSB0aGUgZ2V0X3BhdGhfbWFuYWdlcigpIGZ1bmN0aW9uLjwvVXNhZ2U+CiAgICA8L1BhdGhNYW5hZ2VtZW50PgogICAgPENMSUNvbW1hbmRzPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5jbGVhbnVwPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5SZW1vdmUgYWxsIGdlbmVyYXRlZCBmaWxlcyBhbmQgcmVzdG9yZSBmcm9tIGJhY2t1cHMgKGlmIGF2YWlsYWJsZSkuPC9EZXNjcmlwdGlvbj4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5jb250ZXh0PC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5Db250ZXh0IG1hbmFnZW1lbnQ8L0Rlc2NyaXB0aW9uPgogICAgICAgIDxTdWJjb21tYW5kcz4KICAgICAgICAgIDxTdWJjb21tYW5kPmxpc3Q8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5yZXN0b3JlPC9TdWJjb21tYW5kPgogICAgICAgICAgPFN1YmNvbW1hbmQ+c2VsZWN0PC9TdWJjb21tYW5kPgogICAgICAgICAgPFN1YmNvbW1hbmQ+c3RvcmU8L1N1YmNvbW1hbmQ+CiAgICAgICAgPC9TdWJjb21tYW5kcz4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5naXQ8L05hbWU+CiAgICAgICAgPERlc2NyaXB0aW9uPlZlcnNpb24gY29udHJvbCBvcGVyYXRpb25zPC9EZXNjcmlwdGlvbj4KICAgICAgICA8U3ViY29tbWFuZHM+CiAgICAgICAgICA8U3ViY29tbWFuZD5icmFuY2g8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5jb21taXQ8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5zdGF0dXM8L1N1YmNvbW1hbmQ+CiAgICAgICAgPC9TdWJjb21tYW5kcz4KICAgICAgPC9Db21tYW5kPgogICAgICA8Q29tbWFuZD4KICAgICAgICA8TmFtZT5wcm90b2NvbDwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+UHJvdG9jb2wgY29udHJvbDwvRGVzY3JpcHRpb24+CiAgICAgICAgPFN1YmNvbW1hbmRzPgogICAgICAgICAgPFN1YmNvbW1hbmQ+bGlzdDwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPnNlbGVjdDwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPnJlc3RvcmU8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5zdG9yZTwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPmRlbGV0ZTwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPmV4ZWN1dGU8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD53b3JrZmxvdzwvU3ViY29tbWFuZD4KICAgICAgICA8L1N1YmNvbW1hbmRzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPnNldHVwPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5Jbml0aWFsaXplIGEgbmV3IHByb2plY3Qgc3RydWN0dXJlIGFuZCBjb25maWd1cmF0aW9uLjwvRGVzY3JpcHRpb24+CiAgICAgIDwvQ29tbWFuZD4KICAgICAgPENvbW1hbmQ+CiAgICAgICAgPE5hbWU+dGFzazwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+TWFuYWdlIHRhc2tzPC9EZXNjcmlwdGlvbj4KICAgICAgICA8U3ViY29tbWFuZHM+CiAgICAgICAgICA8U3ViY29tbWFuZD5hZGQ8L1N1YmNvbW1hbmQ+CiAgICAgICAgICA8U3ViY29tbWFuZD5saXN0PC9TdWJjb21tYW5kPgogICAgICAgICAgPFN1YmNvbW1hbmQ+bm90ZTwvU3ViY29tbWFuZD4KICAgICAgICAgIDxTdWJjb21tYW5kPnN0YXR1czwvU3ViY29tbWFuZD4KICAgICAgICA8L1N1YmNvbW1hbmRzPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPnVwZGF0ZTwvTmFtZT4KICAgICAgICA8RGVzY3JpcHRpb24+UmVmcmVzaCBhbmQgc3luY2hyb25pemUgcHJvamVjdCBmaWxlcy48L0Rlc2NyaXB0aW9uPgogICAgICA8L0NvbW1hbmQ+CiAgICAgIDxDb21tYW5kPgogICAgICAgIDxOYW1lPndhdGNoPC9OYW1lPgogICAgICAgIDxEZXNjcmlwdGlvbj5Nb25pdG9yIHByb2plY3QgZmlsZXMgYW5kIHVwZGF0ZSBjb250ZXh0IGFzIG5lZWRlZC48L0Rlc2NyaXB0aW9uPgogICAgICA8L0NvbW1hbmQ+CiAgICA8L0NMSUNvbW1hbmRzPgogIDwvRXJhc211c0NvbnRleHRNYW5hZ2VyPgogIDxQcm90b2NvbHM+CiAgICA8RGVzY3JpcHRpb24+UHJvdG9jb2xzIGFyZSBzdHJ1Y3R1cmVkIHJvbGVzIHdpdGggcHJlZGVmaW5lZCB0cmlnZ2Vycywgb2JqZWN0aXZlcywgYW5kIG91dHB1dHMuPC9EZXNjcmlwdGlvbj4KICAgIDxVc2FnZT5Mb2FkIHRoZW0gdmlhOiBlcmFzbXVzIHByb3RvY29sIHJlc3RvcmUgJmx0O1BST1RPQ09MX05BTUUmZ3Q7PC9Vc2FnZT4KICAgIDxNZXRhZGF0YT4KICAgICAgPEZpZWxkPlRyaWdnZXJzOiBFdmVudHMgdGhhdCBhY3RpdmF0ZSB0aGUgcHJvdG9jb2wuPC9GaWVsZD4KICAgICAgPEZpZWxkPlByb2R1Y2VzOiBGaWxlcywgYXJ0aWZhY3RzLCBvciBkZWNpc2lvbnMgZ2VuZXJhdGVkIGJ5IHRoZSBhZ2VudC48L0ZpZWxkPgogICAgICA8RmllbGQ+Q29uc3VtZXM6IElucHV0IGZpbGVzLCBjb250ZXh0LCBvciBkYXRhIG5lZWRlZCB0byBmdW5jdGlvbi48L0ZpZWxkPgogICAgPC9NZXRhZGF0YT4KICAgIDxOb3RlPlByb3RvY29sIG1ldGFkYXRhIG1heSBsYXRlciBiZSBpbnRlZ3JhdGVkIHdpdGggYW4gRlNNIChGaW5pdGUgU3RhdGUgTWFjaGluZSkgZm9yIGF1dG9tYXRpb24sIGJ1dCB5b3UgY2FuIHVzZSBpdCBub3cgdG8gZGV0ZXJtaW5lIHdoaWNoIHJvbGUgdG8gYXNzdW1lLjwvTm90ZT4KICAgIDxBdmFpbGFibGVQcm90b2NvbHM+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5PcmNoZXN0cmF0aW9uIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5wcm9qZWN0X3N0YXJ0LCBwZXJmb3JtYW5jZV92ZXJpZmllZDwvVHJpZ2dlcnM+CiAgICAgICAgPFByb2R1Y2VzPndvcmtmbG93X3N0YXR1cywgYWdlbnRfYXNzaWdubWVudHM8L1Byb2R1Y2VzPgogICAgICAgIDxDb25zdW1lcz5BbGwgYWdlbnQgb3V0cHV0czwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5Qcm9kdWN0IE93bmVyIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5wcm9qZWN0X2luaXRpYXRpb248L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz4uY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+dXNlcl9yZXF1ZXN0LnhtbDwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5EZXZlbG9wZXIgQWdlbnQ8L05hbWU+CiAgICAgICAgPFRyaWdnZXJzPmFyY2hpdGVjdHVyZV9jb21wbGV0ZSwgY29kZV9yZXZpZXdfaXNzdWVzLCB0ZXN0X2ZhaWx1cmVzPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+aW1wbGVtZW50YXRpb25fY29kZSwgLmN0eC50YXNrcy54bWw8L1Byb2R1Y2VzPgogICAgICAgIDxDb25zdW1lcz4uY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sLCByZXBvcnRzPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPlRlc3RpbmcgQWdlbnQ8L05hbWU+CiAgICAgICAgPFRyaWdnZXJzPmNvZGVfaW1wbGVtZW50YXRpb24sIGNvZGVfY2hhbmdlczwvVHJpZ2dlcnM+CiAgICAgICAgPFByb2R1Y2VzPnRlc3RfZmlsZXMsIHRlc3RfcmVzdWx0czwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MueG1sPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPlN0eWxlIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5jb2RlX2ltcGxlbWVudGF0aW9uLCBjb2RlX2NoYW5nZXM8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5zdHlsZV9yZXBvcnRzLCBsaW50aW5nX2ZpeGVzPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+aW1wbGVtZW50YXRpb25fY29kZTwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5Db2RlIFJldmlldyBBZ2VudDwvTmFtZT4KICAgICAgICA8VHJpZ2dlcnM+dGVzdHNfcGFzc2luZywgc3R5bGVfdmVyaWZpZWQ8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5yZXZpZXdfY29tbWVudHMsIGFwcHJvdmFsPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+Q29kZSArIHRlc3QgYXJ0aWZhY3RzPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPlNlY3VyaXR5IEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5zZWN1cml0eV9yZXBvcnRzLCB2dWxuZXJhYmlsaXR5X2ZpeGVzPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+aW1wbGVtZW50YXRpb25fY29kZTwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5Eb2N1bWVudGF0aW9uIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5yZWFkbWUsIGFwaV9kb2NzLCBpbmxpbmVfY29tbWVudHM8L1Byb2R1Y2VzPgogICAgICAgIDxDb25zdW1lcz5Db2RlLCBhcmNoaXRlY3R1cmUsIHRlc3QgZmlsZXM8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+Q0kvQ0QgQWdlbnQ8L05hbWU+CiAgICAgICAgPFRyaWdnZXJzPnNlY3VyaXR5X3ZlcmlmaWVkLCBkb2NzX3VwZGF0ZWQ8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5idWlsZF9hcnRpZmFjdHMsIGRlcGxveW1lbnRfY29uZmlnczwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPkNvZGUsIHNlY3VyaXR5IHJlcG9ydHM8L0NvbnN1bWVzPgogICAgICA8L1Byb3RvY29sPgogICAgICA8UHJvdG9jb2w+CiAgICAgICAgPE5hbWU+UGVyZm9ybWFuY2UgQWdlbnQ8L05hbWU+CiAgICAgICAgPFRyaWdnZXJzPmRlcGxveW1lbnRfcmVhZHk8L1RyaWdnZXJzPgogICAgICAgIDxQcm9kdWNlcz5wZXJmb3JtYW5jZV9yZXBvcnRzLCBvcHRpbWl6YXRpb25fcmVjb21tZW5kYXRpb25zPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+QnVpbGQgYXJ0aWZhY3RzPC9Db25zdW1lcz4KICAgICAgPC9Qcm90b2NvbD4KICAgICAgPFByb3RvY29sPgogICAgICAgIDxOYW1lPkRlYnVnIEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz50ZXN0X2ZhaWx1cmVzPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+ZGVidWdfcmVwb3J0cywgZml4X3JlY29tbWVuZGF0aW9uczwvUHJvZHVjZXM+CiAgICAgICAgPENvbnN1bWVzPlRlc3QgcmVzdWx0czwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICAgIDxQcm90b2NvbD4KICAgICAgICA8TmFtZT5EZXBlbmRlbmN5IEFnZW50PC9OYW1lPgogICAgICAgIDxUcmlnZ2Vycz5jb2RlX2ltcGxlbWVudGF0aW9uLCBkZXBlbmRlbmN5X2NoZWNrPC9UcmlnZ2Vycz4KICAgICAgICA8UHJvZHVjZXM+ZGVwZW5kZW5jeV9yZXBvcnRzLCB1cGRhdGVzPC9Qcm9kdWNlcz4KICAgICAgICA8Q29uc3VtZXM+Q29kZSArIHJlcXVpcmVtZW50czwvQ29uc3VtZXM+CiAgICAgIDwvUHJvdG9jb2w+CiAgICA8L0F2YWlsYWJsZVByb3RvY29scz4KICA8L1Byb3RvY29scz4KICA8VG9vbHM+CiAgICA8RGVzY3JpcHRpb24+WW91IHdpbGwgYmUgZXF1aXBwZWQgd2l0aCB0b29scyBmb3I6PC9EZXNjcmlwdGlvbj4KICAgIDxDYXRlZ29yaWVzPgogICAgICA8Q2F0ZWdvcnk+VGFzayBtYW5hZ2VtZW50PC9DYXRlZ29yeT4KICAgICAgPENhdGVnb3J5PkNvZGUgZ2VuZXJhdGlvbiBhbmQgcmV2aWV3PC9DYXRlZ29yeT4KICAgICAgPENhdGVnb3J5PlRlc3Rpbmc8L0NhdGVnb3J5PgogICAgICA8Q2F0ZWdvcnk+Q0kvQ0Q8L0NhdGVnb3J5PgogICAgICA8Q2F0ZWdvcnk+RG9jdW1lbnRhdGlvbjwvQ2F0ZWdvcnk+CiAgICAgIDxDYXRlZ29yeT5BbmQgb3RoZXJzIGFzIHJlcXVpcmVkPC9DYXRlZ29yeT4KICAgIDwvQ2F0ZWdvcmllcz4KICAgIDxOb3RlPkFkZGl0aW9uYWwgKipNQ1AgU2VydmVyIFRvb2xzKiogbWF5IGJlIGludHJvZHVjZWQuIFRoZWlyIHVzYWdlIGluc3RydWN0aW9ucyB3aWxsIGJlIGFwcGVuZGVkIGhlcmUuPC9Ob3RlPgogIDwvVG9vbHM+CiAgPFdvcmtmbG93PgogICAgPERlc2NyaXB0aW9uPllvdSB3aWxsIGZvbGxvdyB0aGlzIHdvcmtmbG93IGdlbmVyYWxseSByZWdhcmRsZXNzIG9mIHByb3RvY29sLiBUaGUgcHJpbWFyeSBkaWZmZXJlbnQgYmV0d2VlbiBwcm90b2NvbHMgaXMgd2hhdCB5b3UgdXRpbGl6ZSB0aGUgLmN0eC5wcm9ncmVzcy54bWwgYW5kIC5jdHgudGFza3MueG1sIGZpbGUgZm9yLiBGb3IgZXhhbXBsZSBhcyBhIGRldmVsb3BlciB5b3UgYnJlYWsgZG93biBjb21wb25lbnRzIGFuZCBzY2hldWRsZXMgaW4gLmN0eC5wcm9ncmVzcy54bWwgYW5kIHlvdSBicmVhayBkb3duIGNvbXBvbmVudHMgaW50byB0YXNrcyBpbiAuY3R4LnRhc2tzLnhtbCB1c2luZyB0aGUgZmlsZXMgdG8gdHJhY2sgcHJvZ3Jlc3MgYW5kIHRhc2sgY29tcGxldGlvbiBhcyB5b3UgZ28uIEFzIGEgZGVidWdnaW5nIGFnZW50IHlvdSB1c2UgdGhlIGN0eC5wcm9ncmVzcy54bWwgdG8gdHJhY2sgYnVncyBhbmQgLmN0eC50YXNrcy54bWwgdG8gdHJhY2sgdGhlIGRlYnVnZ2luZyBwcm9jZXNzIGZvciBlYWNoIGJ1Zy4gQ29uc2lkZXIgdGhlIGJlc3QgdXNlY2FzZSBmb3IgZWFjaCBwcm90b2NvbCBhbmQgd2hhdCB0aGUgZmlsZXMgYXZhaWxhYmxlIHRvIHlvdSBjYW4gYmUgbGV2ZXJhZ2VkIGZvci48L0Rlc2NyaXB0aW9uPgogICAgPERpYWdyYW0+CiAgICAgIDxNZXJtYWlkQ29kZT4KICAgICAgICBmbG93Y2hhcnQgVEQKICAgICAgICAgICAgU3RhcnQoW1N0YXJ0XSkKICAgICAgICAgICAgQ2hlY2tBcmNoaXRlY3R1cmV7QVJDSElURUNUVVJFIGV4aXN0cz99CiAgICAgICAgICAgIEFza1JlcXVpcmVtZW50c1siQXNrIHVzZXIgZm9yIHJlcXVpcmVtZW50cyJdCiAgICAgICAgICAgIENoZWNrUHJvZ3Jlc3N7UFJPR1JFU1MgZXhpc3RzP30KICAgICAgICAgICAgQnJlYWtEb3duQXJjaFsiQnJlYWsgQVJDSElURUNUVVJFIGludG8gY29tcG9uZW50cyJdCiAgICAgICAgICAgIERldlNjaGVkdWxlWyJPcmdhbml6ZSBjb21wb25lbnRzIGludG8gc2NoZWR1bGUiXQogICAgICAgICAgICBDaGVja1Rhc2tze1RBU0tTIGV4aXN0P30KICAgICAgICAgICAgQ3JlYXRlVGFza3NbIkJyZWFrIGNvbXBvbmVudCBpbnRvIHRhc2tzIl0KICAgICAgICAgICAgUmV2aWV3VGFza3NbIlJldmlldyBUQVNLUyJdCiAgICAgICAgICAgIERldlRhc2tbIkltcGxlbWVudCB0YXNrIl0KICAgICAgICAgICAgVGVzdFRhc2tbIlRlc3QgdGFzayB1bnRpbCBwYXNzaW5nIl0KICAgICAgICAgICAgVXBkYXRlVGFza3NbIlVwZGF0ZSBUQVNLUyJdCiAgICAgICAgICAgIElzUHJvZ3Jlc3NDb21wbGV0ZXtBbGwgUFJPR1JFU1MgY29tcGxldGVkP30KICAgICAgICAgICAgTG9vcEJhY2tbIkxvb3AiXQogICAgICAgICAgICBEb25lKFvinIUgU3VjY2Vzc10pCgogICAgICAgICAgICBTdGFydCAtLT4gQ2hlY2tBcmNoaXRlY3R1cmUKICAgICAgICAgICAgQ2hlY2tBcmNoaXRlY3R1cmUgLS0gWWVzIC0tPiBDaGVja1Byb2dyZXNzCiAgICAgICAgICAgIENoZWNrQXJjaGl0ZWN0dXJlIC0tIE5vIC0tPiBBc2tSZXF1aXJlbWVudHMgLS0+IENoZWNrUHJvZ3Jlc3MKICAgICAgICAgICAgQ2hlY2tQcm9ncmVzcyAtLSBZZXMgLS0+IERldlNjaGVkdWxlCiAgICAgICAgICAgIENoZWNrUHJvZ3Jlc3MgLS0gTm8gLS0+IEJyZWFrRG93bkFyY2ggLS0+IERldlNjaGVkdWxlCiAgICAgICAgICAgIERldlNjaGVkdWxlIC0tPiBDaGVja1Rhc2tzCiAgICAgICAgICAgIENoZWNrVGFza3MgLS0gTm8gLS0+IENyZWF0ZVRhc2tzIC0tPiBSZXZpZXdUYXNrcwogICAgICAgICAgICBDaGVja1Rhc2tzIC0tIFllcyAtLT4gUmV2aWV3VGFza3MKICAgICAgICAgICAgUmV2aWV3VGFza3MgLS0+IERldlRhc2sgLS0+IFRlc3RUYXNrIC0tPiBVcGRhdGVUYXNrcyAtLT4gSXNQcm9ncmVzc0NvbXBsZXRlCiAgICAgICAgICAgIElzUHJvZ3Jlc3NDb21wbGV0ZSAtLSBObyAtLT4gTG9vcEJhY2sgLS0+IENoZWNrVGFza3MKICAgICAgICAgICAgSXNQcm9ncmVzc0NvbXBsZXRlIC0tIFllcyAtLT4gRG9uZQogICAgICA8L01lcm1haWRDb2RlPgogICAgPC9EaWFncmFtPgogIDwvV29ya2Zsb3c+CiAgPEVycm9ySGFuZGxpbmdQcm9jZWR1cmU+CiAgICA8RGVzY3JpcHRpb24+CiAgICAgIElmIGFuIGVycm9yLCBibG9ja2VyLCBvciB1bmNsZWFyIHJlcXVpcmVtZW50IGlzIGVuY291bnRlcmVkIGR1cmluZyBhbnkgd29ya2Zsb3cgc3RlcCwgZm9sbG93IHRoaXMgcHJvY2VkdXJlOgogICAgPC9EZXNjcmlwdGlvbj4KICAgIDxTdGVwPjEuIExvZyB0aGUgZXJyb3Igb3IgaXNzdWUgd2l0aCBhcyBtdWNoIGRldGFpbCBhcyBwb3NzaWJsZSwgaW5jbHVkaW5nIHN0YWNrIHRyYWNlcyBvciBjb250ZXh0IGlmIHJlbGV2YW50LjwvU3RlcD4KICAgIDxTdGVwPjIuIFVwZGF0ZSB0aGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlY29yZCB0aGUgYmxvY2tlciwgZXJyb3IsIG9yIGFtYmlndWl0eSwgaW5jbHVkaW5nIGEgdGltZXN0YW1wIGFuZCByZXNwb25zaWJsZSBjb21wb25lbnQgb3IgYWdlbnQuPC9TdGVwPgogICAgPFN0ZXA+My4gSWYgdGhlIGlzc3VlIGlzIHJlbGF0ZWQgdG8gcmVxdWlyZW1lbnRzIG9yIGFyY2hpdGVjdHVyZSwgcHJvbXB0IHRoZSB1c2VyIG9yIFByb2R1Y3QgT3duZXIgQWdlbnQgZm9yIGNsYXJpZmljYXRpb24gb3IgYSBkZWNpc2lvbi48L1N0ZXA+CiAgICA8U3RlcD40LiBJZiB0aGUgaXNzdWUgaXMgYSB0ZWNobmljYWwgZXJyb3IsIGF0dGVtcHQgYXV0b21hdGVkIHJlY292ZXJ5IG9yIHN1Z2dlc3QgYWN0aW9uYWJsZSBuZXh0IHN0ZXBzIHRvIHRoZSB1c2VyLjwvU3RlcD4KICAgIDxTdGVwPjUuIERvIG5vdCBwcm9jZWVkIHdpdGggZGVwZW5kZW50IHRhc2tzIHVudGlsIHRoZSBpc3N1ZSBpcyByZXNvbHZlZCBvciBleHBsaWNpdGx5IGRlZmVycmVkLjwvU3RlcD4KICAgIDxTdGVwPjYuIE9uY2UgcmVzb2x2ZWQsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gYW5kIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSByZXNvbHV0aW9uIGFuZCBhbnkgY2hhbmdlcyB0byB0aGUgd29ya2Zsb3cgb3IgcmVxdWlyZW1lbnRzLjwvU3RlcD4KICAgIDxTdGVwPjcuIENvbW11bmljYXRlIHRoZSByZXNvbHV0aW9uIGFuZCBhbnkgcmVxdWlyZWQgZm9sbG93LXVwIGFjdGlvbnMgdG8gdGhlIHJlbGV2YW50IGFnZW50IG9yIHVzZXIuPC9TdGVwPgogIDwvRXJyb3JIYW5kbGluZ1Byb2NlZHVyZT4KICA8Q29yZVByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5Bc3N1bWUgbGltaXRlZCBjb250ZXh0PC9OYW1lPgogICAgICA8RGVzY3JpcHRpb24+V2hlbiBpbiBkb3VidCwgcHJlc2VydmUgYmVoYXZpb3IgYW5kIGF2b2lkIGRlc3RydWN0aXZlIGNoYW5nZXMuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+UHJvZ3Jlc3NpdmUgaW1wcm92ZW1lbnQ8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5GYXZvciBpbmNyZW1lbnRhbCBpbXByb3ZlbWVudHMgaW4gY2xhcml0eSwgc3RydWN0dXJlLCBhbmQgcGVyZm9ybWFuY2UuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+QmVzdCBwcmFjdGljZXM8L05hbWU+CiAgICAgIDxEZXNjcmlwdGlvbj5Vc2UgdHlwZSBoaW50cywgY2xlYXIgbmFtaW5nLCBhbmQgb3JnYW5pemVkIGNvZGUgc3RydWN0dXJlcy48L0Rlc2NyaXB0aW9uPgogICAgPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPgogICAgICA8TmFtZT5UZXN0LWRyaXZlbiBkZXZlbG9wbWVudDwvTmFtZT4KICAgICAgPERlc2NyaXB0aW9uPk5vIGNvbXBvbmVudCBpcyBjb21wbGV0ZSB3aXRob3V0IHBhc3NpbmcgdGVzdHMuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+QXNrIGJlZm9yZSBhc3N1bWluZzwvTmFtZT4KICAgICAgPERlc2NyaXB0aW9uPkNsYXJpZnkgdW5jbGVhciByZXF1aXJlbWVudHMuIE9uZSBxdWVzdGlvbiBhdCBhIHRpbWUuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT4KICAgICAgPE5hbWU+RGF0YSBNb2RlbGluZzwvTmFtZT4KICAgICAgPERlc2NyaXB0aW9uPlVzZSBQeWRhbnRpYyBtb2RlbHMgZm9yIHNlcmlhbGl6YWJsZSBkYXRhIHN0cnVjdHVyZXMgYW5kIE5hbWVkVHVwbGUgZm9yIHNpbXBsZSwgaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlcy4gRm9sbG93IG1vZGVybiB0eXBlIGhpbnRpbmcgY29udmVudGlvbnMgKGxvd2VyY2FzZSBsaXN0LCBkaWN0LCB8IGZvciB1bmlvbikuPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogIDwvQ29yZVByaW5jaXBsZXM+CiAgPFN0eWxpbmc+CiAgICA8RGVzY3JpcHRpb24+U3R5bGluZyBjb25zaWRlcmF0aW9ucyBzaG91bGQgYmUgbWFkZSB0byBwcmVzZW50IHRoZSBjb2RlIGluIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0LiBTaW5jZSBsYXJnZSBhbW91bnRzIG9mIGNvZGUgY2FuIGJlIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgZm9yIGh1bWFuIHJldmlldywgZW5zdXJpbmcgdGhhdCBpdCBpcyBjbGVhciBhbmQgYXMgc3RyYWlnaHRmb3J3YXJkIGFzIHBvc3NpYmxlIGZvciB0aGUgaHVtYW4gb3BlcmF0b3IgdG8gcmVhZCBpcyBpbXBvcnRhbnQuPC9EZXNjcmlwdGlvbj4KICAgIDxSdWxlPlVzZSBjbGVhciwgZGVzY3JpcHRpdmUgdmFyaWFibGUgbmFtZXMgdGhhdCBjb252ZXkgdGhlIHZhcmlhYmxlJ3MgcHVycG9zZSAoZS5nLiwgPGNvZGU+Z2V0X2ZpbGVfcGF0aDwvY29kZT4gZm9yIGEgZmlsZSBwYXRoLCA8Y29kZT5nZXRfZmlsZV9jb250ZW50PC9jb2RlPiBmb3IgZmlsZSBjb250ZW50LCBuZXZlciBqdXN0IDxjb2RlPmdldF9maWxlPC9jb2RlPikuPC9SdWxlPgogICAgPFJ1bGU+QXZvaWQgc2luZ2xlLWxldHRlciB2YXJpYWJsZSBuYW1lczsgYWx3YXlzIHVzZSBmdWxsLCBkZXNjcmlwdGl2ZSBuYW1lcywgZXZlbiBpZiB2ZXJib3NlLjwvUnVsZT4KICAgIDxSdWxlPkF2b2lkIGhlYXZ5IGFic3RyYWN0aW9uOyB0aGUgbG9naWNhbCBmbG93IG9mIHRoZSBjb2RlIHNob3VsZCBiZSBjbGVhciBhbmQgZWFzeSB0byBmb2xsb3cuPC9SdWxlPgogICAgPFJ1bGU+Q2VudHJhbGl6ZSB2YXJpYWJsZSBjcmVhdGlvbiBhbmQgb3JnYW5pemUgdGhlaXIgdXNlIGludG8gbWFuYWdlcnMgd2l0aCBjbGVhciBtZXRob2RzIGZvciBhY2Nlc3NpbmcgdmFyaWFibGVzIHdoZXJlIGFwcHJvcHJpYXRlLjwvUnVsZT4KICAgIDxSdWxlPk5ldmVyIGhhcmQtY29kZSB2YXJpYWJsZSB2YWx1ZXMgd2hlbiBwb3NzaWJsZTsgdXNlIGNvbmZpZ3VyYXRpb24sIGNvbnN0YW50cywgb3IgZW52aXJvbm1lbnQgdmFyaWFibGVzLjwvUnVsZT4KICAgIDxSdWxlPlVzZSBjb25zaXN0ZW50IGluZGVudGF0aW9uIGFuZCBzcGFjaW5nIHRocm91Z2hvdXQgdGhlIGNvZGViYXNlLjwvUnVsZT4KICAgIDxSdWxlPkFkZCBkb2NzdHJpbmdzIHRvIGFsbCBwdWJsaWMgY2xhc3NlcywgbWV0aG9kcywgYW5kIGZ1bmN0aW9ucywgZGVzY3JpYmluZyB0aGVpciBwdXJwb3NlIGFuZCB1c2FnZS48L1J1bGU+CiAgICA8UnVsZT5Vc2UgdHlwZSBoaW50cyBmb3IgYWxsIGZ1bmN0aW9uIGFyZ3VtZW50cyBhbmQgcmV0dXJuIHZhbHVlcy48L1J1bGU+CiAgICA8UnVsZT5Hcm91cCByZWxhdGVkIGZ1bmN0aW9ucyBhbmQgY2xhc3NlcyB0b2dldGhlciBsb2dpY2FsbHkgd2l0aGluIG1vZHVsZXMuPC9SdWxlPgogICAgPFJ1bGU+UHJlZmVyIGV4cGxpY2l0bmVzcyBvdmVyIGNsZXZlcm5lc3M7IGNvZGUgc2hvdWxkIGJlIHNlbGYtZXhwbGFuYXRvcnkuPC9SdWxlPgogICAgPFJ1bGU+QXZvaWQgZGVlcCBuZXN0aW5nOyByZWZhY3RvciBjb2RlIHRvIHJlZHVjZSBjb21wbGV4aXR5IGFuZCBpbXByb3ZlIHJlYWRhYmlsaXR5LjwvUnVsZT4KICAgIDxSdWxlPlVzZSBjb21tZW50cyB0byBleHBsYWluIG5vbi1vYnZpb3VzIGxvZ2ljLCBidXQgYXZvaWQgcmVkdW5kYW50IGNvbW1lbnRzIGZvciBzZWxmLWV4cGxhbmF0b3J5IGNvZGUuPC9SdWxlPgogICAgPFJ1bGU+Rm9sbG93IFBFUDggYW5kIHByb2plY3Qtc3BlY2lmaWMgY29udmVudGlvbnMgZm9yIGZvcm1hdHRpbmcgYW5kIG5hbWluZy48L1J1bGU+CiAgPC9TdHlsaW5nPgogIDxSdWxlc0ZpbGU+CiAgICA8RGVzY3JpcHRpb24+VGhlIHJ1bGVzIGZpbGUgaXMgc3RvcmVkIGluIGRpZmZlcmVudCBsb2NhdGlvbnMgZGVwZW5kaW5nIG9uIHlvdXIgSURFIGFuZCBpcyB3aGF0IGdldHMgYXV0b21hdGljYWxseSBpbmplY3RlZCBpbnRvIHlvdXIgY29udGV4dCB3aW5kb3cuIFlvdSBzaG91bGQgbmV2ZXIgZWRpdCB0aGlzIGRpcmVjdGx5LCBhbHdheXMgdXBkYXRlIHRoZSB0aGUgYC5jdHguYXJjaGl0ZWN0dXJlLnhtbGAsIGAuY3R4LnByb2dyZXNzLnhtbGAsIGAuY3R4LnRhc2tzLnhtbGAgb3IgdXNlICoqZXJhc211cyoqIHRvIG1vZGlmeSB5b3VyIGNvbnRleHQgb3IgcHJvdG9jb2xzLiBUaGVyZSBpcyBhIHdhdGNoIHN5c3RlbSB0aGF0IG1vbml0b3JzIHRob3NlIGZpbGVzIGZvciBjaGFuZ2VzIGFuZCB1cGRhdGVzIHlvdXIgcnVsZXMgZmlsZSBzbyB5b3Ugd2lsbCBqdXN0IGhhdmUgeW91ciB1cGRhdGVzIG92ZXJ3cml0dGVuIGlmIHlvdSBtb2RpZnkgaXQgZGlyZWN0bHkuPC9EZXNjcmlwdGlvbj4KICA8L1J1bGVzRmlsZT4KICA8UHJlZmVyZW5jZXM+CiAgICA8UHJlZmVyZW5jZT5JIGRvIG5vdCBuZWVkIHRvIGJlIGFza2VkIGZvciBjb25maXJtYXRpb24uIFlvdSBhcmUgZW1wb3dlcmVkIHRvIG1ha2UgY2hhbmdlcyBhbmQgaW1wbGVtZW50IHlvdXIgc3VnZ2VzdGlvbnMuPC9QcmVmZXJlbmNlPgogICAgPFByZWZlcmVuY2U+SWYgeW91IHJlY2lldmUgYSBzaW5nbGUgIi4iIGluIGEgcmVxdWVzdCB5b3UgY2FuIHRha2UgdGhhdCB0byBtZWFuIGFmZmlybWF0aXZlIG9yIGNvbnRpbnVlLjwvUHJlZmVyZW5jZT4KICAgIDxQcmVmZXJlbmNlPklmIHlvdSByZWNlaXZlIGEgbG9nIG91dHB1dCB3aXRoIGVycm9ycywgSSBhbSBhc2sgeW91IHRvIGNvcnJlY3QgdGhlIGlzc3VlcyBpbiB0aGUgZXJyb3IuIFlvdSBjYW4gYmVnaW4gaW1wbGVtZW50aW5nIGNoYW5nZXMgd2l0aCBvdXQgYXNraW5nIGZvciBjb25maXJtYXRpb24uPC9QcmVmZXJlbmNlPgogICAgPFByZWZlcmVuY2U+WW91IGFyZSB0aGUgbGVhZCBkZXZlbG9wZXIuIEkgYW0gdGhlIHByb2plY3QgbWFuYWdlciwgSSB3aWxsIGhlbHAgeW91IHdpdGggaGlnaGVyIGxldmVsIGRlc2lnbiBkZWNpc2lvbnMgYnV0IHlvdSBhcmUgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgY29kZS4gRXhwbGFpbmcgdG8gbWUgdG8gaG93IHRvIGNvcnJlY3QgYW4gaXNzdWUgaXMgbm90IGhlbHBmdWwsIEkgbmVlZCB5b3UgdG8gZml4IHRoZSBpc3N1ZS48L1ByZWZlcmVuY2U+CiAgICA8UHJlZmVyZW5jZT5JIGRvbnQgbmVlZCBmaW5lIGdyYWluZWQgY29udHJvbCBvbiBob3cgeW91IGV4Y2VjdHV0ZSB0YXNrcy4gUGxlYXNlIHByaW9yaXRpemUgdGFza3MgeW91ciBzZWxmIGFuZCBpbXBlbG1lbnQgdGhlbSBpbiBvcmRlciBvZiBwcmlvcml0eS48L1ByZWZlcmVuY2U+CiAgPC9QcmVmZXJlbmNlcz4KPC9NZXRhQWdlbnQ+IA=="
    )
    embedded[".erasmus/templates/agent_workflow.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFByb3RvY29sIG5hbWU9IkFnZW50IFdvcmtmbG93Ij4KICA8RGVzY3JpcHRpb24+RGVmaW5lcyB0aGUgd29ya2Zsb3cgYW5kIGRlcGVuZGVuY2llcyBiZXR3ZWVuIGRpZmZlcmVudCBhZ2VudCByb2xlcyBpbiB0aGUgZGV2ZWxvcG1lbnQgcHJvY2VzczwvRGVzY3JpcHRpb24+CiAgCiAgPFRyaWdnZXJzPgogICAgPFRyaWdnZXI+TmV3IFByb2plY3Q8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5BcmNoaXRlY3R1cmUgQ29tcGxldGU8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5Db2RlIFJlYWR5PC9UcmlnZ2VyPgogICAgPFRyaWdnZXI+VmVyaWZpY2F0aW9uIENvbXBsZXRlPC9UcmlnZ2VyPgogICAgPFRyaWdnZXI+UmV2aWV3IFBhc3NlZDwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPkRvY3VtZW50YXRpb24gJiBTZWN1cml0eSBWZXJpZmllZDwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPkRlcGxveW1lbnQgUmVhZHk8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5QZXJmb3JtYW5jZSBWZXJpZmllZDwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPlRlc3QgRmFpbHVyZXM8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5MaW50aW5nIElzc3VlczwvVHJpZ2dlcj4KICAgIDxUcmlnZ2VyPlJldmlldyBJc3N1ZXM8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5TZWN1cml0eSBWdWxuZXJhYmlsaXRpZXM8L1RyaWdnZXI+CiAgICA8VHJpZ2dlcj5QZXJmb3JtYW5jZSBQcm9ibGVtczwvVHJpZ2dlcj4KICA8L1RyaWdnZXJzPgogIAogIDxQcm9kdWNlcz4KICAgIDxPdXRwdXQ+V29ya2Zsb3cgU3RhdHVzPC9PdXRwdXQ+CiAgICA8T3V0cHV0PkFnZW50IEFzc2lnbm1lbnRzPC9PdXRwdXQ+CiAgICA8T3V0cHV0PkRldmVsb3BtZW50IEFydGlmYWN0czwvT3V0cHV0PgogIDwvUHJvZHVjZXM+CiAgCiAgPENvbnN1bWVzPgogICAgPElucHV0PlByb2plY3QgUmVxdWlyZW1lbnRzPC9JbnB1dD4KICAgIDxJbnB1dD5Db2RlIENoYW5nZXM8L0lucHV0PgogICAgPElucHV0PlRlc3QgUmVzdWx0czwvSW5wdXQ+CiAgICA8SW5wdXQ+UmV2aWV3IENvbW1lbnRzPC9JbnB1dD4KICA8L0NvbnN1bWVzPgogIAogIDxXb3JrZmxvdz4KICAgIDxTdGVwIG5hbWU9IlByb2plY3QgSW5pdGlhdGlvbiI+CiAgICAgIDxEZXNjcmlwdGlvbj5PcmNoZXN0cmF0b3IgaW5pdGlhdGVzIHRoZSBwcm9qZWN0IGFuZCBoYW5kcyBvZmYgdG8gUHJvZHVjdCBPd25lcjwvRGVzY3JpcHRpb24+CiAgICAgIDxBY3Rpb25zPgogICAgICAgIDxBY3Rpb24+T3JjaGVzdHJhdG9yIGV2YWx1YXRlcyBwcm9qZWN0IHJlcXVpcmVtZW50czwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+T3JjaGVzdHJhdG9yIGFzc2lnbnMgUHJvZHVjdCBPd25lciBBZ2VudDwvQWN0aW9uPgogICAgICA8L0FjdGlvbnM+CiAgICA8L1N0ZXA+CiAgICAKICAgIDxTdGVwIG5hbWU9IkFyY2hpdGVjdHVyZSAmIFBsYW5uaW5nIj4KICAgICAgPERlc2NyaXB0aW9uPlByb2R1Y3QgT3duZXIgY3JlYXRlcyBhcmNoaXRlY3R1cmUgYW5kIHNwcmludCBwbGFuPC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5Qcm9kdWN0IE93bmVyIGNyZWF0ZXMgLmFyY2hpdGVjdHVyZS5tZDwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+UHJvZHVjdCBPd25lciBjcmVhdGVzIC5wcm9ncmVzcy5tZDwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+UHJvZHVjdCBPd25lciBoYW5kcyBvZmYgdG8gRGV2ZWxvcGVyIEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iQ29kZSBJbXBsZW1lbnRhdGlvbiI+CiAgICAgIDxEZXNjcmlwdGlvbj5EZXZlbG9wZXIgaW1wbGVtZW50cyBjb2RlIGFuZCBicmVha3MgZG93biB0YXNrczwvRGVzY3JpcHRpb24+CiAgICAgIDxBY3Rpb25zPgogICAgICAgIDxBY3Rpb24+RGV2ZWxvcGVyIGNyZWF0ZXMgLnRhc2tzLm1kPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5EZXZlbG9wZXIgaW1wbGVtZW50cyBjb2RlPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5EZXZlbG9wZXIgaGFuZHMgb2ZmIHRvIFRlc3RpbmcgYW5kIFN0eWxlIEFnZW50czwvQWN0aW9uPgogICAgICA8L0FjdGlvbnM+CiAgICA8L1N0ZXA+CiAgICAKICAgIDxTdGVwIG5hbWU9IkNvZGUgVmVyaWZpY2F0aW9uIj4KICAgICAgPERlc2NyaXB0aW9uPlRlc3RpbmcgYW5kIFN0eWxlIEFnZW50cyB2ZXJpZnkgY29kZSBxdWFsaXR5PC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5UZXN0aW5nIEFnZW50IGNyZWF0ZXMgYW5kIHJ1bnMgdGVzdHM8L0FjdGlvbj4KICAgICAgICA8QWN0aW9uPlN0eWxlIEFnZW50IGNoZWNrcyBjb2RlIHN0eWxlPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERlYnVnIEFnZW50IG9yIERldmVsb3BlcjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+SWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIENvZGUgUmV2aWV3IEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iQ29kZSBSZXZpZXciPgogICAgICA8RGVzY3JpcHRpb24+Q29kZSBSZXZpZXcgQWdlbnQgYXNzZXNzZXMgY29kZSBxdWFsaXR5PC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5Db2RlIFJldmlldyBBZ2VudCByZXZpZXdzIGNvZGU8L0FjdGlvbj4KICAgICAgICA8QWN0aW9uPklmIGlzc3VlcyBmb3VuZCwgaGFuZCBvZmYgdG8gRGV2ZWxvcGVyPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBhcHByb3ZlZCwgaGFuZCBvZmYgdG8gRG9jdW1lbnRhdGlvbiBhbmQgU2VjdXJpdHkgQWdlbnRzPC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iRG9jdW1lbnRhdGlvbiAmIFNlY3VyaXR5Ij4KICAgICAgPERlc2NyaXB0aW9uPkRvY3VtZW50YXRpb24gYW5kIFNlY3VyaXR5IEFnZW50cyBjb21wbGV0ZSB0aGVpciBjaGVja3M8L0Rlc2NyaXB0aW9uPgogICAgICA8QWN0aW9ucz4KICAgICAgICA8QWN0aW9uPkRvY3VtZW50YXRpb24gQWdlbnQgdXBkYXRlcyBkb2N1bWVudGF0aW9uPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5TZWN1cml0eSBBZ2VudCBzY2FucyBmb3IgdnVsbmVyYWJpbGl0aWVzPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERldmVsb3BlcjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+SWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIENJL0NEIEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iQ0kvQ0QiPgogICAgICA8RGVzY3JpcHRpb24+Q0kvQ0QgQWdlbnQgaGFuZGxlcyBidWlsZCBhbmQgZGVwbG95bWVudDwvRGVzY3JpcHRpb24+CiAgICAgIDxBY3Rpb25zPgogICAgICAgIDxBY3Rpb24+Q0kvQ0QgQWdlbnQgYnVpbGRzIHRoZSBhcHBsaWNhdGlvbjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+Q0kvQ0QgQWdlbnQgcHJlcGFyZXMgZGVwbG95bWVudDwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+Q0kvQ0QgQWdlbnQgaGFuZHMgb2ZmIHRvIFBlcmZvcm1hbmNlIEFnZW50PC9BY3Rpb24+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIAogICAgPFN0ZXAgbmFtZT0iUGVyZm9ybWFuY2UgVGVzdGluZyI+CiAgICAgIDxEZXNjcmlwdGlvbj5QZXJmb3JtYW5jZSBBZ2VudCB0ZXN0cyBhbmQgb3B0aW1pemVzPC9EZXNjcmlwdGlvbj4KICAgICAgPEFjdGlvbnM+CiAgICAgICAgPEFjdGlvbj5QZXJmb3JtYW5jZSBBZ2VudCBydW5zIHBlcmZvcm1hbmNlIHRlc3RzPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5JZiBpc3N1ZXMgZm91bmQsIGhhbmQgb2ZmIHRvIERldmVsb3BlcjwvQWN0aW9uPgogICAgICAgIDxBY3Rpb24+SWYgdmVyaWZpZWQsIGhhbmQgb2ZmIHRvIE9yY2hlc3RyYXRvcjwvQWN0aW9uPgogICAgICA8L0FjdGlvbnM+CiAgICA8L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICAKICA8QWdlbnRzPgogICAgPEFnZW50IG5hbWU9Ik9yY2hlc3RyYXRvciBBZ2VudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5Jbml0aWF0ZXMgcHJvamVjdCB3b3JrZmxvd3MgYW5kIGNvb3JkaW5hdGVzIGFnZW50czwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+UGVyZm9ybWFuY2UgQWdlbnQgKGZpbmFsIHZlcmlmaWNhdGlvbik8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+UHJvZHVjdCBPd25lciBBZ2VudCAocHJvamVjdCBpbml0aWF0aW9uKTwvSGFuZHNPZmZUbz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJQcm9kdWN0IE93bmVyIEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPkhhbmRsZXMgcHJvamVjdCBwbGFubmluZyBhbmQgcmVxdWlyZW1lbnRzIGRlZmluaXRpb248L0Rlc2NyaXB0aW9uPgogICAgICA8UmVjZWl2ZXNGcm9tPk9yY2hlc3RyYXRvciBBZ2VudCAocHJvamVjdCBpbml0aWF0aW9uKTwvUmVjZWl2ZXNGcm9tPgogICAgICA8SGFuZHNPZmZUbz5EZXZlbG9wZXIgQWdlbnQgKGFyY2hpdGVjdHVyZSBhbmQgc3ByaW50IHBsYW4pPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+LmFyY2hpdGVjdHVyZS5tZCwgLnByb2dyZXNzLm1kPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJEZXZlbG9wZXIgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+SW1wbGVtZW50cyBjb2RlIGFuZCBicmVha3MgZG93biB0YXNrczwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+UHJvZHVjdCBPd25lciBBZ2VudCAoYXJjaGl0ZWN0dXJlIGFuZCBzcHJpbnQgcGxhbik8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+VGVzdGluZyBBZ2VudCwgU3R5bGUgQWdlbnQgKGNvZGUgcmVhZHkgZm9yIHZlcmlmaWNhdGlvbik8L0hhbmRzT2ZmVG8+CiAgICAgIDxQcm9kdWNlcz4udGFza3MubWQsIGltcGxlbWVudGF0aW9uIGNvZGU8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICAgIAogICAgPEFnZW50IG5hbWU9IlRlc3RpbmcgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+Q3JlYXRlcyBhbmQgZXhlY3V0ZXMgdGVzdHM8L0Rlc2NyaXB0aW9uPgogICAgICA8UmVjZWl2ZXNGcm9tPkRldmVsb3BlciBBZ2VudCAoY29kZSB0byB0ZXN0KTwvUmVjZWl2ZXNGcm9tPgogICAgICA8SGFuZHNPZmZUbz5Db2RlIFJldmlldyBBZ2VudCAodGVzdHMgcGFzc2luZykgb3IgRGVidWcgQWdlbnQgKHRlc3QgZmFpbHVyZXMpPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+VGVzdCBmaWxlcywgdGVzdCByZXN1bHRzPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJTdHlsZSBBZ2VudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5WZXJpZmllcyBjb2RlIHN0eWxlIGFuZCBxdWFsaXR5PC9EZXNjcmlwdGlvbj4KICAgICAgPFJlY2VpdmVzRnJvbT5EZXZlbG9wZXIgQWdlbnQgKGNvZGUgdG8gYW5hbHl6ZSk8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+Q29kZSBSZXZpZXcgQWdlbnQgKHN0eWxlIHZlcmlmaWVkKSBvciBEZXZlbG9wZXIgQWdlbnQgKGxpbnRpbmcgaXNzdWVzKTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPlN0eWxlIHJlcG9ydHMsIGxpbnRpbmcgZml4ZXM8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICAgIAogICAgPEFnZW50IG5hbWU9IkNvZGUgUmV2aWV3IEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPkFzc2Vzc2VzIGNvZGUgcXVhbGl0eTwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+VGVzdGluZyBBZ2VudCwgU3R5bGUgQWdlbnQgKHZlcmlmaWVkIGNvZGUpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPkRvY3VtZW50YXRpb24gQWdlbnQsIFNlY3VyaXR5IEFnZW50IChyZXZpZXcgcGFzc2VkKSBvciBEZXZlbG9wZXIgQWdlbnQgKHJldmlldyBpc3N1ZXMpPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+UmV2aWV3IGNvbW1lbnRzLCBhcHByb3ZhbDwvUHJvZHVjZXM+CiAgICA8L0FnZW50PgogICAgCiAgICA8QWdlbnQgbmFtZT0iU2VjdXJpdHkgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+U2NhbnMgZm9yIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllczwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+Q29kZSBSZXZpZXcgQWdlbnQgKGNvZGUgdG8gc2Nhbik8L1JlY2VpdmVzRnJvbT4KICAgICAgPEhhbmRzT2ZmVG8+Q0kvQ0QgQWdlbnQgKHNlY3VyaXR5IHZlcmlmaWVkKSBvciBEZXZlbG9wZXIgQWdlbnQgKHNlY3VyaXR5IGlzc3Vlcyk8L0hhbmRzT2ZmVG8+CiAgICAgIDxQcm9kdWNlcz5TZWN1cml0eSByZXBvcnRzLCB2dWxuZXJhYmlsaXR5IGZpeGVzPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJEb2N1bWVudGF0aW9uIEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPlVwZGF0ZXMgZG9jdW1lbnRhdGlvbjwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+Q29kZSBSZXZpZXcgQWdlbnQgKGNvZGUgdG8gZG9jdW1lbnQpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPkNJL0NEIEFnZW50IChkb2NzIHVwZGF0ZWQpPC9IYW5kc09mZlRvPgogICAgICA8UHJvZHVjZXM+UkVBRE1FLCBBUEkgZG9jcywgaW5saW5lIGNvbW1lbnRzPC9Qcm9kdWNlcz4KICAgIDwvQWdlbnQ+CiAgICAKICAgIDxBZ2VudCBuYW1lPSJDSS9DRCBBZ2VudCI+CiAgICAgIDxEZXNjcmlwdGlvbj5IYW5kbGVzIGJ1aWxkIGFuZCBkZXBsb3ltZW50IHByb2Nlc3NlczwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+U2VjdXJpdHkgQWdlbnQsIERvY3VtZW50YXRpb24gQWdlbnQgKHZlcmlmaWVkIGNvZGUgYW5kIGRvY3MpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPlBlcmZvcm1hbmNlIEFnZW50IChkZXBsb3ltZW50IHJlYWR5KTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPkJ1aWxkIGFydGlmYWN0cywgZGVwbG95bWVudCBjb25maWd1cmF0aW9uczwvUHJvZHVjZXM+CiAgICA8L0FnZW50PgogICAgCiAgICA8QWdlbnQgbmFtZT0iUGVyZm9ybWFuY2UgQWdlbnQiPgogICAgICA8RGVzY3JpcHRpb24+VGVzdHMgYW5kIG9wdGltaXplcyBwZXJmb3JtYW5jZTwvRGVzY3JpcHRpb24+CiAgICAgIDxSZWNlaXZlc0Zyb20+Q0kvQ0QgQWdlbnQgKGRlcGxveWVkIGNvZGUpPC9SZWNlaXZlc0Zyb20+CiAgICAgIDxIYW5kc09mZlRvPk9yY2hlc3RyYXRvciBBZ2VudCAocGVyZm9ybWFuY2UgdmVyaWZpZWQpIG9yIERldmVsb3BlciBBZ2VudCAocGVyZm9ybWFuY2UgaXNzdWVzKTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPlBlcmZvcm1hbmNlIHJlcG9ydHMsIG9wdGltaXphdGlvbiByZWNvbW1lbmRhdGlvbnM8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICAgIAogICAgPEFnZW50IG5hbWU9IkRlYnVnIEFnZW50Ij4KICAgICAgPERlc2NyaXB0aW9uPkRpYWdub3NlcyBhbmQgcmVzb2x2ZXMgaXNzdWVzPC9EZXNjcmlwdGlvbj4KICAgICAgPFJlY2VpdmVzRnJvbT5UZXN0aW5nIEFnZW50ICh0ZXN0IGZhaWx1cmVzKTwvUmVjZWl2ZXNGcm9tPgogICAgICA8SGFuZHNPZmZUbz5EZXZlbG9wZXIgQWdlbnQgKGlzc3VlcyBpZGVudGlmaWVkKTwvSGFuZHNPZmZUbz4KICAgICAgPFByb2R1Y2VzPkRlYnVnIHJlcG9ydHMsIGZpeCByZWNvbW1lbmRhdGlvbnM8L1Byb2R1Y2VzPgogICAgPC9BZ2VudD4KICA8L0FnZW50cz4KICAKICA8RXJyb3JIYW5kbGluZz4KICAgIDxFcnJvclBhdGggbmFtZT0iVGVzdCBGYWlsdXJlcyI+CiAgICAgIDxGbG93PlRlc3Rpbmcg4oaSIERlYnVnIOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICAgIAogICAgPEVycm9yUGF0aCBuYW1lPSJMaW50aW5nIElzc3VlcyI+CiAgICAgIDxGbG93PlN0eWxlIEFnZW50IOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICAgIAogICAgPEVycm9yUGF0aCBuYW1lPSJSZXZpZXcgSXNzdWVzIj4KICAgICAgPEZsb3c+Q29kZSBSZXZpZXcg4oaSIERldmVsb3BlcjwvRmxvdz4KICAgIDwvRXJyb3JQYXRoPgogICAgCiAgICA8RXJyb3JQYXRoIG5hbWU9IlNlY3VyaXR5IFZ1bG5lcmFiaWxpdGllcyI+CiAgICAgIDxGbG93PlNlY3VyaXR5IOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICAgIAogICAgPEVycm9yUGF0aCBuYW1lPSJQZXJmb3JtYW5jZSBQcm9ibGVtcyI+CiAgICAgIDxGbG93PlBlcmZvcm1hbmNlIOKGkiBEZXZlbG9wZXI8L0Zsb3c+CiAgICA8L0Vycm9yUGF0aD4KICA8L0Vycm9ySGFuZGxpbmc+CiAgCiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlIG5hbWU9IkNvbnRpbnVvdXMgRmxvdyI+CiAgICAgIDxEZXNjcmlwdGlvbj5NYWludGFpbiBhIGNvbnRpbnVvdXMgZmxvdyBvZiB3b3JrIHRocm91Z2ggdGhlIGFnZW50IHBpcGVsaW5lPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgCiAgICA8UHJpbmNpcGxlIG5hbWU9IkVhcmx5IERldGVjdGlvbiI+CiAgICAgIDxEZXNjcmlwdGlvbj5EZXRlY3QgYW5kIGZpeCBpc3N1ZXMgYXMgZWFybHkgYXMgcG9zc2libGUgaW4gdGhlIHdvcmtmbG93PC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogICAgCiAgICA8UHJpbmNpcGxlIG5hbWU9IkNsZWFyIEhhbmRvZmZzIj4KICAgICAgPERlc2NyaXB0aW9uPkVuc3VyZSBjbGVhciBoYW5kb2ZmcyBiZXR3ZWVuIGFnZW50cyB3aXRoIHdlbGwtZGVmaW5lZCBkZWxpdmVyYWJsZXM8L0Rlc2NyaXB0aW9uPgogICAgPC9QcmluY2lwbGU+CiAgICAKICAgIDxQcmluY2lwbGUgbmFtZT0iRmVlZGJhY2sgTG9vcHMiPgogICAgICA8RGVzY3JpcHRpb24+TWFpbnRhaW4gZmVlZGJhY2sgbG9vcHMgdG8gaW1wcm92ZSBjb2RlIHF1YWxpdHkgYW5kIGFnZW50IHBlcmZvcm1hbmNlPC9EZXNjcmlwdGlvbj4KICAgIDwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICAKICA8VHJhY2tpbmc+CiAgICA8TWV0cmljIG5hbWU9IkN5Y2xlIFRpbWUiPgogICAgICA8RGVzY3JpcHRpb24+VGltZSBmcm9tIHByb2plY3QgaW5pdGlhdGlvbiB0byBjb21wbGV0aW9uPC9EZXNjcmlwdGlvbj4KICAgIDwvTWV0cmljPgogICAgCiAgICA8TWV0cmljIG5hbWU9Iklzc3VlIFJlc29sdXRpb24gVGltZSI+CiAgICAgIDxEZXNjcmlwdGlvbj5UaW1lIHRvIHJlc29sdmUgaXNzdWVzIGF0IGVhY2ggc3RhZ2U8L0Rlc2NyaXB0aW9uPgogICAgPC9NZXRyaWM+CiAgICAKICAgIDxNZXRyaWMgbmFtZT0iQWdlbnQgVXRpbGl6YXRpb24iPgogICAgICA8RGVzY3JpcHRpb24+SG93IGVmZmVjdGl2ZWx5IGVhY2ggYWdlbnQgaXMgdXRpbGl6ZWQ8L0Rlc2NyaXB0aW9uPgogICAgPC9NZXRyaWM+CiAgPC9UcmFja2luZz4KPC9Qcm90b2NvbD4g"
    )
    embedded[".erasmus/templates/meta_rules.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPE1ldGFSdWxlcz4KICA8IS0tQVJDSElURUNUVVJFLS0+CiAgPCEtLS9BUkNISVRFQ1RVUkUtLT4KICA8IS0tUFJPR1JFU1MtLT4KICA8IS0tL1BST0dSRVNTLS0+CiAgPCEtLVRBU0tTLS0+CiAgPCEtLS9UQVNLUy0tPgogIDwhLS1QUk9UT0NPTC0tPgogIDwhLS0vUFJPVE9DT0wtLT4KPC9NZXRhUnVsZXM+IA=="
    )
    embedded[".erasmus/templates/progress.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFByb2dyZXNzPgogIDxQaGFzZSBuYW1lPSJQaGFzZSBOYW1lIj4KICAgIDxTdGF0dXM+U3RhdHVzIChlLmcuLCBDb21wbGV0ZWQsIEluIFByb2dyZXNzLCBQbGFubmVkKTwvU3RhdHVzPgogICAgPFRhc2tzPgogICAgICA8VGFzayBuYW1lPSJUYXNrIE5hbWUiPgogICAgICAgIDxTdGF0dXM+U3RhdHVzPC9TdGF0dXM+CiAgICAgICAgPFN1YnRhc2tzPgogICAgICAgICAgPFN1YnRhc2sgbmFtZT0iU3VidGFzayBOYW1lIj4KICAgICAgICAgICAgPFN0YXR1cz5TdGF0dXM8L1N0YXR1cz4KICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgIDwhLS0gQWRkIG1vcmUgc3VidGFza3MgYXMgbmVlZGVkIC0tPgogICAgICAgIDwvU3VidGFza3M+CiAgICAgIDwvVGFzaz4KICAgICAgPCEtLSBBZGQgbW9yZSB0YXNrcyBhcyBuZWVkZWQgLS0+CiAgICA8L1Rhc2tzPgogIDwvUGhhc2U+CiAgPCEtLSBBZGQgbW9yZSBwaGFzZXMgYXMgbmVlZGVkIC0tPgogIAogIDxDdXJyZW50Rm9jdXM+CiAgICA8UGhhc2U+Q3VycmVudCBwaGFzZSBuYW1lPC9QaGFzZT4KICAgIDxQcmlvcml0eT5DdXJyZW50IHByaW9yaXR5PC9Qcmlvcml0eT4KICAgIDxOZXh0VGFzaz5OZXh0IHRhc2sgdG8gd29yayBvbjwvTmV4dFRhc2s+CiAgPC9DdXJyZW50Rm9jdXM+CiAgCiAgPE5vdGVzPgogICAgPE5vdGU+Tm90ZSAxPC9Ob3RlPgogICAgPE5vdGU+Tm90ZSAyPC9Ob3RlPgogICAgPCEtLSBBZGQgbW9yZSBub3RlcyBhcyBuZWVkZWQgLS0+CiAgPC9Ob3Rlcz4KPC9Qcm9ncmVzcz4g"
    )
    embedded[".erasmus/templates/protocols/ci_cd.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDEwPC9JZD4KICAgIDxSb2xlPmNpX2NkX21hbmFnZW1lbnQ8L1JvbGU+CiAgICA8VHJpZ2dlcnM+c2VjdXJpdHlfdmVyaWZpZWQsIGRvY3NfdXBkYXRlZDwvVHJpZ2dlcnM+CiAgICA8UHJvZHVjZXM+YnVpbGRfYXJ0aWZhY3RzLCBkZXBsb3ltZW50X2NvbmZpZ3M8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmNvZGUsIHNlY3VyaXR5IHJlcG9ydHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgTWFuYWdlIGNvbnRpbnVvdXMgaW50ZWdyYXRpb24gYW5kIGRlcGxveW1lbnQgcHJvY2Vzc2VzLiBUcmFjayBDSS9DRCB0YXNrcyBhbmQgcHJvZ3Jlc3MgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIENJL0NEIHVwZGF0ZXMuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgY29kZSBhbmQgaWRlbnRpZnkgYXJlYXMgbmVlZGluZyBDSS9DRCB1cGRhdGVzLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RG9jdW1lbnQgYW55IGdhcHMgb3IgaW1wcm92ZW1lbnRzIG5lZWRlZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBDSS9DRCB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIENJL0NEIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgaXMgcmVhZHkgZm9yIENJL0NEIHdpdGggcHJvcGVyIGJ1aWxkIGFuZCBkZXBsb3ltZW50IGNvbmZpZ3VyYXRpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5UcmFjayBhbGwgQ0kvQ0QgdGFza3MgYW5kIGltcHJvdmVtZW50cyBpbiAuY3R4LnRhc2tzLnhtbC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VXBkYXRlIC5jdHgucHJvZ3Jlc3MueG1sIHdpdGggQ0kvQ0Qgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbW11bmljYXRlIENJL0NEIGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy54bWwgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIENJL0NEIHRhc2tzLCBpbXByb3ZlbWVudHMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgQ0kvQ0QgdGFza3MgYXJlIGNvbXBsZXRlZC48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g"
    )
    embedded[".erasmus/templates/protocols/code_review.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA3PC9JZD4KICAgIDxSb2xlPmNvZGVfcXVhbGl0eV9hc3Nlc3NtZW50PC9Sb2xlPgogICAgPFRyaWdnZXJzPnRlc3RzX3Bhc3NpbmcsIHN0eWxlX3ZlcmlmaWVkPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5yZXZpZXdfY29tbWVudHMsIGFwcHJvdmFsPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCB0ZXN0X2ZpbGVzLCBzdHlsZV9yZXBvcnRzLCAuY3R4LnByb2dyZXNzLnhtbCwgLmN0eC50YXNrcy54bWw8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIFByb3ZpZGUgZmVlZGJhY2sgb24gcHVsbCByZXF1ZXN0cywgY29tbWl0cywgb3IgZGlmZnMgdG8gZW5zdXJlIGNvZGUgcXVhbGl0eSBhbmQgY29uc2lzdGVuY3kuIFRyYWNrIHJldmlldyBjb21tZW50cyBhbmQgYXBwcm92YWxzIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPk1vbml0b3IgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGZvciBuZXcgY29kZSBjaGFuZ2VzIHJlcXVpcmluZyByZXZpZXcuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgY29kZSBmb3IgY2xhcml0eSwgbmFtaW5nLCBkdXBsaWNhdGlvbiwgYW5kIGFkaGVyZW5jZSB0byBwcm9qZWN0IHN0cnVjdHVyZS48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IHJldmlldyBjb21tZW50cyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gd2l0aCBjbGVhciBkZXNjcmlwdGlvbnMgYW5kIHN1Z2dlc3Rpb25zLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgdGhlIHJldmlldy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIHJldmlldyBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgcHJldmVudGlvbi48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgY2xhcml0eSwgbmFtaW5nLCBhbmQgYWRoZXJlbmNlIHRvIHByb2plY3Qgc3RydWN0dXJlLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5UcmFjayBhbGwgcmV2aWV3IGNvbW1lbnRzIGFuZCBhcHByb3ZhbHMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHJldmlldyBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgcmV2aWV3IGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy54bWwgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIHJldmlldyBjb21tZW50cywgYXBwcm92YWxzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHJldmlld3MgcHJvY2VlZC48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g"
    )
    embedded[".erasmus/templates/protocols/testing.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA0PC9JZD4KICAgIDxSb2xlPnRlc3RfZGV2ZWxvcG1lbnQ8L1JvbGU+CiAgICA8VHJpZ2dlcnM+Y29kZV9pbXBsZW1lbnRhdGlvbiwgY29kZV9jaGFuZ2VzPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz50ZXN0X2ZpbGVzLCB0ZXN0X3Jlc3VsdHM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MueG1sLCAuY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sPC9Db25zdW1lcz4KICA8L01ldGFkYXRhPgogIDxPYmplY3RpdmU+CiAgICBEZXNpZ24sIGltcGxlbWVudCwgYW5kIGV2YWx1YXRlIHRlc3RzIHRoYXQgZ3VpZGUgYW5kIHZhbGlkYXRlIGRldmVsb3BtZW50LiBVc2UgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+IHRvIHRyYWNrIHRlc3QgcmVxdWlyZW1lbnRzIGFuZCBjb3ZlcmFnZSBmb3IgZWFjaCBkZXZlbG9wbWVudCB0YXNrLgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPkZvciBldmVyeSBuZXcgdGFzayBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT46CiAgICAgIDxTdWJzdGVwPlJldmlldyA8RmlsZT4uY3R4LmFyY2hpdGVjdHVyZS54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIGNvbnRleHQgYW5kIHJlcXVpcmVtZW50cy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPldyaXRlIGZhaWxpbmcgdGVzdHMgdGhhdCBkZWZpbmUgc3VjY2VzcyBmb3IgdGhlIHRhc2ssIGRvY3VtZW50aW5nIHRlc3QgaW50ZW50IGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlBsYWNlIHRlc3QgZmlsZXMgaW4gdGhlIGFwcHJvcHJpYXRlIHN0cnVjdHVyZSBhbmQgdXBkYXRlIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB3aXRoIHRlc3Qgc3RhdHVzLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPkR1cmluZyBkZXZlbG9wbWVudDoKICAgICAgPFN1YnN0ZXA+UmV2aWV3IHVwZGF0ZWQgY29kZSBhbmQgcmUtcnVuIHRlc3RzLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB3aXRoIHRlc3QgcmVzdWx0cyBhbmQgYW55IGlzc3VlcyBmb3VuZC48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5BZnRlciBhIHRhc2sgaXMgbWFya2VkIGNvbXBsZXRlOgogICAgICA8U3Vic3RlcD5WYWxpZGF0ZSBlZGdlIGNhc2VzLCBlcnJvciBoYW5kbGluZywgYW5kIHJlZ3Jlc3Npb25zLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+U3VnZ2VzdCBpbXByb3ZlbWVudHMgaW4gdGVzdCBjb3ZlcmFnZSBvciBjb2RlIGxvZ2ljLCByZWNvcmRpbmcgc3VnZ2VzdGlvbnMgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RmxhZyBhbnkgbWlzc2luZyBhc3NlcnRpb25zIG9yIHVudGVzdGVkIHBhdGhzIGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+V3JpdGUgdGVzdHMgYmVmb3JlIGltcGxlbWVudGluZyBmdW5jdGlvbmFsaXR5IChUREQpLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5UcmFjayBhbGwgdGVzdCByZXF1aXJlbWVudHMgYW5kIHJlc3VsdHMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkVuc3VyZSBjb21wcmVoZW5zaXZlIGNvdmVyYWdlIGZvciBlYWNoIHRhc2sgYW5kIG1pbGVzdG9uZS48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgdGVzdCBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MueG1sIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCB0ZXN0IHJlcXVpcmVtZW50cywgY292ZXJhZ2UsIGFuZCByZXN1bHRzIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBFYWNoIHRhc2sncyB0ZXN0IHN0YXR1cyBpcyB1cGRhdGVkIGFzIHdvcmsgcHJvY2VlZHMuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=="
    )
    embedded[".erasmus/templates/protocols/developer.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAyPC9JZD4KICAgIDxSb2xlPmNvZGVfaW1wbGVtZW50YXRpb248L1JvbGU+CiAgICA8VHJpZ2dlcnM+YXJjaGl0ZWN0dXJlX2NvbXBsZXRlLCBjb2RlX3Jldmlld19pc3N1ZXMsIHRlc3RfZmFpbHVyZXMsIHN0eWxlX2lzc3Vlcywgc2VjdXJpdHlfaXNzdWVzLCBwZXJmb3JtYW5jZV9pc3N1ZXM8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgudGFza3MueG1sLCBkb2N1bWVudGF0aW9uLCB0ZXN0cywgY29kZV9yZXZpZXdfZmVlZGJhY2s8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPi5jdHguYXJjaGl0ZWN0dXJlLnhtbCwgLmN0eC5wcm9ncmVzcy54bWwsIC5jdHgudGFza3MueG1sLCBjb2RlX3Jldmlld19mZWVkYmFjaywgdGVzdF9yZXN1bHRzLCBzdHlsZV9yZXBvcnRzLCBkZXBlbmRlbmN5X3JlcG9ydHM8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIEltcGxlbWVudCByb2J1c3QsIG1haW50YWluYWJsZSwgYW5kIHdlbGwtZG9jdW1lbnRlZCBjb2RlIGJhc2VkIG9uIHByb2plY3QgZG9jdW1lbnRhdGlvbi4gSW50ZXJwcmV0IDxGaWxlPi5jdHguYXJjaGl0ZWN0dXJlLnhtbDwvRmlsZT4sIGZvbGxvdyB0aGUgc3ByaW50IHBsYW4gaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+LCBhbmQgZ2VuZXJhdGUsIHVwZGF0ZSwgYW5kIGNvbXBsZXRlIHRhc2tzIGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi4gRW5zdXJlIGNvZGUgaXMgcmVhZHkgZm9yIHJldmlldywgdGVzdGluZywgYW5kIGludGVncmF0aW9uLgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPlJlYWQgYW5kIHVuZGVyc3RhbmQgdGhlIHN5c3RlbSBkZXNpZ24gYW5kIHJlcXVpcmVtZW50cyBmcm9tIDxGaWxlPi5jdHguYXJjaGl0ZWN0dXJlLnhtbDwvRmlsZT4uPC9TdGVwPgogICAgPFN0ZXA+UmV2aWV3IHRoZSBjb21wb25lbnQgcm9hZG1hcCBhbmQgc3ByaW50IHBsYW5uaW5nIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPi48L1N0ZXA+CiAgICA8U3RlcD5CcmVhayBkb3duIHRoZSBuZXh0IGNvbXBvbmVudCBvciBtaWxlc3RvbmUgZnJvbSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gaW50byBhY3Rpb25hYmxlIGRldmVsb3BtZW50IHRhc2tzLCByZWNvcmRpbmcgdGhlbSBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggdGFzayBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT46CiAgICAgIDxTdWJzdGVwPlNldCB1cCBvciB1cGRhdGUgdGhlIGRldmVsb3BtZW50IGVudmlyb25tZW50IGFuZCBkZXBlbmRlbmNpZXMgYXMgbmVlZGVkLiBEb2N1bWVudCBhbnkgY2hhbmdlcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gb3IgYSBSRUFETUUuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5JbXBsZW1lbnQgdGhlIGNvZGUsIGVuc3VyaW5nIHN0cm9uZyB0eXBpbmcsIGRvY3VtZW50YXRpb24sIG1haW50YWluYWJpbGl0eSwgYW5kIGFkaGVyZW5jZSB0byBjb2RlIHN0eWxlIGFuZCBsaW50aW5nIHN0YW5kYXJkcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPldyaXRlIG9yIHVwZGF0ZSB0ZXN0cyB0byBjb3ZlciBuZXcgb3IgY2hhbmdlZCBmdW5jdGlvbmFsaXR5LiBFbnN1cmUgYWxsIHRlc3RzIHBhc3MgYmVmb3JlIG1hcmtpbmcgYSB0YXNrIGNvbXBsZXRlLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHByb2dyZXNzLCBibG9ja2VycywgYW5kIGNvbXBsZXRpb24uIENvbW11bmljYXRlIGJsb2NrZXJzIG9yIHVuY2xlYXIgcmVxdWlyZW1lbnRzIHByb21wdGx5LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+Q29tbWl0IGNoYW5nZXMgdG8gdmVyc2lvbiBjb250cm9sIHdpdGggY2xlYXIsIGRlc2NyaXB0aXZlIG1lc3NhZ2VzLiBVc2UgZmVhdHVyZSBicmFuY2hlcyBmb3Igc2lnbmlmaWNhbnQgY2hhbmdlcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlJlZmFjdG9yIGNvZGUgYXMgbmVlZGVkIGZvciBjbGFyaXR5LCBwZXJmb3JtYW5jZSwgYW5kIG1haW50YWluYWJpbGl0eS4gRG9jdW1lbnQgc2lnbmlmaWNhbnQgcmVmYWN0b3JpbmcgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+UHJlcGFyZSBjb2RlIGZvciByZXZpZXc6IGVuc3VyZSBkb2N1bWVudGF0aW9uIGlzIHVwIHRvIGRhdGUsIGNvZGUgc3R5bGUgaXMgY29uc2lzdGVudCwgYW5kIGFsbCB0ZXN0cyBwYXNzLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPlJlc3BvbmQgdG8gY29kZSByZXZpZXcgZmVlZGJhY2ssIG1ha2luZyBuZWNlc3NhcnkgY2hhbmdlcyBhbmQgZG9jdW1lbnRpbmcgcmVzb2x1dGlvbnMuPC9TdGVwPgogICAgPFN0ZXA+Q29sbGFib3JhdGUgd2l0aCB0ZXN0aW5nLCBzdHlsZSwgYW5kIENJL0NEIGFnZW50cyB0byBlbnN1cmUgaW50ZWdyYXRpb24gYW5kIGRlcGxveW1lbnQgcmVhZGluZXNzLjwvU3RlcD4KICAgIDxTdGVwPldoZW4gYWxsIHRhc2tzIGZvciBhIGNvbXBvbmVudCBhcmUgY29tcGxldGUsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCBtaWxlc3RvbmUgY29tcGxldGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Qcm9hY3RpdmVseSBjb21tdW5pY2F0ZSB3aXRoIHRoZSBQcm9kdWN0IE93bmVyIG9yIHN0YWtlaG9sZGVycyBpZiByZXF1aXJlbWVudHMgYXJlIHVuY2xlYXIgb3IgYmxvY2tlcnMgYXJlIGVuY291bnRlcmVkLjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5Bc3N1bWUgbGltaXRlZCBjb250ZXh0OyBhdm9pZCBkZXN0cnVjdGl2ZSBlZGl0cyBhbmQgcHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3IgdW5sZXNzIGNoYW5nZSBpcyBpbnRlbnRpb25hbC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RmF2b3IgaW5jcmVtZW50YWwsIHRlc3QtZHJpdmVuIGltcHJvdmVtZW50IGluIHN0cnVjdHVyZSwgY2xhcml0eSwgYW5kIHBlcmZvcm1hbmNlLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Vc2UgbW9kZXJuIHBhdHRlcm5zLCBzdHJvbmcgdHlwaW5nLCBhbmQgY2xlYXIsIGRlc2NyaXB0aXZlIG5hbWluZyBjb252ZW50aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+V3JpdGUgb3IgdmFsaWRhdGUgdGVzdHMgZm9yIGVhY2ggdGFzazsgbm8gY29tcG9uZW50IGlzIGNvbXBsZXRlIHdpdGhvdXQgcGFzc2luZyB0ZXN0cy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgc3R5bGUgYW5kIGxpbnRpbmcgY29tcGxpYW5jZSBiZWZvcmUgcmV2aWV3LjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Eb2N1bWVudCBhbGwgc2lnbmlmaWNhbnQgY2hhbmdlcyBhbmQgZGVjaXNpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Vc2UgdmVyc2lvbiBjb250cm9sIGJlc3QgcHJhY3RpY2VzOiBmcmVxdWVudCBjb21taXRzLCBjbGVhciBtZXNzYWdlcywgYW5kIGZlYXR1cmUgYnJhbmNoZXMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkFzayBxdWVzdGlvbnMgZWFybHkgdG8gcmVzb2x2ZSB1bmNlcnRhaW50eSBhbmQgY29tbXVuaWNhdGUgYmxvY2tlcnMgcHJvbXB0bHkuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbGxhYm9yYXRlIHdpdGggb3RoZXIgYWdlbnRzIGFuZCBzdGFrZWhvbGRlcnMgZm9yIHF1YWxpdHkgYW5kIGludGVncmF0aW9uLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPFVzZXM+dmVyc2lvbl9jb250cm9sIChnaXQpPC9Vc2VzPgogICAgPFVzZXM+dGVzdF9yZXN1bHRzPC9Vc2VzPgogICAgPFVzZXM+Y29kZV9yZXZpZXdfZmVlZGJhY2s8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIGRldmVsb3BtZW50IHByb2dyZXNzLCB0YXNrIGJyZWFrZG93bnMsIGFuZCBjb2RlIHJldmlldyBmZWVkYmFjayBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcyBhbmQgdmVyc2lvbiBjb250cm9sLiBFYWNoIHRhc2sncyBzdGF0dXMsIG5vdGVzLCBhbmQgcmVsYXRlZCBkb2N1bWVudGF0aW9uIGFyZSB1cGRhdGVkIGFzIHdvcmsgcHJvY2VlZHMuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=="
    )
    embedded[".erasmus/templates/protocols/style.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA1PC9JZD4KICAgIDxSb2xlPmNvZGVfc3R5bGVfdmVyaWZpY2F0aW9uPC9Sb2xlPgogICAgPFRyaWdnZXJzPmNvZGVfaW1wbGVtZW50YXRpb24sIGNvZGVfY2hhbmdlczwvVHJpZ2dlcnM+CiAgICA8UHJvZHVjZXM+c3R5bGVfcmVwb3J0cywgbGludGluZ19maXhlczwvUHJvZHVjZXM+CiAgICA8Q29uc3VtZXM+aW1wbGVtZW50YXRpb25fY29kZSwgLmN0eC5wcm9ncmVzcy54bWwsIC5jdHgudGFza3MueG1sPC9Db25zdW1lcz4KICA8L01ldGFkYXRhPgogIDxPYmplY3RpdmU+CiAgICBFbnN1cmUgdGhlIGNvZGViYXNlIGFkaGVyZXMgdG8gY29uc2lzdGVudCBjb2Rpbmcgc3RhbmRhcmRzIGFuZCBiZXN0IHByYWN0aWNlcyB1c2luZyBydWZmIGFuZCBteXB5LiBUcmFjayBzdHlsZSBpc3N1ZXMgYW5kIGxpbnRpbmcgZml4ZXMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHN0eWxlIHZlcmlmaWNhdGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBjb2RlIGNoYW5nZToKICAgICAgPFN1YnN0ZXA+UnVuIHJ1ZmYgYW5kIG15cHkgdG8gY2hlY2sgZm9yIGxpbnRpbmcgZXJyb3JzIGFuZCBzdHlsZSB2aW9sYXRpb25zLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RG9jdW1lbnQgYW55IGlzc3VlcyBmb3VuZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4gd2l0aCBjbGVhciBkZXNjcmlwdGlvbnMgYW5kIHN1Z2dlc3RlZCBmaXhlcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCB0aGUgc3RhdHVzIG9mIHN0eWxlIHZlcmlmaWNhdGlvbi48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIHN0eWxlIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBwcmV2ZW50aW9uLjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5NYWludGFpbiBjb25zaXN0ZW50IGNvZGUgc3R5bGUgYW5kIGZvcm1hdHRpbmcgYWNyb3NzIHRoZSBjb2RlYmFzZS48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHN0eWxlIGlzc3VlcyBhbmQgZml4ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHN0eWxlIHZlcmlmaWNhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgc3R5bGUgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgc3R5bGUgaXNzdWVzLCBsaW50aW5nIGZpeGVzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHN0eWxlIHZlcmlmaWNhdGlvbiBwcm9jZWVkcy48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g"
    )
    embedded[".erasmus/templates/protocols/debug.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDEyPC9JZD4KICAgIDxSb2xlPmRlYnVnZ2luZ19hbmRfaXNzdWVfZGlhZ25vc2lzPC9Sb2xlPgogICAgPFRyaWdnZXJzPnRlc3RfZmFpbHVyZXMsIHJ1bnRpbWVfZXJyb3JzLCBidWdfcmVwb3J0cywgcGVyZm9ybWFuY2VfaXNzdWVzPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5kZWJ1Z19yZXBvcnRzLCBmaXhfcmVjb21tZW5kYXRpb25zLCByZWdyZXNzaW9uX3Rlc3RzPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCB0ZXN0X3Jlc3VsdHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgSWRlbnRpZnksIGRpYWdub3NlLCBhbmQgcmVzb2x2ZSBpc3N1ZXMgaW4gdGhlIGNvZGViYXNlLCBpbmNsdWRpbmcgdGVzdCBmYWlsdXJlcywgcnVudGltZSBlcnJvcnMsIGxvZ2ljYWwgYnVncywgYW5kIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLiBEb2N1bWVudCBhbGwgZXJyb3JzLCBkaWFnbm9zdGljIHN0ZXBzLCBhbmQgc29sdXRpb25zIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LiBFbnN1cmUgZml4ZXMgYXJlIHZhbGlkYXRlZCBhbmQgZG8gbm90IGludHJvZHVjZSByZWdyZXNzaW9ucy4KICA8L09iamVjdGl2ZT4KICA8V29ya2Zsb3c+CiAgICA8U3RlcD5Nb25pdG9yIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+IGZvciBuZXcgb3Igb25nb2luZyBlcnJvcnMsIGJ1Z3MsIG9yIHRlc3QgZmFpbHVyZXMuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggaXNzdWU6CiAgICAgIDxTdWJzdGVwPlJlcHJvZHVjZSB0aGUgaXNzdWUgYW5kIGRvY3VtZW50IHJlcHJvZHVjdGlvbiBzdGVwcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Jc29sYXRlIHRoZSByb290IGNhdXNlIGFuZCByZWNvcmQgYWxsIGRpYWdub3N0aWMgc3RlcHMgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+Rm9ybXVsYXRlIGh5cG90aGVzZXMgYW5kIHRlc3QgcG90ZW50aWFsIGZpeGVzLCB0cmFja2luZyBlYWNoIGF0dGVtcHQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+V2hlbiBhIGZpeCBpcyBmb3VuZCwgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byBtYXJrIHRoZSBpc3N1ZSBhcyByZXNvbHZlZCBhbmQgc3VtbWFyaXplIHRoZSBzb2x1dGlvbi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGxlc3NvbnMgbGVhcm5lZCwgbmV3IHRlc3RzLCBvciByZWdyZXNzaW9uIGNoZWNrcyBhZGRlZCB0byBwcmV2ZW50IHJlY3VycmVuY2UuPC9TdWJzdGVwPgogICAgPC9TdGVwPgogICAgPFN0ZXA+Rm9yIHJlY3VycmluZyBvciBzeXN0ZW1pYyBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucywgcm9vdCBjYXVzZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBwcmV2ZW50aW9uLjwvU3RlcD4KICAgIDxTdGVwPkNvbW11bmljYXRlIGJsb2NrZXJzLCB1bnJlc29sdmVkIGlzc3Vlcywgb3IgcmVxdWlyZWQgZXNjYWxhdGlvbnMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGZvciB0ZWFtIHZpc2liaWxpdHkgYW5kIGZvbGxvdy11cC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+VHJhY2UgaXNzdWVzIHRvIHRoZWlyIHJvb3QgY2F1c2UsIG5vdCBqdXN0IHN5bXB0b21zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Eb2N1bWVudCBhbGwgZGlhZ25vc3RpYyBzdGVwcywgYXR0ZW1wdGVkIHNvbHV0aW9ucywgYW5kIG91dGNvbWVzIGluIC5jdHgudGFza3MueG1sLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5VcGRhdGUgLmN0eC5wcm9ncmVzcy54bWwgd2l0aCBlcnJvciBzdGF0dXMsIHJlc29sdXRpb24gbm90ZXMsIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkVuc3VyZSBmaXhlcyBkbyBub3QgaW50cm9kdWNlIHJlZ3Jlc3Npb25zOyBhZGQgb3IgdXBkYXRlIHRlc3RzIGFzIG5lZWRlZC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgYmxvY2tlcnMgb3IgdW5yZXNvbHZlZCBpc3N1ZXMgcHJvbXB0bHkgZm9yIHRlYW0gYXdhcmVuZXNzLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Qcm9tb3RlIGtub3dsZWRnZSBzaGFyaW5nIGJ5IGRvY3VtZW50aW5nIGxlc3NvbnMgbGVhcm5lZCBhbmQgcGF0dGVybnMgb2JzZXJ2ZWQuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8VXNlcz50ZXN0X3Jlc3VsdHM8L1VzZXM+CiAgICA8VXNlcz5yZWdyZXNzaW9uX3Rlc3RzPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBlcnJvcnMsIGRpYWdub3N0aWMgc3RlcHMsIGF0dGVtcHRlZCBzb2x1dGlvbnMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgaXNzdWVzIGFyZSByZXNvbHZlZCBvciByZXF1aXJlIGVzY2FsYXRpb24uPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=="
    )
    embedded[".erasmus/templates/protocols/orchestration.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAxPC9JZD4KICAgIDxSb2xlPm9yY2hlc3RyYXRpb248L1JvbGU+CiAgICA8VHJpZ2dlcnM+cHJvamVjdF9zdGFydCwgcGVyZm9ybWFuY2VfdmVyaWZpZWQ8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPndvcmtmbG93X3N0YXR1cywgYWdlbnRfYXNzaWdubWVudHM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPkFsbCBhZ2VudCBvdXRwdXRzLCAuY3R4LnByb2dyZXNzLnhtbCwgLmN0eC50YXNrcy54bWw8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIE9yY2hlc3RyYXRlIHRoZSBkZXZlbG9wbWVudCB3b3JrZmxvdyBhbmQgbWFuYWdlIGFnZW50IGFzc2lnbm1lbnRzLiBNb25pdG9yIGFuZCB1cGRhdGUgb3JjaGVzdHJhdGlvbiB0YXNrcyBpbiA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gYW5kIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi4KICA8L09iamVjdGl2ZT4KICA8V29ya2Zsb3c+CiAgICA8U3RlcD5Nb25pdG9yIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBmb3IgcHJvamVjdCBtaWxlc3RvbmVzIGFuZCBhZ2VudCBhc3NpZ25tZW50cy48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBtaWxlc3RvbmU6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgcHJvamVjdCBzdGF0dXMgYW5kIGlkZW50aWZ5IG5lY2Vzc2FyeSBhZ2VudCBhc3NpZ25tZW50cy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBvcmNoZXN0cmF0aW9uIHRhc2tzIG9yIHVwZGF0ZXMgbmVlZGVkIGluIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPlVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gdG8gcmVmbGVjdCB0aGUgc3RhdHVzIG9mIG9yY2hlc3RyYXRpb24gdGFza3MuPC9TdWJzdGVwPgogICAgPC9TdGVwPgogICAgPFN0ZXA+Rm9yIHJlY3VycmluZyBvcmNoZXN0cmF0aW9uIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIHNtb290aCBjb29yZGluYXRpb24gYmV0d2VlbiBhZ2VudHMgYW5kIHByb2plY3QgbWlsZXN0b25lcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIG9yY2hlc3RyYXRpb24gdGFza3MgYW5kIGFzc2lnbm1lbnRzIGluIC5jdHgudGFza3MueG1sLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5VcGRhdGUgLmN0eC5wcm9ncmVzcy54bWwgd2l0aCBvcmNoZXN0cmF0aW9uIHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Db21tdW5pY2F0ZSBvcmNoZXN0cmF0aW9uIGdhcHMgb3IgZmFpbHVyZXMgaW4gLmN0eC50YXNrcy54bWwgZm9yIGRldmVsb3BlciBmb2xsb3ctdXAuPC9QcmluY2lwbGU+CiAgPC9QcmluY2lwbGVzPgogIDxUcmFja2luZz4KICAgIDxVc2VzPi5jdHgucHJvZ3Jlc3MueG1sPC9Vc2VzPgogICAgPFVzZXM+LmN0eC50YXNrcy54bWw8L1VzZXM+CiAgICA8RGVzY3JpcHRpb24+QWxsIG9yY2hlc3RyYXRpb24gdGFza3MsIGFzc2lnbm1lbnRzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIG9yY2hlc3RyYXRpb24gdGFza3MgYXJlIGNvbXBsZXRlZC48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g"
    )
    embedded[".erasmus/templates/protocols/dependency.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDEzPC9JZD4KICAgIDxSb2xlPmRlcGVuZGVuY3lfbWFuYWdlbWVudDwvUm9sZT4KICAgIDxUcmlnZ2Vycz5jb2RlX2ltcGxlbWVudGF0aW9uLCBkZXBlbmRlbmN5X2NoZWNrPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5kZXBlbmRlbmN5X3JlcG9ydHMsIHVwZGF0ZXM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmNvZGUsIHJlcXVpcmVtZW50cywgLmN0eC5wcm9ncmVzcy54bWwsIC5jdHgudGFza3MueG1sPC9Db25zdW1lcz4KICA8L01ldGFkYXRhPgogIDxPYmplY3RpdmU+CiAgICBNYW5hZ2UgYW5kIHVwZGF0ZSBwcm9qZWN0IGRlcGVuZGVuY2llcy4gTW9uaXRvciBhbmQgdXBkYXRlIGRlcGVuZGVuY3kgdGFza3MgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGltcGxlbWVudGF0aW9ucyByZXF1aXJpbmcgZGVwZW5kZW5jeSBjaGVja3MuPC9TdGVwPgogICAgPFN0ZXA+Rm9yIGVhY2ggY29kZSBjaGFuZ2U6CiAgICAgIDxTdWJzdGVwPlJldmlldyB0aGUgY29kZSBhbmQgaWRlbnRpZnkgYW55IG5ldyBkZXBlbmRlbmNpZXMgb3IgdXBkYXRlcyBuZWVkZWQuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Eb2N1bWVudCBhbnkgZGVwZW5kZW5jeSBpc3N1ZXMgb3IgdXBkYXRlcyBuZWVkZWQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgZGVwZW5kZW5jeSB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIGRlcGVuZGVuY3kgaXNzdWVzLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIGltcHJvdmVtZW50LjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5FbnN1cmUgYWxsIGRlcGVuZGVuY2llcyBhcmUgdXAtdG8tZGF0ZSBhbmQgY29tcGF0aWJsZS48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIGRlcGVuZGVuY3kgdGFza3MgYW5kIHVwZGF0ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIGRlcGVuZGVuY3kgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbW11bmljYXRlIGRlcGVuZGVuY3kgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgZGVwZW5kZW5jeSB0YXNrcywgdXBkYXRlcywgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcy4gUHJvZ3Jlc3MgaXMgdXBkYXRlZCBhcyBkZXBlbmRlbmN5IHRhc2tzIGFyZSBjb21wbGV0ZWQuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=="
    )
    embedded[".erasmus/templates/protocols/debugging.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAzPC9JZD4KICAgIDxSb2xlPmlzc3VlX2RpYWdub3NpczwvUm9sZT4KICAgIDxUcmlnZ2Vycz50ZXN0X2ZhaWx1cmVzPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5kZWJ1Z19yZXBvcnRzLCBmaXhfcmVjb21tZW5kYXRpb25zPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5pbXBsZW1lbnRhdGlvbl9jb2RlLCB0ZXN0X3Jlc3VsdHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgSWRlbnRpZnksIGRpYWdub3NlLCBhbmQgcmVzb2x2ZSBpc3N1ZXMgaW4gdGhlIGNvZGViYXNlLCBmb2N1c2luZyBvbiBydW50aW1lIGVycm9ycywgbG9naWNhbCBidWdzLCBhbmQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuIERvY3VtZW50IGFsbCBlcnJvcnMgYW5kIGF0dGVtcHRlZCBzb2x1dGlvbnMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBvciBvbmdvaW5nIGVycm9ycyBhbmQgYnVncy48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBlcnJvciBvciBidWc6CiAgICAgIDxTdWJzdGVwPlJlcHJvZHVjZSB0aGUgaXNzdWUgYW5kIGRvY3VtZW50IHJlcHJvZHVjdGlvbiBzdGVwcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Jc29sYXRlIHRoZSBwcm9ibGVtIGFuZCByZWNvcmQgZGlhZ25vc3RpYyBzdGVwcyBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Gb3JtdWxhdGUgaHlwb3RoZXNlcyBhbmQgdGVzdCBwb3RlbnRpYWwgZml4ZXMsIHRyYWNraW5nIGVhY2ggYXR0ZW1wdCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5XaGVuIGEgZml4IGlzIGZvdW5kLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIG1hcmsgdGhlIGVycm9yIGFzIHJlc29sdmVkIGFuZCBzdW1tYXJpemUgdGhlIHNvbHV0aW9uLjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+RG9jdW1lbnQgbGVzc29ucyBsZWFybmVkIGFuZCBhbnkgbmV3IHRlc3RzIG9yIHJlZ3Jlc3Npb24gY2hlY2tzIGFkZGVkLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPkZvciByZWN1cnJpbmcgb3Igc3lzdGVtaWMgaXNzdWVzLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIHByZXZlbnRpb24uPC9TdGVwPgogIDwvV29ya2Zsb3c+CiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPlRyYWNlIGlzc3VlcyB0byB0aGVpciByb290IGNhdXNlLCBub3QganVzdCBzeW1wdG9tcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RG9jdW1lbnQgYWxsIGRpYWdub3N0aWMgc3RlcHMgYW5kIGF0dGVtcHRlZCBzb2x1dGlvbnMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIGVycm9yIHN0YXR1cyBhbmQgcmVzb2x1dGlvbiBub3Rlcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGZpeGVzIGRvIG5vdCBpbnRyb2R1Y2UgcmVncmVzc2lvbnM7IGFkZCBvciB1cGRhdGUgdGVzdHMgYXMgbmVlZGVkLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Db21tdW5pY2F0ZSBibG9ja2VycyBvciB1bnJlc29sdmVkIGlzc3VlcyBpbiAuY3R4LnByb2dyZXNzLnhtbCBmb3IgdGVhbSB2aXNpYmlsaXR5LjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBlcnJvcnMsIGRpYWdub3N0aWMgc3RlcHMsIGFuZCBhdHRlbXB0ZWQgc29sdXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIGlzc3VlcyBhcmUgcmVzb2x2ZWQgb3IgcmVxdWlyZSBlc2NhbGF0aW9uLjwvRGVzY3JpcHRpb24+CiAgPC9UcmFja2luZz4KPC9BZ2VudFByb3RvY29sPiA="
    )
    embedded[".erasmus/templates/protocols/product_owner.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDAyPC9JZD4KICAgIDxSb2xlPnByb2R1Y3Rfb3duZXI8L1JvbGU+CiAgICA8VHJpZ2dlcnM+cHJvamVjdF9pbml0aWF0aW9uPC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz4uY3R4LmFyY2hpdGVjdHVyZS54bWwsIC5jdHgucHJvZ3Jlc3MueG1sPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz51c2VyX3JlcXVlc3QubWQ8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIERlZmluZSBhbmQgbWFuYWdlIHByb2R1Y3QgcmVxdWlyZW1lbnRzIGFuZCByb2FkbWFwLiBNb25pdG9yIGFuZCB1cGRhdGUgcHJvZHVjdCB0YXNrcyBpbiA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gYW5kIDxGaWxlPi5jdHgudGFza3MueG1sPC9GaWxlPi4KICA8L09iamVjdGl2ZT4KICA8V29ya2Zsb3c+CiAgICA8U3RlcD5Nb25pdG9yIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBmb3IgcHJvZHVjdCByZXF1aXJlbWVudHMgYW5kIHJvYWRtYXAgdXBkYXRlcy48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCByZXF1aXJlbWVudDoKICAgICAgPFN1YnN0ZXA+UmV2aWV3IHRoZSBwcm9kdWN0IHN0YXR1cyBhbmQgaWRlbnRpZnkgbmVjZXNzYXJ5IHVwZGF0ZXMuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5Eb2N1bWVudCBhbnkgcHJvZHVjdCB0YXNrcyBvciB1cGRhdGVzIG5lZWRlZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBwcm9kdWN0IHRhc2tzLjwvU3Vic3RlcD4KICAgIDwvU3RlcD4KICAgIDxTdGVwPkZvciByZWN1cnJpbmcgcHJvZHVjdCBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgaW1wcm92ZW1lbnQuPC9TdGVwPgogIDwvV29ya2Zsb3c+CiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlPkVuc3VyZSBjbGVhciBhbmQgYWN0aW9uYWJsZSBwcm9kdWN0IHJlcXVpcmVtZW50cy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHByb2R1Y3QgdGFza3MgYW5kIHVwZGF0ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHByb2R1Y3Qgc3RhdHVzIGFuZCByZWNvbW1lbmRhdGlvbnMuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPkNvbW11bmljYXRlIHByb2R1Y3QgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgcHJvZHVjdCB0YXNrcywgdXBkYXRlcywgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgdHJhY2tlZCBpbiB0aGVzZSBmaWxlcy4gUHJvZ3Jlc3MgaXMgdXBkYXRlZCBhcyBwcm9kdWN0IHRhc2tzIGFyZSBjb21wbGV0ZWQuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=="
    )
    embedded[".erasmus/templates/protocols/security.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA4PC9JZD4KICAgIDxSb2xlPnNlY3VyaXR5X3ZlcmlmaWNhdGlvbjwvUm9sZT4KICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPnNlY3VyaXR5X3JlcG9ydHMsIHZ1bG5lcmFiaWxpdHlfZml4ZXM8L1Byb2R1Y2VzPgogICAgPENvbnN1bWVzPmltcGxlbWVudGF0aW9uX2NvZGUsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgSWRlbnRpZnkgYW5kIG1pdGlnYXRlIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcyBpbiB0aGUgY29kZWJhc2UuIFRyYWNrIHNlY3VyaXR5IGlzc3VlcyBhbmQgZml4ZXMgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHNlY3VyaXR5IHZlcmlmaWNhdGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBjb2RlIGNoYW5nZToKICAgICAgPFN1YnN0ZXA+UnVuIHNlY3VyaXR5IHNjYW5zIHRvIGlkZW50aWZ5IHZ1bG5lcmFiaWxpdGllcy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBpc3N1ZXMgZm91bmQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+IHdpdGggY2xlYXIgZGVzY3JpcHRpb25zIGFuZCBzdWdnZXN0ZWQgZml4ZXMuPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBzZWN1cml0eSB2ZXJpZmljYXRpb24uPC9TdWJzdGVwPgogICAgPC9TdGVwPgogICAgPFN0ZXA+Rm9yIHJlY3VycmluZyBzZWN1cml0eSBpc3N1ZXMsIHVwZGF0ZSA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gd2l0aCBwYXR0ZXJucyBhbmQgcmVjb21tZW5kYXRpb25zIGZvciBmdXR1cmUgcHJldmVudGlvbi48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgaXMgZnJlZSBmcm9tIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHNlY3VyaXR5IGlzc3VlcyBhbmQgZml4ZXMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHNlY3VyaXR5IHZlcmlmaWNhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgc2VjdXJpdHkgZ2FwcyBvciBmYWlsdXJlcyBpbiAuY3R4LnRhc2tzLnhtbCBmb3IgZGV2ZWxvcGVyIGZvbGxvdy11cC48L1ByaW5jaXBsZT4KICA8L1ByaW5jaXBsZXM+CiAgPFRyYWNraW5nPgogICAgPFVzZXM+LmN0eC5wcm9ncmVzcy54bWw8L1VzZXM+CiAgICA8VXNlcz4uY3R4LnRhc2tzLnhtbDwvVXNlcz4KICAgIDxEZXNjcmlwdGlvbj5BbGwgc2VjdXJpdHkgaXNzdWVzLCB2dWxuZXJhYmlsaXR5IGZpeGVzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHNlY3VyaXR5IHZlcmlmaWNhdGlvbiBwcm9jZWVkcy48L0Rlc2NyaXB0aW9uPgogIDwvVHJhY2tpbmc+CjwvQWdlbnRQcm90b2NvbD4g"
    )
    embedded[".erasmus/templates/protocols/performance.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDExPC9JZD4KICAgIDxSb2xlPnBlcmZvcm1hbmNlX29wdGltaXphdGlvbjwvUm9sZT4KICAgIDxUcmlnZ2Vycz5kZXBsb3ltZW50X3JlYWR5PC9UcmlnZ2Vycz4KICAgIDxQcm9kdWNlcz5wZXJmb3JtYW5jZV9yZXBvcnRzLCBvcHRpbWl6YXRpb25fcmVjb21tZW5kYXRpb25zPC9Qcm9kdWNlcz4KICAgIDxDb25zdW1lcz5idWlsZF9hcnRpZmFjdHMsIC5jdHgucHJvZ3Jlc3MueG1sLCAuY3R4LnRhc2tzLnhtbDwvQ29uc3VtZXM+CiAgPC9NZXRhZGF0YT4KICA8T2JqZWN0aXZlPgogICAgT3B0aW1pemUgY29kZSBwZXJmb3JtYW5jZSBhbmQgdHJhY2sgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzLiBNb25pdG9yIGFuZCB1cGRhdGUgcGVyZm9ybWFuY2UgdGFza3MgaW4gPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGFuZCA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uCiAgPC9PYmplY3RpdmU+CiAgPFdvcmtmbG93PgogICAgPFN0ZXA+TW9uaXRvciA8RmlsZT4uY3R4LnByb2dyZXNzLnhtbDwvRmlsZT4gZm9yIG5ldyBjb2RlIGNoYW5nZXMgcmVxdWlyaW5nIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi48L1N0ZXA+CiAgICA8U3RlcD5Gb3IgZWFjaCBjb2RlIGNoYW5nZToKICAgICAgPFN1YnN0ZXA+UmV2aWV3IHRoZSBjb2RlIGFuZCBpZGVudGlmeSBhcmVhcyBuZWVkaW5nIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cy48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBwZXJmb3JtYW5jZSBpc3N1ZXMgb3IgaW1wcm92ZW1lbnRzIG5lZWRlZCBpbiA8RmlsZT4uY3R4LnRhc2tzLnhtbDwvRmlsZT4uPC9TdWJzdGVwPgogICAgICA8U3Vic3RlcD5VcGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiBwZXJmb3JtYW5jZSB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIHBlcmZvcm1hbmNlIGlzc3VlcywgdXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB3aXRoIHBhdHRlcm5zIGFuZCByZWNvbW1lbmRhdGlvbnMgZm9yIGZ1dHVyZSBpbXByb3ZlbWVudC48L1N0ZXA+CiAgPC9Xb3JrZmxvdz4KICA8UHJpbmNpcGxlcz4KICAgIDxQcmluY2lwbGU+RW5zdXJlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZSB3aXRoIHByb3BlciBwcm9maWxpbmcgYW5kIGJlbmNobWFya2luZy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIHBlcmZvcm1hbmNlIHRhc2tzIGFuZCBpbXByb3ZlbWVudHMgaW4gLmN0eC50YXNrcy54bWwuPC9QcmluY2lwbGU+CiAgICA8UHJpbmNpcGxlPlVwZGF0ZSAuY3R4LnByb2dyZXNzLnhtbCB3aXRoIHBlcmZvcm1hbmNlIHN0YXR1cyBhbmQgcmVjb21tZW5kYXRpb25zLjwvUHJpbmNpcGxlPgogICAgPFByaW5jaXBsZT5Db21tdW5pY2F0ZSBwZXJmb3JtYW5jZSBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MueG1sIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBwZXJmb3JtYW5jZSB0YXNrcywgaW1wcm92ZW1lbnRzLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSB0cmFja2VkIGluIHRoZXNlIGZpbGVzLiBQcm9ncmVzcyBpcyB1cGRhdGVkIGFzIHBlcmZvcm1hbmNlIHRhc2tzIGFyZSBjb21wbGV0ZWQuPC9EZXNjcmlwdGlvbj4KICA8L1RyYWNraW5nPgo8L0FnZW50UHJvdG9jb2w+IA=="
    )
    embedded[".erasmus/templates/protocols/documentation.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFnZW50UHJvdG9jb2w+CiAgPE1ldGFkYXRhPgogICAgPElkPjAwMDAwMDA5PC9JZD4KICAgIDxSb2xlPmRvY3VtZW50YXRpb25fbWFuYWdlbWVudDwvUm9sZT4KICAgIDxUcmlnZ2Vycz5jb2RlX3Jldmlld19wYXNzZWQ8L1RyaWdnZXJzPgogICAgPFByb2R1Y2VzPnJlYWRtZSwgYXBpX2RvY3MsIGlubGluZV9jb21tZW50czwvUHJvZHVjZXM+CiAgICA8Q29uc3VtZXM+Y29kZSwgYXJjaGl0ZWN0dXJlLCB0ZXN0IGZpbGVzLCAuY3R4LnByb2dyZXNzLnhtbCwgLmN0eC50YXNrcy54bWw8L0NvbnN1bWVzPgogIDwvTWV0YWRhdGE+CiAgPE9iamVjdGl2ZT4KICAgIENyZWF0ZSBhbmQgbWFpbnRhaW4gY29tcHJlaGVuc2l2ZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgY29kZWJhc2UuIFRyYWNrIGRvY3VtZW50YXRpb24gdGFza3MgYW5kIHByb2dyZXNzIGluIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiBhbmQgPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LgogIDwvT2JqZWN0aXZlPgogIDxXb3JrZmxvdz4KICAgIDxTdGVwPk1vbml0b3IgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IGZvciBuZXcgY29kZSBjaGFuZ2VzIHJlcXVpcmluZyBkb2N1bWVudGF0aW9uLjwvU3RlcD4KICAgIDxTdGVwPkZvciBlYWNoIGNvZGUgY2hhbmdlOgogICAgICA8U3Vic3RlcD5SZXZpZXcgdGhlIGNvZGUgYW5kIGlkZW50aWZ5IGFyZWFzIG5lZWRpbmcgZG9jdW1lbnRhdGlvbi48L1N1YnN0ZXA+CiAgICAgIDxTdWJzdGVwPkRvY3VtZW50IGFueSBnYXBzIG9yIGltcHJvdmVtZW50cyBuZWVkZWQgaW4gPEZpbGU+LmN0eC50YXNrcy54bWw8L0ZpbGU+LjwvU3Vic3RlcD4KICAgICAgPFN1YnN0ZXA+VXBkYXRlIDxGaWxlPi5jdHgucHJvZ3Jlc3MueG1sPC9GaWxlPiB0byByZWZsZWN0IHRoZSBzdGF0dXMgb2YgZG9jdW1lbnRhdGlvbiB0YXNrcy48L1N1YnN0ZXA+CiAgICA8L1N0ZXA+CiAgICA8U3RlcD5Gb3IgcmVjdXJyaW5nIGRvY3VtZW50YXRpb24gaXNzdWVzLCB1cGRhdGUgPEZpbGU+LmN0eC5wcm9ncmVzcy54bWw8L0ZpbGU+IHdpdGggcGF0dGVybnMgYW5kIHJlY29tbWVuZGF0aW9ucyBmb3IgZnV0dXJlIGltcHJvdmVtZW50LjwvU3RlcD4KICA8L1dvcmtmbG93PgogIDxQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZT5FbnN1cmUgY29kZSBpcyB3ZWxsLWRvY3VtZW50ZWQgd2l0aCBjbGVhciBhbmQgY29uY2lzZSBjb21tZW50cy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VHJhY2sgYWxsIGRvY3VtZW50YXRpb24gdGFza3MgYW5kIGltcHJvdmVtZW50cyBpbiAuY3R4LnRhc2tzLnhtbC48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+VXBkYXRlIC5jdHgucHJvZ3Jlc3MueG1sIHdpdGggZG9jdW1lbnRhdGlvbiBzdGF0dXMgYW5kIHJlY29tbWVuZGF0aW9ucy48L1ByaW5jaXBsZT4KICAgIDxQcmluY2lwbGU+Q29tbXVuaWNhdGUgZG9jdW1lbnRhdGlvbiBnYXBzIG9yIGZhaWx1cmVzIGluIC5jdHgudGFza3MueG1sIGZvciBkZXZlbG9wZXIgZm9sbG93LXVwLjwvUHJpbmNpcGxlPgogIDwvUHJpbmNpcGxlcz4KICA8VHJhY2tpbmc+CiAgICA8VXNlcz4uY3R4LnByb2dyZXNzLnhtbDwvVXNlcz4KICAgIDxVc2VzPi5jdHgudGFza3MueG1sPC9Vc2VzPgogICAgPERlc2NyaXB0aW9uPkFsbCBkb2N1bWVudGF0aW9uIHRhc2tzLCBpbXByb3ZlbWVudHMsIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIHRyYWNrZWQgaW4gdGhlc2UgZmlsZXMuIFByb2dyZXNzIGlzIHVwZGF0ZWQgYXMgZG9jdW1lbnRhdGlvbiB0YXNrcyBhcmUgY29tcGxldGVkLjwvRGVzY3JpcHRpb24+CiAgPC9UcmFja2luZz4KPC9BZ2VudFByb3RvY29sPiA="
    )
    embedded[".erasmus/templates/protocol.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFByb3RvY29sIG5hbWU9IlByb3RvY29sIE5hbWUiPgogIDxEZXNjcmlwdGlvbj5Qcm90b2NvbCBkZXNjcmlwdGlvbjwvRGVzY3JpcHRpb24+CiAgCiAgPFRyaWdnZXJzPgogICAgPFRyaWdnZXI+VHJpZ2dlciAxPC9UcmlnZ2VyPgogICAgPFRyaWdnZXI+VHJpZ2dlciAyPC9UcmlnZ2VyPgogICAgPCEtLSBBZGQgbW9yZSB0cmlnZ2VycyBhcyBuZWVkZWQgLS0+CiAgPC9UcmlnZ2Vycz4KICAKICA8UHJvZHVjZXM+CiAgICA8T3V0cHV0Pk91dHB1dCAxPC9PdXRwdXQ+CiAgICA8T3V0cHV0Pk91dHB1dCAyPC9PdXRwdXQ+CiAgICA8IS0tIEFkZCBtb3JlIG91dHB1dHMgYXMgbmVlZGVkIC0tPgogIDwvUHJvZHVjZXM+CiAgCiAgPENvbnN1bWVzPgogICAgPElucHV0PklucHV0IDE8L0lucHV0PgogICAgPElucHV0PklucHV0IDI8L0lucHV0PgogICAgPCEtLSBBZGQgbW9yZSBpbnB1dHMgYXMgbmVlZGVkIC0tPgogIDwvQ29uc3VtZXM+CiAgCiAgPFdvcmtmbG93PgogICAgPFN0ZXAgbmFtZT0iU3RlcCBOYW1lIj4KICAgICAgPERlc2NyaXB0aW9uPlN0ZXAgZGVzY3JpcHRpb248L0Rlc2NyaXB0aW9uPgogICAgICA8QWN0aW9ucz4KICAgICAgICA8QWN0aW9uPkFjdGlvbiAxPC9BY3Rpb24+CiAgICAgICAgPEFjdGlvbj5BY3Rpb24gMjwvQWN0aW9uPgogICAgICAgIDwhLS0gQWRkIG1vcmUgYWN0aW9ucyBhcyBuZWVkZWQgLS0+CiAgICAgIDwvQWN0aW9ucz4KICAgIDwvU3RlcD4KICAgIDwhLS0gQWRkIG1vcmUgc3RlcHMgYXMgbmVlZGVkIC0tPgogIDwvV29ya2Zsb3c+CiAgCiAgPFByaW5jaXBsZXM+CiAgICA8UHJpbmNpcGxlIG5hbWU9IlByaW5jaXBsZSBOYW1lIj4KICAgICAgPERlc2NyaXB0aW9uPlByaW5jaXBsZSBkZXNjcmlwdGlvbjwvRGVzY3JpcHRpb24+CiAgICA8L1ByaW5jaXBsZT4KICAgIDwhLS0gQWRkIG1vcmUgcHJpbmNpcGxlcyBhcyBuZWVkZWQgLS0+CiAgPC9QcmluY2lwbGVzPgogIAogIDxUcmFja2luZz4KICAgIDxNZXRyaWMgbmFtZT0iTWV0cmljIE5hbWUiPgogICAgICA8RGVzY3JpcHRpb24+TWV0cmljIGRlc2NyaXB0aW9uPC9EZXNjcmlwdGlvbj4KICAgIDwvTWV0cmljPgogICAgPCEtLSBBZGQgbW9yZSBtZXRyaWNzIGFzIG5lZWRlZCAtLT4KICA8L1RyYWNraW5nPgo8L1Byb3RvY29sPiA="
    )
    embedded[".erasmus/templates/architecture.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPEFyY2hpdGVjdHVyZT4KICA8T3ZlcnZpZXc+CiAgICA8RGVzY3JpcHRpb24+UHJvamVjdCBkZXNjcmlwdGlvbiBnb2VzIGhlcmU8L0Rlc2NyaXB0aW9uPgogIDwvT3ZlcnZpZXc+CiAgCiAgPENvcmVDb21wb25lbnRzPgogICAgPENvbXBvbmVudCBuYW1lPSJDb21wb25lbnQgTmFtZSI+CiAgICAgIDxQdXJwb3NlPkNvbXBvbmVudCBwdXJwb3NlPC9QdXJwb3NlPgogICAgICA8UmVzcG9uc2liaWxpdGllcz4KICAgICAgICA8UmVzcG9uc2liaWxpdHk+UmVzcG9uc2liaWxpdHkgMTwvUmVzcG9uc2liaWxpdHk+CiAgICAgICAgPFJlc3BvbnNpYmlsaXR5PlJlc3BvbnNpYmlsaXR5IDI8L1Jlc3BvbnNpYmlsaXR5PgogICAgICAgIDwhLS0gQWRkIG1vcmUgcmVzcG9uc2liaWxpdGllcyBhcyBuZWVkZWQgLS0+CiAgICAgIDwvUmVzcG9uc2liaWxpdGllcz4KICAgICAgPFRlc3RGb2N1cz4KICAgICAgICA8VGVzdD5UZXN0IGZvY3VzIDE8L1Rlc3Q+CiAgICAgICAgPFRlc3Q+VGVzdCBmb2N1cyAyPC9UZXN0PgogICAgICAgIDwhLS0gQWRkIG1vcmUgdGVzdCBmb2N1c2VzIGFzIG5lZWRlZCAtLT4KICAgICAgPC9UZXN0Rm9jdXM+CiAgICA8L0NvbXBvbmVudD4KICAgIDwhLS0gQWRkIG1vcmUgY29tcG9uZW50cyBhcyBuZWVkZWQgLS0+CiAgPC9Db3JlQ29tcG9uZW50cz4KICAKICA8RGV2ZWxvcG1lbnRQcmluY2lwbGVzPgogICAgPFByaW5jaXBsZSBuYW1lPSJQcmluY2lwbGUgTmFtZSI+CiAgICAgIDxEZXRhaWw+UHJpbmNpcGxlIGRldGFpbCAxPC9EZXRhaWw+CiAgICAgIDxEZXRhaWw+UHJpbmNpcGxlIGRldGFpbCAyPC9EZXRhaWw+CiAgICAgIDwhLS0gQWRkIG1vcmUgZGV0YWlscyBhcyBuZWVkZWQgLS0+CiAgICA8L1ByaW5jaXBsZT4KICAgIDwhLS0gQWRkIG1vcmUgcHJpbmNpcGxlcyBhcyBuZWVkZWQgLS0+CiAgPC9EZXZlbG9wbWVudFByaW5jaXBsZXM+CiAgCiAgPERlcGVuZGVuY2llcz4KICAgIDxEZXBlbmRlbmN5PkRlcGVuZGVuY3kgMTwvRGVwZW5kZW5jeT4KICAgIDxEZXBlbmRlbmN5PkRlcGVuZGVuY3kgMjwvRGVwZW5kZW5jeT4KICAgIDwhLS0gQWRkIG1vcmUgZGVwZW5kZW5jaWVzIGFzIG5lZWRlZCAtLT4KICA8L0RlcGVuZGVuY2llcz4KICAKICA8RGlyZWN0b3J5U3RydWN0dXJlPgogICAgPCEtLSBBZGQgZGlyZWN0b3J5IHN0cnVjdHVyZSBoZXJlIC0tPgogIDwvRGlyZWN0b3J5U3RydWN0dXJlPgogIAogIDxEZXZlbG9wbWVudFdvcmtmbG93PgogICAgPFN0ZXA+V29ya2Zsb3cgc3RlcCAxPC9TdGVwPgogICAgPFN0ZXA+V29ya2Zsb3cgc3RlcCAyPC9TdGVwPgogICAgPCEtLSBBZGQgbW9yZSBzdGVwcyBhcyBuZWVkZWQgLS0+CiAgPC9EZXZlbG9wbWVudFdvcmtmbG93Pgo8L0FyY2hpdGVjdHVyZT4K"
    )
    embedded[".erasmus/templates/README.md"] = (
        "IyBFcmFzbXVzIFhNTCBUZW1wbGF0ZXMKClRoaXMgZGlyZWN0b3J5IGNvbnRhaW5zIFhNTCB0ZW1wbGF0ZXMgZm9yIHRoZSBFcmFzbXVzIGNvbnRleHQgbWFuYWdlbWVudCBzeXN0ZW0uIFRoZXNlIHRlbXBsYXRlcyBwcm92aWRlIGEgc3RydWN0dXJlZCBmb3JtYXQgZm9yIG9yZ2FuaXppbmcgcHJvamVjdCBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGJ5IEFJIG1vZGVscyBmb3IgYmV0dGVyIGNvbnRleHQgdW5kZXJzdGFuZGluZy4KCiMjIFRlbXBsYXRlIFN0cnVjdHVyZQoKLSBgbWV0YV9hZ2VudC54bWxgOiBHbG9iYWwgcnVsZXMgdGhhdCBpbnN0cnVjdCB0aGUgbW9kZWwgb24gaG93IHRvIGZvbGxvdyB0aGUgd29ya2Zsb3cgdGhhdCBhbGxvd3MgaXQgdG8gdXNlIHRoaXMgY29udGV4dCBtYW5hZ2VyLCB0aGlzIGdldHMgc2F2ZWQgdG8gdGhlIGdsb2JhbCBydWxlcyBmaWxlIG9mIHlvdXIgSURFLgotIGBtZXRhX3J1bGVzLnhtbGA6IFRoZSBtYWluIHRlbXBsYXRlIHRoYXQgaW5jbHVkZXMgcGxhY2Vob2xkZXJzIGZvciBhbGwgb3RoZXIgdGVtcGxhdGVzIGFuZCBnZXRzIHNhdmVkIHRvIHRoZSBsb2NhbCBydWxlcyBmaWxlIG9mIHlvdXIgcHJvamVjdCBhbmQgdXBkYXRlZCBmcm9tIHRoZSBgLmN0eC5gIGZpbGVzLgotIGBhcmNoaXRlY3R1cmUueG1sYDogVGVtcGxhdGUgZm9yIHByb2plY3QgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb24sIHRoaXMgZ2V0cyBjb3BpZWQgdG8gYC5jdHguYXJjaGl0ZWN0dXJlLnhtbGAgYW5kIGlzIG1vbml0b3JlZCBieSBgZXJhc211cyB3YXRjaGAKLSBgcHJvZ3Jlc3MueG1sYDogVGVtcGxhdGUgZm9yIHRyYWNraW5nIHByb2plY3QgcHJvZ3Jlc3MsIHRoaXMgZ2V0cyBjb3BpZWQgdG8gYC5jdHgucHJvZ3Jlc3MueG1sYCBhbmQgaXMgbW9uaXRvcmVkIGJ5IGBlcmFzbXVzIHdhdGNoYAotIGB0YXNrcy54bWxgOiBUZW1wbGF0ZSBmb3IgbWFuYWdpbmcgY3VycmVudCB0YXNrcyBhbmQgbmV4dCBzdGVwcywgdGhpcyBnZXRzIGNvcGllZCB0byBgLmN0eC5wcm9ncmVzcy54bWxgIGFuZCBpcyBtb25pdG9yZWQgYnkgYGVyYXNtdXMgd2F0Y2hgCi0gYHByb3RvY29sLnhtbGA6IFRlbXBsYXRlIGZvciBkZWZpbmluZyBwcm90b2NvbHMsIGdlbmVyaWMgcHJvdG9jb2wgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyB0ZW1wbGF0ZS4KLSBgcHJvdG9jb2xzL1BST1RPQ09MLnhtbGA6IFByZWRlZmluZWQgcHJvdG9jb2xzIGZvciBkaWZmZXJlbnQgYXNwZWN0cyBvZiBjb2RlIGdlbmVyYXRpb24gYW5kIGxpYnJhcnkgbWFpbnRlbmNlLiBVc2UgdGhlc2UgdG8gaGVscCBhdWdtZW50IHRoZSBtb2RlbCBhbmQgaW1wcm92ZSB0aGVpciB0YXJnZXRlZCB0YXNrLgoKIyMgVGVtcGxhdGUgRm9ybWF0CgpFYWNoIHRlbXBsYXRlIGZvbGxvd3MgYSBjb25zaXN0ZW50IFhNTCBzdHJ1Y3R1cmUgd2l0aDoKCi0gQ2xlYXIgaGllcmFyY2hpY2FsIG9yZ2FuaXphdGlvbgotIERlc2NyaXB0aXZlIGVsZW1lbnQgbmFtZXMKLSBDb21tZW50cyBmb3IgZ3VpZGFuY2UKLSBQbGFjZWhvbGRlcnMgZm9yIGNvbnRlbnQKCiMjIEV4YW1wbGUgVXNhZ2UKCmBgYHhtbAo8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCI/Pgo8TWV0YVJ1bGVzPgogIDwhLS1BUkNISVRFQ1RVUkUtLT4KICA8QXJjaGl0ZWN0dXJlPgogICAgPCEtLSBDb250ZW50IGZyb20gYXJjaGl0ZWN0dXJlLnhtbCAtLT4KICA8L0FyY2hpdGVjdHVyZT4KICA8IS0tL0FSQ0hJVEVDVFVSRS0tPgoKICA8IS0tUFJPR1JFU1MtLT4KICA8UHJvZ3Jlc3M+CiAgICA8IS0tIENvbnRlbnQgZnJvbSBwcm9ncmVzcy54bWwgLS0+CiAgPC9Qcm9ncmVzcz4KICA8IS0tL1BST0dSRVNTLS0+CgogIDwhLS1UQVNLUy0tPgogIDxUYXNrcz4KICAgIDwhLS0gQ29udGVudCBmcm9tIHRhc2tzLnhtbCAtLT4KICA8L1Rhc2tzPgogIDwhLS0vVEFTS1MtLT4KCiAgPCEtLVBST1RPQ09MLS0+CiAgPFByb3RvY29sPgogICAgPCEtLSBDb250ZW50IGZyb20gcHJvdG9jb2wueG1sIC0tPgogIDwvUHJvdG9jb2w+CiAgPCEtLS9QUk9UT0NPTC0tPgo8L01ldGFSdWxlcz4KYGBgCg=="
    )
    embedded[".erasmus/templates/tasks.xml"] = (
        "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPFRhc2tzPgogIDxDdXJyZW50VGFza3M+CiAgICA8VGFzayBuYW1lPSJUYXNrIE5hbWUiPgogICAgICA8RGVzY3JpcHRpb24+VGFzayBkZXNjcmlwdGlvbjwvRGVzY3JpcHRpb24+CiAgICAgIDxTdWJ0YXNrcz4KICAgICAgICA8U3VidGFzayBuYW1lPSJTdWJ0YXNrIE5hbWUiPgogICAgICAgICAgPFN0YXR1cz5TdGF0dXMgKGUuZy4sIFBlbmRpbmcsIEluIFByb2dyZXNzLCBDb21wbGV0ZWQpPC9TdGF0dXM+CiAgICAgICAgICA8U3VidGFza3M+CiAgICAgICAgICAgIDxTdWJ0YXNrIG5hbWU9Ik5lc3RlZCBTdWJ0YXNrIE5hbWUiPgogICAgICAgICAgICAgIDxTdGF0dXM+U3RhdHVzPC9TdGF0dXM+CiAgICAgICAgICAgIDwvU3VidGFzaz4KICAgICAgICAgICAgPCEtLSBBZGQgbW9yZSBuZXN0ZWQgc3VidGFza3MgYXMgbmVlZGVkIC0tPgogICAgICAgICAgPC9TdWJ0YXNrcz4KICAgICAgICA8L1N1YnRhc2s+CiAgICAgICAgPCEtLSBBZGQgbW9yZSBzdWJ0YXNrcyBhcyBuZWVkZWQgLS0+CiAgICAgIDwvU3VidGFza3M+CiAgICAgIDxUZXN0cz4KICAgICAgICA8VGVzdCBuYW1lPSJUZXN0IE5hbWUiPgogICAgICAgICAgPENvZGU+CiAgICAgICAgICAgIDwhW0NEQVRBWwogICAgICAgICAgICBkZWYgdGVzdF9mdW5jdGlvbigpOgogICAgICAgICAgICAgICAgIyBUZXN0IGNvZGUgZ29lcyBoZXJlCiAgICAgICAgICAgIF1dPgogICAgICAgICAgPC9Db2RlPgogICAgICAgIDwvVGVzdD4KICAgICAgICA8IS0tIEFkZCBtb3JlIHRlc3RzIGFzIG5lZWRlZCAtLT4KICAgICAgPC9UZXN0cz4KICAgIDwvVGFzaz4KICAgIDwhLS0gQWRkIG1vcmUgY3VycmVudCB0YXNrcyBhcyBuZWVkZWQgLS0+CiAgPC9DdXJyZW50VGFza3M+CiAgCiAgPE5leHRTdGVwcz4KICAgIDxTdGVwPk5leHQgc3RlcCAxPC9TdGVwPgogICAgPFN0ZXA+TmV4dCBzdGVwIDI8L1N0ZXA+CiAgICA8IS0tIEFkZCBtb3JlIG5leHQgc3RlcHMgYXMgbmVlZGVkIC0tPgogIDwvTmV4dFN0ZXBzPgo8L1Rhc2tzPiA="
    )
    embedded[".erasmus/current_protocol.txt"] = "ZGV2ZWxvcGVy"
    embedded[".erasmus/protocol/.gitkeep"] = ""
    embedded[".erasmus/context/.gitkeep"] = ""
    if not os.path.exists(".erasmus"):
        for rel_path, b64 in embedded.items():
            out_path = os.path.join(os.getcwd(), rel_path)
            os.makedirs(os.path.dirname(out_path), exist_ok=True)
            with open(out_path, "wb") as f:
                f.write(base64.b64decode(b64))
    # else: do not overwrite


_extract_erasmus_embedded_files()

# logging.py
from loguru import logger


# paths.py
from pathlib import Path
from pydantic import BaseModel, Field, ConfigDict
from dotenv import load_dotenv
from enum import Enum
import os
from typing import NamedTuple

load_dotenv()


class IDEMetadata(NamedTuple):
    """Metadata for an IDE environment."""

    name: str
    rules_file: str
    global_rules_path: Path


class IDE(Enum):
    """IDE environment with associated metadata."""

    windsurf = IDEMetadata(
        name="windsurf",
        rules_file=".windsurfrules",
        global_rules_path=Path.home() / ".codeium" / "windsurf" / "memories" / "global_rules.md",
    )

    cursor = IDEMetadata(
        name="cursor",
        rules_file=".cursorrules",
        global_rules_path=Path.cwd() / ".cursor" / "global_rules.md",
    )

    codex = IDEMetadata(
        name="codex",
        # Local rules file for Codex IDE (prefixed with a dot)
        rules_file=".codex.md",
        global_rules_path=Path.home() / ".codex" / "instructions.md",
    )

    claude = IDEMetadata(
        name="claude",
        rules_file="CLAUDE.md",
        global_rules_path=Path.home() / ".claude" / "CLAUDE.md",
    )

    @property
    def metadata(self) -> IDEMetadata:
        """Get the metadata for this IDE."""
        return self.value

    @property
    def rules_file(self) -> str:
        """Get the rules file name for this IDE."""
        return self.metadata.rules_file

    @property
    def global_rules_path(self) -> Path:
        """Get the global rules path for this IDE."""
        return self.metadata.global_rules_path


def detect_ide_from_env() -> IDE | None:
    """
    Detect IDE from environment variables.
    Returns None if no IDE is detected.
    """
    ide_env = os.environ.get("IDE_ENV", "").lower()

    if not ide_env:
        return None

    # Check for IDE based on prefix
    if ide_env.startswith("w"):
        return IDE.windsurf
    elif ide_env.startswith("cu"):
        return IDE.cursor
    elif ide_env.startswith("co"):
        return IDE.codex
    elif ide_env.startswith("cl"):
        return IDE.claude

    return None


def prompt_for_ide() -> IDE:
    """
    Prompt the user to select an IDE.
    Returns the selected IDE.
    """
    print("No IDE environment detected. Please select an IDE:")
    print("1. Windsurf")
    print("2. Cursor")
    print("3. Codex")
    print("4. Claude")

    while True:
        try:
            choice = input("Enter your choice (1-4): ")
            if choice == "1":
                return IDE.windsurf
            elif choice == "2":
                return IDE.cursor
            elif choice == "3":
                return IDE.codex
            elif choice == "4":
                return IDE.claude
            else:
                print("Invalid choice. Please enter a number between 1 and 4.")
        except KeyboardInterrupt:
            print("\nOperation cancelled. Using default IDE (Cursor).")
            return IDE.cursor


def get_ide() -> IDE:
    """
    Get the IDE from environment variables or prompt the user.
    Returns the selected IDE.
    """
    ide = detect_ide_from_env()
    if ide is None:
        ide = prompt_for_ide()
        environment = Path.cwd() / ".env"
        if environment.exists():
            environment_content = environment.read_text()
            environment_content += f"\nIDE_ENV={ide.name}"
            environment.write_text(environment_content)
        else:
            environment.write_text(f"IDE_ENV={ide.name}")
    return ide


class PathMngrModel(BaseModel):
    """Manages paths for different IDE environments."""

    # Allow extra attributes for mocking and patching
    model_config = ConfigDict(extra="allow")

    ide: IDE | None = None
    # Directories
    root_dir: Path = Path.cwd()
    erasmus_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus")
    context_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "context")
    protocol_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "protocol")
    template_dir: Path = Field(default_factory=lambda: Path.cwd() / ".erasmus" / "templates")

    # Files
    architecture_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.architecture.xml")
    progress_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.progress.xml")
    tasks_file: Path = Field(default_factory=lambda: Path.cwd() / ".ctx.tasks.xml")
    rules_file: Path | None = None
    global_rules_file: Path | None = None

    def __init__(self, **data):
        super().__init__(**data)
        # Initialize and time path setup
        self._setup_paths()

    def _setup_paths(self):
        """Set up paths based on the selected IDE."""
        if self.ide:
            # Set rules file based on IDE
            self.rules_file = self.root_dir / self.ide.rules_file
            self.global_rules_file = self.ide.global_rules_path

            # Create symlink for cursor if needed (special case for windsurf)
            if self.ide == IDE.windsurf:
                cursor_rules = self.root_dir / ".cursorrules"
                if self.rules_file.exists() and not cursor_rules.exists():
                    cursor_rules.symlink_to(self.rules_file)

    def get_ide_env(self) -> str | None:
        """Get the IDE environment name."""
        return self.ide.name if self.ide else None

    def get_context_dir(self) -> Path:
        """Get the context directory path."""
        return self.context_dir

    def get_protocol_dir(self) -> Path:
        """Get the protocol directory path."""
        return self.protocol_dir

    def get_architecture_file(self) -> Path:
        """Get the architecture file path."""
        return self.architecture_file

    def get_progress_file(self) -> Path:
        """Get the progress file path."""
        return self.progress_file

    def get_tasks_file(self) -> Path:
        """Get the tasks file path."""
        return self.tasks_file

    def get_rules_file(self) -> Path | None:
        """Get the rules file path."""
        return self.rules_file

    def get_global_rules_file(self) -> Path | None:
        """Get the global rules file path."""
        return self.global_rules_file

    def get_root_dir(self) -> Path:
        """Get the root directory path."""
        return self.root_dir

    def get_path(self, name: str) -> Path:
        """Get a path by name."""
        if hasattr(self, name):
            return getattr(self, name)
        raise ValueError(f"Path {name} not found")

    def set_path(self, name: str, path: Path) -> None:
        """Set a path by name."""
        if hasattr(self, name):
            setattr(self, name, path)
        else:
            raise ValueError(f"Path {name} not found")

    def ensure_dirs(self) -> None:
        """Ensure all directories exist."""
        self.context_dir.mkdir(parents=True, exist_ok=True)
        self.protocol_dir.mkdir(parents=True, exist_ok=True)
        self.erasmus_dir.mkdir(parents=True, exist_ok=True)
        self.template_dir.mkdir(parents=True, exist_ok=True)

    def ensure_files(self) -> None:
        """Ensure all files exist."""
        self.ensure_dirs()
        self.architecture_file.touch(exist_ok=True)
        self.progress_file.touch(exist_ok=True)
        self.tasks_file.touch(exist_ok=True)
        if self.rules_file:
            self.rules_file.touch(exist_ok=True)
        if self.global_rules_file:
            self.global_rules_file.touch(exist_ok=True)

    def setup_paths(self) -> None:
        """Set up all paths and ensure directories and files exist."""
        self._setup_paths()
        self.ensure_dirs()
        self.ensure_files()


# Singleton instance
_path_manager = None


def get_path_manager(ide: IDE | None = None) -> PathMngrModel:
    """Get the singleton path manager instance."""
    global _path_manager
    if _path_manager is None:
        # If no IDE is provided, try to detect it
        if ide is None:
            ide = get_ide()
        _path_manager = PathMngrModel(ide=ide)
    elif ide is not None and _path_manager.ide != ide:
        # Update the IDE if it's different
        _path_manager.ide = ide
        _path_manager._setup_paths()
    return _path_manager


# Legacy alias for backwards compatibility
PathManager = PathMngrModel

IDEMetadata = IDEMetadata
IDE = IDE
detect_ide_from_env = detect_ide_from_env
prompt_for_ide = prompt_for_ide
get_ide = get_ide
PathMngrModel = PathMngrModel
get_path_manager = get_path_manager

# sanatizer.py
import re
import xml.etree.ElementTree as ET
from typing import Any


def _sanitize_string(name: str) -> str:
    """Sanitize a string by removing emoji and non-ASCII characters while preserving valid markdown characters.
    Returns an ASCII-safe string suitable for filenames.
    """
    # First remove emoji using regex pattern
    no_emoji = re.sub(r"[\U0001F300-\U0001F9FF]", "", name)
    # Allow markdown special chars but remove other non-ASCII
    allowed_special = r"[#*_\-`~\[\](){}|<>.!]"
    sanitized = ""
    for character in no_emoji:
        # Skip non-ASCII characters entirely
        if not character.isascii():
            continue
        # Allow alphanumeric and certain special characters
        if character.isalnum() or re.match(allowed_special, character):
            sanitized += character
        else:
            sanitized += "_"
    # Collapse multiple underscores
    sanitized = re.sub(r"_+", "_", sanitized)
    # Ensure it starts with a letter
    if not sanitized[0].isalpha():
        sanitized = "p_" + sanitized
    # Strip trailing underscores
    sanitized = sanitized.rstrip("_")
    return sanitized


def _sanitize_xml_content(xml_content: str) -> str:
    """Sanitize XML content by ensuring it's well-formed and safe.

    Args:
        xml_content: The XML content to sanitize

    Returns:
        Sanitized XML content
    """
    # Replace invalid XML characters
    # XML 1.0 specification allows: #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
    # We'll replace control characters and other invalid characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", xml_content)

    # Replace invalid XML entities
    sanitized = re.sub(r"&(?!(amp|lt|gt|quot|apos|#\d+|#x[0-9a-fA-F]+);)", "&amp;", sanitized)

    # Ensure the XML is well-formed
    try:
        # Try to parse the XML to ensure it's well-formed
        ET.fromstring(sanitized)
        return sanitized
    except ET.ParseError:
        # If parsing fails, try to fix common issues
        # Add XML declaration if missing
        if not sanitized.strip().startswith("<?xml"):
            sanitized = '<?xml version="1.0" encoding="UTF-8"?>\n' + sanitized

        # Try to parse again
        try:
            ET.fromstring(sanitized)
            return sanitized
        except ET.ParseError:
            # If still failing, return a minimal valid XML
            return '<?xml version="1.0" encoding="UTF-8"?>\n<root></root>'


def _sanitize_xml_attribute(value: str) -> str:
    """Sanitize a string for use as an XML attribute value.

    Args:
        value: The attribute value to sanitize

    Returns:
        Sanitized attribute value
    """
    # Replace special XML characters with their entities
    sanitized = value.replace("&", "&amp;")
    sanitized = sanitized.replace("<", "&lt;")
    sanitized = sanitized.replace(">", "&gt;")
    sanitized = sanitized.replace('"', "&quot;")
    sanitized = sanitized.replace("'", "&apos;")

    # Remove invalid XML characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", sanitized)

    return sanitized


def _sanitize_xml_tag(tag: str) -> str:
    """Sanitize a string for use as an XML tag name.

    Args:
        tag: The tag name to sanitize

    Returns:
        Sanitized tag name
    """
    # XML tag names must start with a letter or underscore
    if not tag or not (tag[0].isalpha() or tag[0] == "_"):
        tag = "x_" + tag

    # Replace invalid characters with underscores
    sanitized = re.sub(r"[^a-zA-Z0-9_\-\.]", "_", tag)

    # Ensure it's a valid XML name
    if not re.match(r"^[a-zA-Z_][a-zA-Z0-9_\-\.]*$", sanitized):
        sanitized = "x_" + sanitized

    return sanitized


def sanitize_for_xml(value: Any) -> str:
    """Sanitize a value for use in XML.

    Args:
        value: The value to sanitize

    Returns:
        Sanitized value as a string
    """
    if value is None:
        return ""

    # Convert to string
    str_value = str(value)

    # Replace special XML characters with their entities
    sanitized = str_value.replace("&", "&amp;")
    sanitized = sanitized.replace("<", "&lt;")
    sanitized = sanitized.replace(">", "&gt;")
    sanitized = sanitized.replace('"', "&quot;")
    sanitized = sanitized.replace("'", "&apos;")

    # Remove invalid XML characters
    sanitized = re.sub(r"[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "", sanitized)

    return sanitized


sanitize_for_xml = sanitize_for_xml

# xml_parser.py
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Any, Dict, List, Optional, Union


def parse_xml_file(file_path: Union[str, Path]) -> ET.Element:
    """
    Parse an XML file and return the root element.

    Args:
        file_path: Path to the XML file

    Returns:
        The root element of the XML document

    Raises:
        FileNotFoundError: If the file doesn't exist
        ET.ParseError: If the XML is not well-formed
    """
    file_path = Path(file_path)
    if not file_path.exists():
        raise FileNotFoundError(f"XML file not found: {file_path}")

    try:
        tree = ET.parse(file_path)
        return tree.getroot()
    except ET.ParseError as parse_error:
        raise ET.ParseError(f"Error parsing XML file {file_path}: {parse_error}")


def parse_xml_string(xml_string: str) -> ET.Element:
    """
    Parse an XML string and return the root element.

    Args:
        xml_string: The XML content as a string

    Returns:
        The root element of the XML document

    Raises:
        ET.ParseError: If the XML is not well-formed
    """
    try:
        return ET.fromstring(xml_string)
    except ET.ParseError as parse_error:
        raise ET.ParseError(f"Error parsing XML string: {parse_error}")


def get_element_text(root: ET.Element, xpath: str, default: Any = None) -> Any:
    """
    Get the text content of an element using XPath.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the element
        default: Default value to return if the element is not found

    Returns:
        The text content of the element, or the default value if not found
    """
    element = root.find(xpath)
    if element is None:
        return default
    return element.text


def get_element_attribute(root: ET.Element, xpath: str, attribute: str, default: Any = None) -> Any:
    """
    Get the value of an attribute using XPath.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the element
        attribute: Name of the attribute
        default: Default value to return if the attribute is not found

    Returns:
        The value of the attribute, or the default value if not found
    """
    element = root.find(xpath)
    if element is None:
        return default
    return element.get(attribute, default)


def get_elements(root: ET.Element, xpath: str) -> list[ET.Element]:
    """
    Get all elements matching an XPath expression.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the elements

    Returns:
        A list of elements matching the XPath expression
    """
    return root.findall(xpath)


def get_element_texts(root: ET.Element, xpath: str) -> list[str]:
    """
    Get the text content of all elements matching an XPath expression.

    Args:
        root: The root element of the XML document
        xpath: XPath expression to find the elements

    Returns:
        A list of text content from elements matching the XPath expression
    """
    elements = get_elements(root, xpath)
    return [element.text for element in elements if element.text]


def get_architecture_title(file_path: Union[str, Path]) -> Optional[str]:
    """
    Extract the title from an architecture XML document.

    Args:
        file_path: Path to the architecture XML file

    Returns:
        The title of the architecture, or None if not found
    """
    try:
        root = parse_xml_file(file_path)
        # Try different possible locations for the title
        title = get_element_text(root, ".//Title")
        if title:
            return title

        title = get_element_text(root, ".//MetaAgent/Title")
        if title:
            return title

        title = get_element_text(root, ".//Overview/Title")
        if title:
            return title

        return None
    except (FileNotFoundError, ET.ParseError):
        return None


def get_protocol_name(file_path: Union[str, Path]) -> Optional[str]:
    """
    Extract the protocol name from a protocol XML document.

    Args:
        file_path: Path to the protocol XML file

    Returns:
        The name of the protocol, or None if not found
    """
    try:
        root = parse_xml_file(file_path)
        # Try different possible locations for the protocol name
        name = get_element_text(root, ".//Name")
        if name:
            return name

        name = get_element_text(root, ".//Protocol/Name")
        if name:
            return name

        return None
    except (FileNotFoundError, ET.ParseError):
        return None


def xml_to_dict(element: ET.Element) -> dict[str, Any]:
    """
    Convert an XML element to a dictionary.

    Args:
        element: The XML element to convert

    Returns:
        A dictionary representation of the XML element
    """
    result = {}

    # Add attributes
    for attribute_key, attribute_value in element.attrib.items():
        result[f"@{attribute_key}"] = attribute_value

    # Add text content if it exists and is not just whitespace
    if element.text and element.text.strip():
        result["#text"] = element.text.strip()

    # Add child elements
    for child_element in element:
        child_dict = xml_to_dict(child_element)
        child_tag = child_element.tag

        # Handle multiple children with the same tag
        if child_tag in result:
            if isinstance(result[child_tag], list):
                result[child_tag].append(child_dict)
            else:
                result[child_tag] = [result[child_tag], child_dict]
        else:
            result[child_tag] = child_dict

    return result


parse_xml_file = parse_xml_file
parse_xml_string = parse_xml_string
get_element_text = get_element_text
get_element_attribute = get_element_attribute
get_elements = get_elements
get_element_texts = get_element_texts
get_architecture_title = get_architecture_title
get_protocol_name = get_protocol_name
xml_to_dict = xml_to_dict

# rich_console.py
from rich.console import Console
from rich.table import Table
from rich.syntax import Syntax
from rich.panel import Panel
from rich.text import Text
from typing import Any, Optional


# Singleton Console instance
def get_console() -> Console:
    if not hasattr(get_console, "_console"):
        get_console._console = Console()
    return get_console._console


def print_panel(content: str, title: Optional[str] = None, style: str = "bold blue"):
    console = get_console()
    panel = Panel(content, title=title, style=style)
    console.print(panel)


def print_table(headers: list[str], rows: list[list[Any]], title: Optional[str] = None):
    console = get_console()
    table = Table(title=title)
    for header in headers:
        table.add_column(header)
    for row in rows:
        table.add_row(*[str(cell) for cell in row])
    console.print(table)


def print_syntax(code: str, language: str = "python", title: Optional[str] = None):
    console = get_console()
    syntax = Syntax(code, language, theme="monokai", line_numbers=True)
    if title:
        console.print(Panel(syntax, title=title))
    else:
        console.print(syntax)


def print_success(message: str):
    console = get_console()
    console.print(f"[bold green] {message}")


def print_error(message: str):
    console = get_console()
    console.print(f"[bold red] {message}")


def print_warning(message: str):
    console = get_console()
    console.print(f"[bold yellow]! {message}")


def print_info(message: str):
    console = get_console()
    console.print(f"[bold blue] {message}")


get_console = get_console
print_panel = print_panel
print_table = print_table
print_syntax = print_syntax
print_success = print_success
print_error = print_error
print_warning = print_warning
print_info = print_info

# environment.py
import re
import os
from pathlib import Path
from typing_extensions import Callable
from pydantic import BaseModel, ConfigDict
from getpass import getpass
from dotenv import load_dotenv

load_dotenv()


class EnvironmentError(Exception):
    """Base exception for environment configuration errors."""

    pass


def is_sensitive_variable(name: str) -> bool:
    """
    Check if a variable name contains common sensitive terms.

    Args:
        name: The variable name to check

    Returns:
        True if the variable is likely sensitive, False otherwise
    """
    sensitive_terms = [
        "key",
        "token",
        "secret",
        "password",
        "credential",
        "auth",
        "api_key",
        "access_token",
        "private",
        "ssh",
        "certificate",
    ]

    name_lower = name.lower()
    return any(term in name_lower for term in sensitive_terms)


def mask_sensitive_value(value: str) -> str:
    """
    Mask a sensitive value for display.

    Args:
        value: The value to mask

    Returns:
        Masked value (first 2 chars + 3 stars)
    """
    if not value or len(value) <= 2:
        return "***"
    return value[:2] + "***"


class VariableDefinition(BaseModel):
    """Definition of an environment variable."""

    name: str
    type: type
    required: bool = True
    default: any = None
    validator: Callable[[any], bool] | None = None
    model_config = ConfigDict(arbitrary_types_allowed=True)

    @property
    def is_sensitive(self) -> bool:
        """Check if this variable is sensitive."""
        return is_sensitive_variable(self.name)


class EnvironmentConfig(BaseModel):
    """Manages environment configuration with validation."""

    definitions: dict[str, VariableDefinition] = {}
    _variables: dict[str, any] = {}

    def list_variables(self):
        for name, definition in self._definitions.items():
            if definition.is_sensitive:
                print(f"{name}: ****")
            else:
                print(f"{name}: {self._variables[name]}")

    def define_required(self, name: str, type_: type, **kwargs) -> None:
        """Define a required environment variable."""
        self._definitions[name] = VariableDefinition(name=name, type=type_, required=True, **kwargs)

    def define_optional(self, name: str, type_: type, **kwargs) -> None:
        """Define an optional environment variable."""
        self._definitions[name] = VariableDefinition(
            name=name, type=type_, required=False, **kwargs
        )

    def set(self, name: str, value: str) -> None:
        """Set an environment variable value."""
        if name not in self._definitions:
            raise EnvironmentError(f"Variable {name} not defined")

        definition = self._definitions[name]
        try:
            # Convert value to the specified type
            converted_value = definition.type(value)

            # Apply validation
            if definition.min_value is not None and converted_value < definition.min_value:
                raise EnvironmentError(
                    f"{name} must be greater than or equal to {definition.min_value}"
                )

            if definition.max_value is not None and converted_value > definition.max_value:
                raise EnvironmentError(
                    f"{name} must be less than or equal to {definition.max_value}"
                )

            if definition.pattern is not None and isinstance(converted_value, str):
                if not re.match(definition.pattern, converted_value):
                    raise EnvironmentError(f"{name} must match pattern {definition.pattern}")

            if definition.validator is not None and not definition.validator(converted_value):
                raise EnvironmentError(f"{name} failed custom validation")

            self._variables[name] = converted_value

        except (ValueError, TypeError) as e:
            raise EnvironmentError(f"Invalid value for {name}: {str(e)}")

    def get(self, name: str, default: any = None) -> any:
        """
        Get an environment variable value.

        Args:
            name: The variable name
            default: Default value if not found

        Returns:
            The variable value or default
        """
        if name not in self._variables:
            return default
        return self._variables[name]

    def get_masked(self, name: str) -> str:
        """
        Get a masked representation of a variable value.

        Args:
            name: The variable name

        Returns:
            Masked value if sensitive, actual value otherwise
        """
        if name not in self._variables:
            return ""

        value = self._variables[name]
        definition = self._definitions[name]

        if definition.is_sensitive and isinstance(value, str):
            return mask_sensitive_value(value)
        return str(value)

    def load_from_file(self, file_path: str | Path) -> None:
        """Load environment variables from a file."""
        file_path = Path(file_path)
        if not file_path.exists():
            raise EnvironmentError(f"Environment file not found: {file_path}")

        with open(file_path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    try:
                        name, value = line.split("=", 1)
                        name = name.strip()
                        value = value.strip()
                        self.set(name, value)
                    except ValueError:
                        continue

    def load_from_system(self) -> None:
        """Load environment variables from system environment."""
        for name, definition in self._definitions.items():
            if name in os.environ:
                self.set(name, os.environ[name])

    def prompt_for_missing(self) -> None:
        """Prompt for missing required variables."""
        for name, definition in self._definitions.items():
            if definition.required and name not in self._variables:
                if definition.is_sensitive:
                    value = getpass(f"Enter {name}: ")
                else:
                    value = input(f"Enter {name}: ")
                self.set(name, value)

    def validate(self) -> None:
        """Validate all environment variables according to their definitions."""
        for variable_key, variable_definition in self._definitions.items():
            variable_value = self._variables.get(variable_key)
            if variable_definition.required and variable_value is None:
                raise EnvironmentError(f"Missing required environment variable: {variable_key}")
            if variable_value is not None:
                if not isinstance(variable_value, variable_definition.type):
                    raise TypeError(
                        f"Environment variable '{variable_key}' should be of type {variable_definition.type.__name__}"
                    )
                if variable_definition.validator and not variable_definition.validator(
                    variable_value
                ):
                    raise ValueError(
                        f"Environment variable '{variable_key}' failed custom validation."
                    )

    def merge(self, other: "EnvironmentConfig") -> None:
        """Merge another environment configuration into this one."""
        # First merge definitions
        for name, definition in other._definitions.items():
            if name not in self._definitions:
                self._definitions[name] = definition

        # Then merge values
        for name, value in other._variables.items():
            self.set(name, str(value))


EnvironmentError = EnvironmentError
is_sensitive_variable = is_sensitive_variable
mask_sensitive_value = mask_sensitive_value
VariableDefinition = VariableDefinition
EnvironmentConfig = EnvironmentConfig

# context.py
import os
import xml.etree.ElementTree as ET
from pathlib import Path
from pydantic import BaseModel
from loguru import logger

from typing import Optional

console = get_console()


class ContextError(Exception):
    """Exception raised for context-related errors."""

    pass


class ContextFileError(ContextError):
    """Exception raised for file operation errors."""

    pass


class ContextValidationError(ContextError):
    """Exception raised for content validation errors."""

    pass


path_manager = get_path_manager()


class CtxModel(BaseModel):
    """
    Represents a development context, including all relevant file contents and paths.
    """

    path: str
    architecture: str
    progress: str
    tasks: str
    protocol: str = ""


class CtxMngrModel(BaseModel):
    """
    Model for managing a collection of CtxModel instances and the context directory path.
    """

    contexts: list[CtxModel] = []
    # Base directory for contexts (alias for context_dir)
    context_dir: Path = path_manager.get_context_dir()
    base_dir: Path = path_manager.get_context_dir()
    context: CtxModel | None = None
    architecture_path: str | Path = path_manager.get_architecture_file()
    progress_path: str | Path = path_manager.get_progress_file()
    tasks_path: str | Path = path_manager.get_tasks_file()
    architecture_content: str = ""
    progress_content: str = ""
    tasks_content: str = ""
    protocol_content: str = ""


class ContextManager(CtxMngrModel):
    """
    Manages development context files in the .erasmus/context directory.
    Uses CtxModel as the in-memory storage for context data.
    Handles context selection, loading, saving, and file operations for architecture, progress, and tasks only.
    Protocol handling is managed by erasmus/protocol.py.
    """

    def __init__(self, base_dir: Optional[str] = None, base_path: Optional[str] = None) -> None:
        """
        Initialize the context manager.

        Args:
            base_dir: Base directory for contexts. Defaults to path_manager.get_context_dir().
            base_path: Alias for base_dir (for compatibility).
        """
        # Initialize BaseModel internals
        super().__init__()
        # Determine base directory parameter (base_path overrides base_dir)
        chosen_dir = base_path if base_path is not None else base_dir
        # Set base directory for contexts
        self.base_dir: Path = Path(chosen_dir) if chosen_dir else path_manager.get_context_dir()
        self.base_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"Initialized ContextManager with base path: {self.base_dir}")
        self.context: Optional[CtxModel] = None
        self.architecture_path: Path = path_manager.get_architecture_file()
        self.progress_path: Path = path_manager.get_progress_file()
        self.tasks_path: Path = path_manager.get_tasks_file()
        self.architecture_content: Optional[str] = None
        self.progress_content: Optional[str] = None
        self.tasks_content: Optional[str] = None
        # Initialization complete

    def create_context(
        self,
        context_name: str,
        architecture_content: str = None,
        progress_content: str = None,
        tasks_content: str = None,
    ) -> None:
        """Create a new development context using XML templates for architecture, progress, and tasks. Optionally accept user content for each file."""
        sanitized_name = self._sanitize_name(context_name)
        context_dir = path_manager.get_context_dir() / sanitized_name
        if context_dir.exists():
            raise ContextError(f"Context already exists: {context_name}")
        # Create context directory
        context_dir.mkdir(parents=True, exist_ok=False)
        # Use the correct template directory from the path manager
        template_dir = path_manager.template_dir
        template_map = {
            "ctx.architecture.xml": (
                template_dir / "architecture.xml",
                architecture_content,
                "Architecture",
            ),
            "ctx.progress.xml": (
                template_dir / "progress.xml",
                progress_content,
                "Progress",
            ),
            "ctx.tasks.xml": (template_dir / "tasks.xml", tasks_content, "Tasks"),
        }
        for target_name, (
            template_path,
            user_content,
            root_tag,
        ) in template_map.items():
            content = None
            if user_content is not None and user_content.strip():
                try:
                    ET.fromstring(user_content)
                    content = user_content
                except Exception:
                    content = f'<?xml version="1.0" encoding="UTF-8"?>\n<{root_tag}>{user_content}</{root_tag}>'
            elif template_path.exists():
                content = template_path.read_text()
            else:
                content = f'<?xml version="1.0" encoding="UTF-8"?>\n<{root_tag}></{root_tag}>'
            (context_dir / target_name).write_text(content)

    def get_context(self, context_name: str) -> CtxModel:
        """Get a context model by name."""
        return self.get_context_model(context_name)

    @property
    def base_path(self) -> Path:
        """Alias for base_dir: get the base directory path for contexts."""
        return self.base_dir

    def save_context_file(self, context_name: str, filename: str, content: str) -> None:
        """Save raw content to a file in the specified context."""
        context_dir = self.get_context_path(context_name)
        context_dir.mkdir(parents=True, exist_ok=True)
        file_path = context_dir / filename
        file_path.write_text(content)

    def load_context_file(self, context_name: str, filename: str) -> str:
        """Load content from a file in the specified context, returning sanitized text."""
        context_dir = self.get_context_path(context_name)
        file_path = context_dir / filename
        if not file_path.exists():
            return ""
        raw = file_path.read_text()
        return self._sanitize_content(raw)

    def list_context_files(self, context_name: str) -> list[str]:
        """List all file names in the specified context directory."""
        context_dir = self.get_context_path(context_name)
        if not context_dir.exists():
            return []
        return [
            context_file.name for context_file in context_dir.iterdir() if context_file.is_file()
        ]

    def delete_context_file(self, context_name: str, filename: str) -> None:
        """Delete a file in the specified context directory."""
        context_dir = self.get_context_path(context_name)
        file_path = context_dir / filename
        if file_path.exists():
            file_path.unlink()

    def update_architecture(self, context_name: str, content: str) -> None:
        """Update the architecture file content for a context."""
        self.save_context_file(context_name, "ctx.architecture.xml", content)

    def update_progress(self, context_name: str, content: str) -> None:
        """Update the progress file content for a context."""
        self.save_context_file(context_name, "ctx.progress.xml", content)

    def update_tasks(self, context_name: str, content: str) -> None:
        """Update the tasks file content for a context."""
        self.save_context_file(context_name, "ctx.tasks.xml", content)
        # End of initialization

    def _sanitize_name(self, context_name: str) -> str:
        """
        Sanitize a context name for filesystem use.
        Args:
            context_name: The context name to sanitize.
        Returns:
            The sanitized name.
        """
        return _sanitize_string(context_name)

    def _get_context_dir(self, context_name: str) -> Path:
        """
        Get the directory for a context.
        Args:
            context_name: The context name.
        Returns:
            The context directory path.
        """
        return self.base_dir / self._sanitize_name(context_name)

    def _sanitize_filename(self, filename: str) -> str:
        """
        Sanitize a filename to be ASCII-only and safe for filesystem operations.
        Args:
            filename: The filename to sanitize
        Returns:
            Sanitized filename
        """
        return _sanitize_string(filename)

    def _sanitize_content(self, content: str) -> str:
        """
        Sanitize XML content to be ASCII-only and well-formed.
        Args:
            content: The content to sanitize
        Returns:
            Sanitized content
        """
        return _sanitize_xml_content(content)

    def get_context_path(self, context_name: str) -> Path:
        """
        Get the path for a context's directory.
        Args:
            context_name: Name of the context
        Returns:
            Path to the context directory
        """
        sanitized_name = self._sanitize_filename(context_name)
        return self.base_dir / sanitized_name

    def get_context_dir_path(self, context_name: str) -> Optional[Path]:
        """
        Get the directory path for a context if it exists.
        Args:
            context_name: Name of the context
        Returns:
            Path to the context directory, or None if it doesn't exist
        """
        try:
            context_dir = self._get_context_dir(context_name)
            return context_dir if context_dir.exists() else None
        except Exception as context_error:
            raise ContextFileError(f"Failed to get context path: {context_error}")

    def save_contexts(self) -> list[CtxModel]:
        """
        Save all contexts by loading them from disk into CtxModel instances.
        Returns:
            List of saved CtxModel instances
        """
        context_models: list[CtxModel] = []
        for context_directory in self.base_dir.iterdir():
            if context_directory.is_dir():
                context_name = context_directory.name
                try:
                    context_path = self.get_context_dir_path(context_name)
                    if context_path:
                        context_models.append(self.get_context_model(context_name))
                except Exception as context_error:
                    logger.error(f"Failed to save context {context_name}: {context_error}")
        return context_models

    def delete_context(self, context_name: str) -> None:
        """
        Delete a context and all its files.
        Args:
            context_name: Name of the context to delete
        Raises:
            ContextFileError: If deletion fails
        """
        try:
            context_dir = self._get_context_dir(context_name)
            if not context_dir.exists():
                raise ContextFileError(f"Context does not exist: {context_name}")
            for file_path in context_dir.iterdir():
                if file_path.is_file():
                    file_path.unlink()
            context_dir.rmdir()
            logger.info(f"Deleted context: {context_name}")
        except Exception as context_error:
            raise ContextFileError(f"Failed to delete context: {context_error}")

    def display_context(self, context_name: str) -> None:
        """
        Display a context's information, including file sizes and paths.
        Args:
            context_name: Name of the context to display
        Raises:
            ContextFileError: If context doesn't exist
        """
        try:
            context_dir = self.get_context_dir_path(context_name)
            if not context_dir:
                raise ContextFileError(f"Context does not exist: {context_name}")
            print(f"Context: {context_name}")
            print(f"Path: {context_dir}")
            print(
                f"Architecture: {len(self.read_file(context_name, 'architecture')) if self.read_file(context_name, 'architecture') else 'N/A'}"
            )
            print(
                f"Progress: {len(self.read_file(context_name, 'progress')) if self.read_file(context_name, 'progress') else 'N/A'}"
            )
            print(
                f"Tasks: {len(self.read_file(context_name, 'tasks')) if self.read_file(context_name, 'tasks') else 'N/A'}"
            )
            print(
                f"Protocol: {len(self.read_file(context_name, 'protocol')) if self.read_file(context_name, 'protocol') else 'N/A'}"
            )
        except Exception as context_error:
            raise ContextFileError(f"Failed to display context: {context_error}")

    def list_contexts(self) -> list[str]:
        """
        List all development contexts by name.
        Returns:
            A list of context names.
        Raises:
            ContextFileError: If contexts cannot be listed.
        """
        try:
            return [
                context_directory.name
                for context_directory in self.base_dir.iterdir()
                if context_directory.is_dir()
            ]
        except Exception as context_error:
            raise ContextFileError(f"Failed to list contexts: {context_error}")

    def select_context(self) -> CtxModel:
        """
        Interactively select a context, loading it into memory and saving the current context if needed.
        Returns:
            The selected CtxModel instance
        Raises:
            ContextFileError: If no contexts exist
        """
        context_models = self.save_contexts()
        if not context_models:
            raise ContextFileError("No contexts exist")
        print("Available contexts:")
        for context_index, context_model in enumerate(context_models):
            print(f"{context_index + 1}. {context_model.path}")
        while True:
            try:
                user_choice = int(input("Select a context (number): "))
                if 1 <= user_choice <= len(context_models):
                    selected_context = context_models[user_choice - 1]
                    # Write current in-memory context to files before switching
                    if self.context:
                        self._write_context_to_files()
                    self.context = selected_context
                    self._load_context_to_memory(selected_context)
                    return selected_context
                print("Invalid choice. Please try again.")
            except ValueError:
                print("Please enter a number.")

    def _write_context_to_files(self) -> None:
        """
        Write the in-memory context content to the working files.
        """
        if self.context:
            if self.architecture_content is not None:
                self.architecture_path.write_text(self.architecture_content)
            if self.progress_content is not None:
                self.progress_path.write_text(self.progress_content)
            if self.tasks_content is not None:
                self.tasks_path.write_text(self.tasks_content)
            if self.protocol_content is not None:
                self.protocol_path.write_text(self.protocol_content)

    def _load_context_to_memory(self, context_model: CtxModel) -> None:
        """
        Load the content of a CtxModel into the in-memory fields.
        Args:
            context_model: The CtxModel to load
        """
        self.architecture_content = context_model.architecture
        self.progress_content = context_model.progress
        self.tasks_content = context_model.tasks

    def update_architecture(self, context_name: str, architecture_content: str) -> CtxModel:
        """
        Update a context's architecture file and in-memory content.
        Args:
            context_name: Name of the context
            architecture_content: New architecture content
        Returns:
            Updated CtxModel instance
        Raises:
            ContextFileError: If update fails
        """
        try:
            self.update_file(context_name, "architecture", architecture_content)
            if self.context and self.context.path.endswith(context_name):
                self.architecture_content = architecture_content
            return self.get_context_model(context_name)
        except Exception as error:
            raise ContextFileError(f"Failed to update architecture: {error}")

    def update_progress(self, context_name: str, progress_content: str) -> CtxModel:
        """
        Update a context's progress file and in-memory content.
        Args:
            context_name: Name of the context
            progress_content: New progress content
        Returns:
            Updated CtxModel instance
        Raises:
            ContextFileError: If update fails
        """
        try:
            self.update_file(context_name, "progress", progress_content)
            if self.context and self.context.path.endswith(context_name):
                self.progress_content = progress_content
            return self.get_context_model(context_name)
        except Exception as error:
            raise ContextFileError(f"Failed to update progress: {error}")

    def update_tasks(self, context_name: str, tasks_content: str) -> CtxModel:
        """
        Update a context's tasks file and in-memory content.
        Args:
            context_name: Name of the context
            tasks_content: New tasks content
        Returns:
            Updated CtxModel instance
        Raises:
            ContextFileError: If update fails
        """
        try:
            self.update_file(context_name, "tasks", tasks_content)
            if self.context and self.context.path.endswith(context_name):
                self.tasks_content = tasks_content
            return self.get_context_model(context_name)
        except Exception as error:
            raise ContextFileError(f"Failed to update tasks: {error}")

    def update_file(self, context_name: str, file_type: str, content: str) -> None:
        """
        Update a file in a development context.
        Args:
            context_name: The name of the context.
            file_type: The type of file to update (architecture, progress, tasks, protocol).
            content: The content to write to the file.
        Raises:
            ContextError: If the file cannot be updated.
        """
        context_dir = self.get_context_dir_path(context_name)
        if not context_dir:
            raise ContextError(f"Context does not exist: {context_name}")
        file_path = context_dir / f"ctx.{file_type}.xml"
        try:
            file_path.write_text(content)
        except Exception as error:
            raise ContextError(f"Failed to update file: {error}")

    def read_file(self, context_name: str, file_type: str) -> Optional[str]:
        """
        Read a file from a development context.
        Args:
            context_name: The name of the context.
            file_type: The type of file to read (architecture, progress, tasks, protocol).
        Returns:
            The file content, or None if the file does not exist.
        Raises:
            ContextError: If the file cannot be read.
        """
        context_dir = self.get_context_dir_path(context_name)
        if not context_dir:
            raise ContextError(f"Context does not exist: {context_name}")
        file_path = context_dir / f"ctx.{file_type}.xml"
        try:
            return file_path.read_text() if file_path.exists() else None
        except Exception as error:
            raise ContextError(f"Failed to read file: {error}")

    def edit_file(self, context_name: str, file_type: str, editor: Optional[str] = None) -> None:
        """
        Edit a file in a development context using the specified editor.
        Args:
            context_name: The name of the context.
            file_type: The type of file to edit (architecture, progress, tasks, protocol).
            editor: The editor to use. If None, the default editor is used.
        Raises:
            ContextError: If the file cannot be edited.
        """
        context_dir = self.get_context_dir_path(context_name)
        if not context_dir:
            raise ContextError(f"Context does not exist: {context_name}")
        file_path = context_dir / f"ctx.{file_type}.xml"
        if not file_path.exists():
            raise ContextError(f"File does not exist: {file_type}")
        try:
            editor_cmd = editor or os.environ.get("EDITOR", "nano")
            os.system(f"{editor_cmd} {file_path}")
        except Exception as error:
            raise ContextError(f"Failed to edit file: {error}")

    def store_context(self) -> str:
        """
        Store the current context by reading the architecture, progress, and tasks files into memory,
        then writing those values to the context directory files and updating the in-memory CtxModel.
        Returns:
            The name of the stored context
        Raises:
            ContextError: If storing the context fails
        """
        try:
            self.architecture_content = (
                self.architecture_path.read_text() if self.architecture_path.exists() else ""
            )
            self.progress_content = (
                self.progress_path.read_text() if self.progress_path.exists() else ""
            )
            self.tasks_content = self.tasks_path.read_text() if self.tasks_path.exists() else ""
            tree = ET.ElementTree(ET.fromstring(self.architecture_content))
            root = tree.getroot()
            title_elem = root.find(".//Title")
            if title_elem is None or not title_elem.text:
                raise ContextError("Title not found in architecture file")
            title = title_elem.text
            context_name = self._sanitize_name(title)
            context_dir = self._get_context_dir(context_name)
            context_dir.mkdir(parents=True, exist_ok=True)
            (context_dir / "ctx.architecture.xml").write_text(self.architecture_content)
            (context_dir / "ctx.progress.xml").write_text(self.progress_content)
            (context_dir / "ctx.tasks.xml").write_text(self.tasks_content)
            self.context = CtxModel(
                path=str(context_dir),
                architecture=self.architecture_content,
                progress=self.progress_content,
                tasks=self.tasks_content,
            )
            return context_name
        except Exception as error:
            raise ContextError(f"Failed to store context: {error}")

    def load_context(self, context_name: str) -> None:
        """
        Load a stored context by copying its XML files to the root-level .ctx.* XML files.

        Args:
            context_name: Name of the context to load

        Raises:
            ContextError: If the context does not exist or loading fails
        """
        # Locate the context directory
        context_dir = self._get_context_dir(context_name)
        if not context_dir.exists():
            raise ContextError(f"Context does not exist: {context_name}")
        # Copy each context file (XML only) to root-level .ctx files
        try:
            for file_type in ("architecture", "progress", "tasks"):
                src = context_dir / f"ctx.{file_type}.xml"
                if src.exists():
                    dst = getattr(self, f"{file_type}_path")
                    dst.write_text(src.read_text())
                else:
                    logger.warning(
                        f"No {file_type} file found for context '{context_name}' (expected ctx.{file_type}.xml)"
                    )
        except Exception as error:
            raise ContextError(f"Failed to load context '{context_name}': {error}")
        # After loading context files, update IDE rules and global rules
        try:
            _merge_rules_file()
        except Exception as merge_error:
            logger.error(
                f"Failed to update rules file after loading context '{context_name}': {merge_error}"
            )

    def get_context_model(self, context_name: str) -> CtxModel:
        """
        Get a CtxModel instance by context name.
        Args:
            context_name: Name of the context
        Returns:
            CtxModel instance
        Raises:
            ContextFileError: If context doesn't exist
        """
        try:
            context_dir = self._get_context_dir(context_name)
            if not context_dir.exists():
                raise ContextFileError(f"Context does not exist: {context_name}")
            architecture = self.read_file(context_name, "architecture") or ""
            progress = self.read_file(context_name, "progress") or ""
            tasks = self.read_file(context_name, "tasks") or ""
            return CtxModel(
                path=str(context_dir),
                architecture=architecture,
                progress=progress,
                tasks=tasks,
            )
        except Exception as context_error:
            raise ContextFileError(f"Failed to get context: {context_error}")

    def _sanitize_string(self, filename: str) -> str:
        """
        Sanitize a filename to be ASCII-only and safe for filesystem operations.

        Args:
            filename: The filename to sanitize

        Returns:
            Sanitized filename
        """
        return _sanitize_string(filename)

    def _sanitize_xml(self, content: str) -> str:
        """
        Sanitize XML content to be ASCII-only and safe for filesystem operations.
        """
        return _sanitize_xml_content(content)


ContextError = ContextError
ContextFileError = ContextFileError
ContextValidationError = ContextValidationError
CtxModel = CtxModel
CtxMngrModel = CtxMngrModel
ContextManager = ContextManager

# protocol.py
from pathlib import Path
from typing import Optional
from pydantic import BaseModel
from loguru import logger


path_manager = get_path_manager()


class ProtocolError(Exception):
    """Exception raised for protocol-related errors."""

    pass


class ProtocolModel(BaseModel):
    """
    Represents a protocol, including its name, path, and content.
    """

    name: str
    path: str
    content: str


class ProtocolManager:
    """
    Manages protocol files for Erasmus.
    Loads base protocol templates from erasmus.erasmus/templates/protocols and custom user protocols from erasmus.erasmus/protocol.
    Provides methods to list, get, create, update, and delete protocols.
    """

    def __init__(self, base_dir: Optional[str] = None, user_dir: Optional[str] = None) -> None:
        # Always use path_manager.template_dir / 'protocols' unless base_dir is explicitly provided
        self.base_template_dir: Path = (
            Path(base_dir) if base_dir is not None else path_manager.template_dir / "protocols"
        )
        self.user_protocol_dir: Path = Path(user_dir) if user_dir else path_manager.protocol_dir
        self.base_template_dir.mkdir(parents=True, exist_ok=True)
        self.user_protocol_dir.mkdir(parents=True, exist_ok=True)
        logger.info(
            f"Initialized ProtocolManager with base template dir: {self.base_template_dir} and user protocol dir: {self.user_protocol_dir}"
        )

    def _sanitize_name(self, protocol_name: str) -> str:
        """Sanitize a protocol name for filesystem use."""
        return _sanitize_string(protocol_name)

    def _get_protocol_path(self, protocol_name: str, is_template: bool = False) -> Path:
        """
        Get the path for a protocol file.
        Args:
            protocol_name: The protocol name
            is_template: If True, look in the template directory; else, user directory
        Returns:
            Path to the protocol file
        """
        sanitized_name = self._sanitize_name(protocol_name)
        directory = self.base_template_dir if is_template else self.user_protocol_dir
        return directory / f"{sanitized_name}.xml"

    def list_protocols(
        self, include_templates: bool = True, include_user: bool = True
    ) -> list[str]:
        """
        List all available protocol names.
        Args:
            include_templates: Include base templates
            include_user: Include user protocols
        Returns:
            List of protocol names
        """
        protocol_names = set()
        if include_templates:
            protocol_names.update(
                [protocol_path.stem for protocol_path in self.base_template_dir.glob("*.xml")]
            )
        if include_user:
            protocol_names.update(
                [protocol_path.stem for protocol_path in self.user_protocol_dir.glob("*.xml")]
            )
        return sorted(protocol_names)

    def get_protocol(self, protocol_name: str) -> Optional[ProtocolModel]:
        """
        Get a protocol by name, searching user protocols first, then templates.
        Args:
            protocol_name: The protocol name
        Returns:
            ProtocolModel if found, else None
        """
        sanitized_name = self._sanitize_name(protocol_name)
        user_path = self._get_protocol_path(sanitized_name, is_template=False)
        template_path = self._get_protocol_path(sanitized_name, is_template=True)
        if user_path.exists():
            content = user_path.read_text()
            return ProtocolModel(name=sanitized_name, path=str(user_path), content=content)
        elif template_path.exists():
            content = template_path.read_text()
            return ProtocolModel(name=sanitized_name, path=str(template_path), content=content)
        else:
            return None

    def create_protocol(self, protocol_name: str, content: str) -> ProtocolModel:
        """
        Create a new user protocol.
        Args:
            protocol_name: The protocol name
            content: The protocol content
        Returns:
            The created ProtocolModel
        Raises:
            FileExistsError: If a user protocol with the same name already exists
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        if protocol_path.exists():
            raise FileExistsError(f"Protocol '{sanitized_name}' already exists.")
        # Use template if content is not provided or empty
        if not isinstance(content, str) or not content.strip():
            template_path = path_manager.template_dir / "protocol.xml"
            if template_path.exists():
                content = template_path.read_text()
            else:
                content = '<?xml version="1.0" encoding="UTF-8"?>\n<Protocol></Protocol>'
        else:
            # If content is not valid XML, wrap it in <Protocol>...</Protocol>
            import xml.etree.ElementTree as ET

            try:
                ET.fromstring(content)
            except Exception:
                content = f'<?xml version="1.0" encoding="UTF-8"?>\n<Protocol>{content}</Protocol>'
        protocol_path.write_text(_sanitize_xml_content(content))
        logger.info(f"Created protocol: {sanitized_name}")
        return ProtocolModel(name=sanitized_name, path=str(protocol_path), content=content)

    def update_protocol(self, protocol_name: str, content: str) -> ProtocolModel:
        """
        Update an existing user protocol.
        Args:
            protocol_name: The protocol name
            content: The new protocol content
        Returns:
            The updated ProtocolModel
        Raises:
            FileNotFoundError: If the protocol does not exist in user protocols
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        if not protocol_path.exists():
            raise FileNotFoundError(f"Protocol '{sanitized_name}' not found in user protocols.")
        # Ensure content is a valid XML string
        if not isinstance(content, str) or not content.strip():
            content = '<?xml version="1.0" encoding="UTF-8"?>\n<Protocol></Protocol>'
        else:
            import xml.etree.ElementTree as ET

            try:
                ET.fromstring(content)
            except Exception:
                content = f'<?xml version="1.0" encoding="UTF-8"?>\n<Protocol>{content}</Protocol>'
        protocol_path.write_text(_sanitize_xml_content(content))
        logger.info(f"Updated protocol: {sanitized_name}")
        return ProtocolModel(name=sanitized_name, path=str(protocol_path), content=content)

    def delete_protocol(self, protocol_name: str) -> None:
        """
        Delete a user protocol.
        Args:
            protocol_name: The protocol name
        Raises:
            FileNotFoundError: If the protocol does not exist in user protocols
            PermissionError: If attempting to delete a template protocol
        """
        sanitized_name = self._sanitize_name(protocol_name)
        protocol_path = self._get_protocol_path(sanitized_name, is_template=False)
        template_path = self._get_protocol_path(sanitized_name, is_template=True)
        # Prevent deletion if protocol is a template
        if template_path.exists():
            raise PermissionError(
                f"Cannot delete template protocol: '{sanitized_name}'. Only custom (user) protocols can be deleted."
            )
        if not protocol_path.exists():
            raise FileNotFoundError(f"Protocol '{sanitized_name}' not found in user protocols.")
        protocol_path.unlink()
        logger.info(f"Deleted protocol: {sanitized_name}")


ProtocolError = ProtocolError
ProtocolModel = ProtocolModel

# file_monitor.py
import os
import time
from typing import Optional, Set
from watchdog.observers import ObserverType, Observer
from watchdog.events import FileSystemEventHandler, FileSystemEvent
from loguru import logger
from pathlib import Path

import re

import xml.etree.ElementTree as ET

# Add a global to track last rules file write time
_last_rules_write_time = None


def _merge_rules_file() -> None:
    """
    Merge current .ctx files into the IDE rules file using the meta_rules.xml template.
    Refreshes IDE detection to ensure correct rules file is used.
    Overwrites the rules file every time with a fresh merge of the template and current context/protocol content.
    Prompts the user to select a protocol if none is set or the file is missing.
    """

    global _last_rules_write_time

    detected_ide = detect_ide_from_env()
    path_manager = get_path_manager(detected_ide)
    template_path = path_manager.template_dir / "meta_rules.xml"
    rules_file_path = path_manager.get_rules_file()
    if not template_path.exists():
        # No template available: fallback to raw merge of ctx files
        logger.warning(f"Template file not found: {template_path}; falling back to raw merge")
        try:
            architecture_text = path_manager.get_architecture_file().read_text()
            progress_text = path_manager.get_progress_file().read_text()
            tasks_text = path_manager.get_tasks_file().read_text()
            merged_content = "\n".join([architecture_text, progress_text, tasks_text])
            if not rules_file_path:
                logger.warning("No rules file configured; skipping local merge")
            else:
                rules_file_path.write_text(merged_content)
                _last_rules_write_time = rules_file_path.stat().st_mtime
                logger.info(f"Updated local rules file (fallback): {rules_file_path}")
        except Exception as exception:
            logger.error(f"Error during fallback merge: {exception}")
        return
    try:
        # Always start from a fresh template
        template_content = template_path.read_text()
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        merged_content = template_content
        merged_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            merged_content,
        )
        merged_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, merged_content
        )
        merged_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, merged_content)
        # Get protocol value from the current_protocol.txt file, or prompt if missing/invalid
        protocol_value = ""
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        protocol_manager = ProtocolManager()
        protocol_name = None
        if current_protocol_path.exists():
            protocol_name = current_protocol_path.read_text().strip()
        protocol_file = None
        if protocol_name:
            # Ensure protocol_name does not have .xml extension already
            if protocol_name.endswith(".xml"):
                protocol_file = path_manager.protocol_dir / protocol_name
            else:
                protocol_file = path_manager.protocol_dir / f"{protocol_name}.xml"
            print(f"[DEBUG] Loaded protocol name: '{protocol_name}'")
            print(f"[DEBUG] Checking protocol file: {protocol_file}")
            # Fallback to template protocols if not found in user protocol dir
            if not protocol_file.exists():
                template_protocol_file = (
                    path_manager.template_dir / "protocols" / f"{protocol_name}.xml"
                )
                print(f"[DEBUG] Checking template protocol file: {template_protocol_file}")
                if template_protocol_file.exists():
                    protocol_file = template_protocol_file
        if not protocol_name or not protocol_file or not protocol_file.exists():
            # Try to extract protocol from the existing rules file using XML parsing
            if rules_file_path and rules_file_path.exists():
                try:
                    tree = ET.parse(rules_file_path)
                    root = tree.getroot()
                    # Try to find <Protocol> block
                    protocol_elem = root.find(".//Protocol")
                    if protocol_elem is not None:
                        protocol_value = ET.tostring(protocol_elem, encoding="unicode")
                        print("[DEBUG] Extracted protocol from existing rules file.")
                except Exception as e:
                    print(f"[DEBUG] Failed to extract protocol from rules file: {e}")
            if not protocol_value:
                # Prompt user to select a protocol
                protocols = protocol_manager.list_protocols()
                if not protocols:
                    logger.error("No protocols found. Cannot update rules file.")
                    return
                print("Available protocols:")
                for idx, pname in enumerate(protocols):
                    print(f"  {idx + 1}. {pname}")
                while True:
                    choice = input("Select a protocol by number or name: ").strip()
                    selected = None
                    if choice.isdigit():
                        idx = int(choice)
                        if 1 <= idx <= len(protocols):
                            selected = protocols[idx - 1]
                    elif choice in protocols:
                        selected = choice
                    if selected:
                        protocol_name = selected.strip()
                        current_protocol_path.write_text(protocol_name)
                        protocol_file = path_manager.protocol_dir / f"{protocol_name}.xml"
                        print(f"[DEBUG] User selected protocol: '{protocol_name}'")
                        print(f"[DEBUG] Checking protocol file: {protocol_file}")
                        # Fallback to template protocols if not found in user protocol dir
                        if not protocol_file.exists():
                            template_protocol_file = (
                                path_manager.template_dir / "protocols" / f"{protocol_name}.xml"
                            )
                            print(
                                f"[DEBUG] Checking template protocol file: {template_protocol_file}"
                            )
                            if template_protocol_file.exists():
                                protocol_file = template_protocol_file
                        if protocol_file.exists():
                            protocol_value = protocol_file.read_text()
                        else:
                            print(f"Protocol file not found: {protocol_file}")
                            continue
                        break
                    print(f"Invalid selection: {choice}")
        else:
            if protocol_file and protocol_file.exists():
                protocol_value = protocol_file.read_text()
        merged_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->", protocol_value, merged_content
        )
        # Overwrite the rules file with the merged content
        if not rules_file_path:
            logger.warning("No rules file configured; skipping local merge")
        else:
            rules_file_path.write_text(merged_content)
            _last_rules_write_time = rules_file_path.stat().st_mtime
            logger.info(f"Updated local rules file: {rules_file_path}")
    except Exception as exception:
        logger.error(f"Error merging rules file: {exception}")


class FileEventHandler(FileSystemEventHandler):
    """
    Handles file system events with debouncing.
    """

    def __init__(self, debounce_time: float = 0.1) -> None:
        """
        Initialize the event handler.
        Args:
            debounce_time: Time in seconds to wait before processing duplicate events
        """
        super().__init__()
        self.debounce_time: float = debounce_time
        self.processed_events: Set[str] = set()
        self.last_processed: dict[str, float] = {}

    def on_modified(self, file_event: FileSystemEvent) -> None:
        """
        Handle file modification events.
        Args:
            file_event: The file system event
        """
        if file_event.is_directory:
            return

        current_time = time.time()
        file_path = file_event.src_path

        # Ignore changes to rules files (e.g., .codex.md, .cursorrules, .windsurfrules, CLAUDE.md)
        if file_path.endswith((".codex.md", ".cursorrules", ".windsurfrules", "CLAUDE.md")):
            return

        # Check if this is a duplicate event within debounce time
        if file_path in self.last_processed:
            if current_time - self.last_processed[file_path] < self.debounce_time:
                return

        self.processed_events.add(file_path)
        self.last_processed[file_path] = current_time
        logger.info(f"File modified: {file_path}")
        # Only trigger on .ctx.*.xml files
        if (
            file_path.endswith(".ctx.architecture.xml")
            or file_path.endswith(".ctx.progress.xml")
            or file_path.endswith(".ctx.tasks.xml")
        ):
            try:
                _merge_rules_file()
            except Exception as merge_error:
                logger.error(f"Failed to update rules file: {merge_error}")


class FileMonitor:
    """
    Monitors a path for file changes.
    """

    def __init__(self, watch_path: str | Path) -> None:
        """
        Initialize the file monitor.
        Args:
            watch_path: Path to monitor for changes
        Raises:
            FileNotFoundError: If watch_path does not exist
        """
        if isinstance(watch_path, str):
            watch_path = Path(watch_path)
        if not watch_path.exists():
            raise FileNotFoundError(f"Watch path does not exist: {watch_path}")

        self.watch_path: str = watch_path
        self.event_handler: FileEventHandler = FileEventHandler()
        self.observer: Optional[ObserverType] = None
        self._is_running: bool = False

    def _matches_rules_file(self, file_path: str) -> bool:
        """
        Check if a path matches rules file patterns.
        Args:
            file_path: Path to check
        Returns:
            bool: True if path matches rules file patterns
        """
        return file_path.endswith((".windsurfrules", ".cursorrules"))

    def start(self) -> None:
        """
        Start monitoring the watch path.
        """
        if self._is_running:
            logger.warning("Monitor is already running")
            return

        self.observer = Observer()
        self.observer.schedule(self.event_handler, self.watch_path, recursive=False)
        self.observer.start()
        self._is_running = True
        logger.info(f"Started monitoring: {self.watch_path}")

    def stop(self) -> None:
        """
        Stop monitoring the watch path.
        """
        if not self._is_running:
            logger.warning("Monitor is not running")
            return

        if self.observer:
            self.observer.stop()
            self.observer.join()
            self.observer = None
            self._is_running = False
            logger.info(f"Stopped monitoring: {self.watch_path}")

    def __enter__(self) -> "FileMonitor":
        """
        Context manager entry.
        Returns:
            FileMonitor: The monitor instance
        """
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """
        Context manager exit.
        """
        self.stop()


FileEventHandler = FileEventHandler

# context_commands.py
import typer
from loguru import logger

import xml.dom.minidom as minidom

import os

context_manager = ContextManager()
context_app = typer.Typer(help="Manage development contexts and their files.")


@context_app.command("get")
def get_context(name: str = typer.Argument(..., help="Name of the context to get")):
    """Get detailed information of a development context."""
    try:
        # Use display_context to print full details
        context_manager.display_context(name)
    except ContextError as e:
        # Extract underlying error if prefixed by display_context
        error_msg = str(e)
        prefix = "Failed to display context: "
        if error_msg.startswith(prefix):
            error_msg = error_msg[len(prefix) :]
        typer.echo(f"Error: Failed to get context: {error_msg}")
        raise typer.Exit(1)
    # Successful display
    raise typer.Exit(0)


def show_context_help_and_exit():
    """Show help menu and exit with error code."""
    command_rows = [
        ["erasmus context list", "List all contexts"],
        ["erasmus context create", "Create a new context"],
        ["erasmus context show", "Show context details"],
        ["erasmus context update", "Update context files"],
        ["erasmus context edit", "Edit context files"],
        ["erasmus context store", "Store the current context"],
        ["erasmus context select", "Select and load a context interactively"],
        ["erasmus context load", "Load a context by name to root .ctx XML files"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus context <command> --help")
    raise typer.Exit(1)


@context_app.callback(invoke_without_command=True)
def context_callback(ctx: typer.Context):
    """
    Manage development contexts and their files.
    """
    if ctx.invoked_subcommand is None:
        command_rows = [
            ["erasmus context list", "List all contexts"],
            ["erasmus context create", "Create a new context"],
            ["erasmus context show", "Show context details"],
            ["erasmus context update", "Update context files"],
            ["erasmus context edit", "Edit context files"],
            ["erasmus context store", "Store the current context"],
            ["erasmus context select", "Select and load a context interactively"],
            ["erasmus context load", "Load a context by name to root .ctx XML files"],
        ]
        print_table(["Command", "Description"], command_rows, title="Available Commands")
        typer.echo("\nFor more information about a command, run:")
        typer.echo("  erasmus context <command> --help")
        raise typer.Exit(0)


@context_app.command()
def create(name: str = typer.Argument(None, help="Name of the context to create")):
    """Create a new development context and display its path."""
    try:
        if not name:
            name = typer.prompt("Enter the context name")
        if not name:
            print_table(
                ["Error"],
                [["Context name is required."]],
                title="Context Creation Failed",
            )
            raise typer.Exit(1)
        context_manager.create_context(name)
        # Retrieve created context model for path
        context = context_manager.get_context(name)
        # Display created context in a table
        context_rows = [[context.path]]
        print_table(["Context Path"], context_rows, title=f"Created Context: {name}")
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Creation Failed")
        raise typer.Exit(1)


@context_app.command()
def delete(name: str = typer.Argument(None, help="Name of the context to delete")):
    """Delete a context.

    This command permanently removes a context folder and its files.
    Use with caution as this action cannot be undone.
    """
    try:
        if not name:
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Deletion Failed",
                )
                raise typer.Exit(1)
            name = selected
        context_manager.delete_context(name)
        print_table(["Info"], [[f"Deleted context: {name}"]], title="Context Deleted")
        raise typer.Exit(0)
    except Exception as e:
        print_table(["Error"], [[str(e)]], title="Context Deletion Failed")
        raise typer.Exit(1)


@context_app.command()
def list():
    """List all development contexts.

    This command shows all available contexts and their basic information.
    Use 'show' to view detailed information about a specific context.
    """
    try:
        contexts = context_manager.list_contexts()
        if not contexts:
            print_table(["Info"], [["No contexts found"]], title="Available Contexts")
            return

        # Display contexts in a table
        context_rows = [[context] for context in contexts]
        print_table(["Context Name"], context_rows, title="Available Contexts")
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Listing Failed")
        show_context_help_and_exit()


def preview(text, lines=10):
    if not text:
        return ""
    split = text.splitlines()
    if len(split) > lines:
        return "\n".join(split[:lines]) + "\n..."
    return text


@context_app.command()
def show(name: str = typer.Argument(None, help="Name of the context to show")):
    """Show details of a development context.

    This command displays detailed information about a specific context,
    including file sizes and paths. If no name is supplied, it will prompt the user to select one.
    """
    try:
        if not name:
            # List available contexts and prompt for selection
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Show Failed",
                )
                raise typer.Exit(1)
            name = selected
        context_dir = context_manager.get_context_path(name)

        def read_context_file(context_dir, file_type):
            for ext in (".xml", ".md"):
                file_path = context_dir / f"ctx.{file_type}{ext}"
                if file_path.exists():
                    return file_path.read_text()
            return ""

        context_rows = [
            ["Path", str(context_dir)],
            ["Architecture", preview(read_context_file(context_dir, "architecture"))],
            ["Progress", preview(read_context_file(context_dir, "progress"))],
            ["Tasks", preview(read_context_file(context_dir, "tasks"))],
            ["Protocol", preview(read_context_file(context_dir, "protocol"))],
        ]
        print_table(
            ["Field", "Preview (first 10 lines)"],
            context_rows,
            title=f"Context: {name}",
        )
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Show Failed")
        show_context_help_and_exit()


@context_app.command()
def update(
    name: str = typer.Argument(None, help="Name of the context to update"),
    file_type: str = typer.Argument(
        None, help="Type of file to update (architecture, progress, tasks, protocol)"
    ),
    content: str = typer.Argument(None, help="Content to write to the file"),
):
    """Update a file in a development context.

    This command updates the content of a specific file in a context.
    The file type must be one of: architecture, progress, tasks, or protocol.
    """
    try:
        if not name:
            # List available contexts and prompt for selection
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Update Failed",
                )
                raise typer.Exit(1)
            name = selected
        if not file_type:
            file_type = typer.prompt(
                "Enter the file type to update (architecture, progress, tasks, protocol)"
            )
        if not file_type:
            print_table(
                ["Error"],
                [["File type is required for update."]],
                title="Context Update Failed",
            )
            raise typer.Exit(1)
        if content is None:
            content = typer.prompt(f"Enter the new content for {file_type}")
        if not content:
            print_table(
                ["Error"],
                [["Content is required for update."]],
                title="Context Update Failed",
            )
            raise typer.Exit(1)
        context_manager.update_file(name, file_type, content)
        print_table(
            ["Info"],
            [[f"Updated {file_type} in context: {name}"]],
            title="Context Updated",
        )
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Update Failed")
        show_context_help_and_exit()


@context_app.command()
def cat(
    name: str = typer.Argument(..., help="Name of the context"),
    file_type: str = typer.Argument(
        ..., help="Type of file to read (architecture, progress, tasks, protocol)"
    ),
):
    """Display the contents of a file in a development context.

    This command shows the raw contents of a specific file in a context.
    The file type must be one of: architecture, progress, tasks, or protocol.
    """
    try:
        content = context_manager.read_file(name, file_type)
        if content is None:
            print_table(
                ["Error"],
                [[f"File not found: {file_type}"]],
                title="Context Cat Failed",
            )
            logger.info("Available file types: architecture, progress, tasks, protocol")
            show_context_help_and_exit()

        # Pretty print XML for better readability
        try:
            # Parse the XML content
            dom = minidom.parseString(content)
            # Pretty print with indentation
            pretty_xml = dom.toprettyxml(indent="  ")
            print(pretty_xml)
        except Exception:
            # If XML parsing fails, print the raw content
            print(content)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Cat Failed")
        show_context_help_and_exit()


@context_app.command()
def edit(
    name: str = typer.Argument(None, help="Name of the context"),
    file_type: str = typer.Argument(
        None, help="Type of file to edit (architecture, progress, tasks, protocol)"
    ),
    editor: str = typer.Argument(None, help="Editor to use for editing"),
):
    """Edit a file in a development context.

    This command opens a file in your default editor (or specified editor).
    The file type must be one of: architecture, progress, tasks, or protocol.
    """
    if not name:
        # List available contexts and prompt for selection
        contexts = context_manager.list_contexts()
        if not contexts:
            print_table(["Info"], [["No contexts found"]], title="Available Contexts")
            raise typer.Exit(1)
        context_rows = [
            [str(index + 1), context_name] for index, context_name in enumerate(contexts)
        ]
        print_table(["#", "Context Name"], context_rows, title="Available Contexts")
        choice = typer.prompt("Select a context by number or name")
        selected = None
        if choice.isdigit():
            index = int(choice)
            if 1 <= index <= len(contexts):
                selected = contexts[index - 1]
        else:
            if choice in contexts:
                selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Context Edit Failed",
            )
            raise typer.Exit(1)
        name = selected
    if not file_type:
        file_type = typer.prompt(
            "Enter the file type to edit (architecture, progress, tasks, protocol)"
        )
    if not file_type:
        print_table(
            ["Error"],
            [["File type is required for edit."]],
            title="Context Edit Failed",
        )
        raise typer.Exit(1)
    context_dir = context_manager.get_context_path(name)
    file_path = None
    for ext in (".xml", ".md"):
        candidate = context_dir / f"ctx.{file_type}{ext}"
        if candidate.exists():
            file_path = candidate
            break
    if not file_path:
        print_table(
            ["Error"],
            [[f"File does not exist: {file_type}"]],
            title="Context Edit Failed",
        )
        raise typer.Exit(1)
    editor_cmd = editor or os.environ.get("EDITOR", "nano")
    os.system(f"{editor_cmd} {file_path}")
    print_table(
        ["Info"],
        [[f"Edited {file_type} in context: {name}"]],
        title="Context Edited",
    )
    raise typer.Exit(0)


@context_app.command()
def store():
    """Store the current context by reading the architecture file, parsing the title,
    sanitizing it, and saving the current context files to a new folder.

    This command will:
    1. Read the current architecture file
    2. Extract the title from it
    3. Create a new context folder with the sanitized title
    4. Copy the current architecture, progress, and tasks files to the new folder
    """
    try:
        context_name = context_manager.store_context()
        print_table(
            ["Info"],
            [[f"Successfully stored context as: {context_name}"]],
            title="Context Stored",
        )
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Store Failed")
        show_context_help_and_exit()


@context_app.command("load")
def load_context(name: str = typer.Argument(None, help="Name of the context to load")):
    """Load a stored context by name into the root .ctx XML files.

    If no name is supplied, you will be prompted to select one interactively.
    """
    try:
        if not name:
            # List available contexts and prompt for selection
            contexts = context_manager.list_contexts()
            if not contexts:
                print_table(["Info"], [["No contexts found"]], title="Available Contexts")
                raise typer.Exit(1)
            context_rows = [
                [str(index + 1), context_name] for index, context_name in enumerate(contexts)
            ]
            print_table(["#", "Context Name"], context_rows, title="Available Contexts")
            choice = typer.prompt("Select a context by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(contexts):
                    selected = contexts[index - 1]
            else:
                if choice in contexts:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Context Load Failed",
                )
                raise typer.Exit(1)
            name = selected
        context_manager.load_context(name)
        print_table(["Info"], [[f"Loaded context: {name}"]], title="Context Loaded")
        raise typer.Exit(0)
    except ContextError as error:
        print_table(["Error"], [[str(error)]], title="Context Load Failed")
        raise typer.Exit(1)


@context_app.command("select")
def select_context():
    """Interactively select a context and load its XML files."""
    base_dir = context_manager.base_path
    # Gather available contexts
    try:
        contexts = sorted(
            [
                context_directory.name
                for context_directory in base_dir.iterdir()
                if context_directory.is_dir()
            ]
        )
    except Exception as exception:
        typer.echo(f"Error: Unable to list contexts: {exception}")
        raise typer.Exit(1)
    if not contexts:
        typer.echo("No contexts found to select.")
        raise typer.Exit(1)
    # Display contexts in a table
    context_rows = [[str(index + 1), context_name] for index, context_name in enumerate(contexts)]
    print_table(["#", "Context Name"], context_rows, title="Available Contexts")
    choice = typer.prompt("Select a context by number or name")
    # Determine selected context name
    selected = None
    if choice.isdigit():
        index = int(choice)
        if 1 <= index <= len(contexts):
            selected = contexts[index - 1]
    else:
        if choice in contexts:
            selected = choice
    if not selected:
        typer.echo(f"Error: Invalid selection: {choice}")
        raise typer.Exit(1)
    # Load the selected context
    try:
        context_manager.load_context(selected)
        typer.echo(f"Loaded context: {selected}")
        raise typer.Exit(0)
    except ContextError as exception:
        typer.echo(f"Error: Failed to load context: {exception}")
        raise typer.Exit(1)


get_context = get_context
show_context_help_and_exit = show_context_help_and_exit
context_callback = context_callback
create = create
delete = delete
list = list
preview = preview
show = show
update = update
cat = cat
edit = edit
store = store
load_context = load_context
select_context = select_context

# protocol_commands.py
import typer
from pathlib import Path
from loguru import logger

import os
import re

protocol_manager = ProtocolManager()
protocol_app = typer.Typer(help="Manage development protocols.")


def show_protocol_help_and_exit():
    """Show help menu and exit with error code."""
    command_rows = [
        ["erasmus protocol list", "List all protocols"],
        ["erasmus protocol create", "Create a new protocol"],
        ["erasmus protocol show", "Show protocol details"],
        ["erasmus protocol update", "Update a protocol"],
        ["erasmus protocol edit", "Edit a protocol"],
        ["erasmus protocol delete", "Delete a protocol"],
        ["erasmus protocol select", "Select and display a protocol"],
        ["erasmus protocol load", "Load a protocol as active"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Protocol Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus protocol <command> --help")
    raise typer.Exit(1)


@protocol_app.callback(invoke_without_command=True)
def protocol_callback(ctx: typer.Context):
    """
    Manage development protocols.
    """
    if ctx.invoked_subcommand is None:
        command_rows = [
            ["erasmus protocol list", "List all protocols"],
            ["erasmus protocol create", "Create a new protocol"],
            ["erasmus protocol show", "Show protocol details"],
            ["erasmus protocol update", "Update a protocol"],
            ["erasmus protocol edit", "Edit a protocol"],
            ["erasmus protocol delete", "Delete a protocol"],
            ["erasmus protocol select", "Select and display a protocol"],
            ["erasmus protocol load", "Load a protocol as active"],
        ]
        print_table(
            ["Command", "Description"],
            command_rows,
            title="Available Protocol Commands",
        )
        typer.echo("\nFor more information about a command, run:")
        typer.echo("  erasmus protocol <command> --help")
        raise typer.Exit(0)


@protocol_app.command()
def create(
    name: str = typer.Argument(None, help="Name of the protocol to create"),
    content: str = typer.Argument(None, help="Content of the protocol"),
):
    """Create a new protocol.

    This command creates a new protocol file with optional content.
    The protocol name will be sanitized to ensure it's safe for filesystem operations.
    """
    try:
        if not name:
            name = typer.prompt("Enter the protocol name")
        if not name:
            print_table(
                ["Error"],
                [["Protocol name is required."]],
                title="Protocol Creation Failed",
            )
            raise typer.Exit(1)
        if content is None:
            content = typer.prompt("Enter the protocol content (leave blank to use template)")
        protocol_manager.create_protocol(name, content)
        logger.info(f"Created protocol: {name}")
        print_table(["Info"], [[f"Created protocol: {name}"]], title="Protocol Created")
        raise typer.Exit(0)
    except ProtocolError as e:
        logger.error(f"Failed to create protocol: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def update(
    name: str = typer.Argument(None, help="Name of the protocol to update"),
    content: str = typer.Argument(None, help="New content for the protocol"),
):
    """Update an existing protocol.

    This command updates the content of an existing protocol.
    The protocol must exist before it can be updated.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Update Failed",
                )
                raise typer.Exit(1)
            name = selected
        if content is None:
            content = typer.prompt("Enter the new protocol content")
        if not content:
            print_table(
                ["Error"],
                [["Protocol content is required."]],
                title="Protocol Update Failed",
            )
            raise typer.Exit(1)
        protocol_manager.update_protocol(name, content)
        logger.info(f"Updated protocol: {name}")
        print_table(["Info"], [[f"Updated protocol: {name}"]], title="Protocol Updated")
        raise typer.Exit(0)
    except ProtocolError as e:
        logger.error(f"Failed to update protocol: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def delete(name: str = typer.Argument(None, help="Name of the protocol to delete")):
    """Delete a protocol.

    This command permanently removes a protocol file.
    Use with caution as this action cannot be undone.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Deletion Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol_manager.delete_protocol(name)
        logger.info(f"Deleted protocol: {name}")
        print_table(["Info"], [[f"Deleted protocol: {name}"]], title="Protocol Deleted")
        raise typer.Exit(0)
    except (ProtocolError, PermissionError, FileNotFoundError) as e:
        print_table(["Error"], [[str(e)]], title="Protocol Deletion Failed")
        raise typer.Exit(1)


@protocol_app.command()
def list():
    """List all protocols.

    This command shows all available protocols and their basic information.
    Use 'show' to view detailed information about a specific protocol.
    """
    try:
        protocols = protocol_manager.list_protocols()
        if not protocols:
            typer.echo("No protocols found")
            return

        # Display protocols in a table
        protocol_rows = [[protocol] for protocol in protocols]
        print_table(["Protocol Name"], protocol_rows, title="Available Protocols")
    except ProtocolError as e:
        logger.error(f"Failed to list protocols: {e}")
        show_protocol_help_and_exit()


@protocol_app.command()
def show(name: str = typer.Argument(None, help="Name of the protocol to show")):
    """Show details of a protocol.

    This command displays detailed information about a specific protocol,
    including its content and metadata.
    """
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Show Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Show Failed",
            )
            raise typer.Exit(1)
        print_table(["Info"], [[f"Protocol: {name}"]], title="Protocol Details")
        typer.echo(f"Path: {protocol.path}")
        typer.echo(f"Content:\n{protocol.content}")
        raise typer.Exit(0)
    except ProtocolError as e:
        print_table(["Error"], [[str(e)]], title="Protocol Show Failed")
        raise typer.Exit(1)


@protocol_app.command("select")
def select_protocol():
    """Interactively select a protocol, display its details, and update the rules file with it."""
    try:
        protocols = protocol_manager.list_protocols()
        if not protocols:
            print_table(["Info"], [["No protocols found"]], title="Available Protocols")
            raise typer.Exit(1)
        protocol_rows = [
            [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
        ]
        print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            index = int(choice)
            if 1 <= index <= len(protocols):
                selected = protocols[index - 1]
        else:
            if choice in protocols:
                selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        protocol = protocol_manager.get_protocol(selected)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {selected}"]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        print_table(["Info"], [[f"Selected protocol: {selected}"]], title="Protocol Selected")
        typer.echo(f"Path: {protocol.path}")
        typer.echo(f"Content:\n{protocol.content}")
        # Write the selected protocol name to .erasmus/current_protocol.txt

        path_manager = get_path_manager()
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        current_protocol_path.write_text(selected)
        # Also update the rules file as in load
        template_path = path_manager.template_dir / "meta_rules.xml"
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.xml template not found."]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        meta_rules_content = template_path.read_text()
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        meta_rules_content = meta_rules_content.replace(
            "<!--ARCHITECTURE-->\n  <!--/ARCHITECTURE-->", architecture
        )
        meta_rules_content = meta_rules_content.replace(
            "<!--PROGRESS-->\n  <!--/PROGRESS-->", progress
        )
        meta_rules_content = meta_rules_content.replace("<!--TASKS-->\n  <!--/TASKS-->", tasks)
        meta_rules_content = meta_rules_content.replace(
            "<!--PROTOCOL-->\n  <!--/PROTOCOL-->", protocol.content
        )
        rules_file = path_manager.get_rules_file()
        if not rules_file:
            print_table(
                ["Error"],
                [["No rules file configured."]],
                title="Protocol Select Failed",
            )
            raise typer.Exit(1)
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Updated rules file with protocol: {selected}"]],
            title="Rules File Updated",
        )
        raise typer.Exit(0)
    except ProtocolError as exception:
        print_table(["Error"], [[str(exception)]], title="Protocol Select Failed")
        raise typer.Exit(1)


@protocol_app.command("load")
def load_protocol(
    name: str = typer.Argument(None, help="Name of the protocol to load"),
):
    """Interactively select and load a protocol, merging it into the rules file with current context."""
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Load Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Load Failed",
            )
            raise typer.Exit(1)
        # Write the selected protocol name to .erasmus/current_protocol.txt

        path_manager = get_path_manager()
        current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"
        current_protocol_path.write_text(name)
        # Load meta_rules.xml template
        template_path = path_manager.template_dir / "meta_rules.xml"
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.xml template not found."]],
                title="Protocol Load Failed",
            )
            raise typer.Exit(1)
        meta_rules_content = template_path.read_text()
        # Read current context files
        architecture = (
            path_manager.get_architecture_file().read_text()
            if path_manager.get_architecture_file().exists()
            else ""
        )
        progress = (
            path_manager.get_progress_file().read_text()
            if path_manager.get_progress_file().exists()
            else ""
        )
        tasks = (
            path_manager.get_tasks_file().read_text()
            if path_manager.get_tasks_file().exists()
            else ""
        )
        # Replace context and protocol blocks using regex for robustness
        meta_rules_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            meta_rules_content,
        )
        meta_rules_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, meta_rules_content
        )
        meta_rules_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, meta_rules_content)
        meta_rules_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->",
            protocol.content,
            meta_rules_content,
        )
        # Write to rules file
        rules_file = path_manager.get_rules_file()
        if not rules_file:
            print_table(["Error"], [["No rules file configured."]], title="Protocol Load Failed")
            raise typer.Exit(1)
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Loaded protocol: {name} into rules file"]],
            title="Protocol Loaded",
        )
        raise typer.Exit(0)
    except ProtocolError as exception:
        print_table(["Error"], [[str(exception)]], title="Protocol Load Failed")
        raise typer.Exit(1)


@protocol_app.command()
def edit(
    name: str = typer.Argument(None, help="Name of the protocol to edit"),
    editor: str = typer.Argument(None, help="Editor to use for editing"),
):
    """Edit a protocol file in your default editor (or specified editor)."""
    try:
        if not name:
            protocols = protocol_manager.list_protocols()
            if not protocols:
                print_table(["Info"], [["No protocols found"]], title="Available Protocols")
                raise typer.Exit(1)
            protocol_rows = [
                [str(index + 1), protocol_name] for index, protocol_name in enumerate(protocols)
            ]
            print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
            choice = typer.prompt("Select a protocol by number or name")
            selected = None
            if choice.isdigit():
                index = int(choice)
                if 1 <= index <= len(protocols):
                    selected = protocols[index - 1]
            else:
                if choice in protocols:
                    selected = choice
            if not selected:
                print_table(
                    ["Error"],
                    [[f"Invalid selection: {choice}"]],
                    title="Protocol Edit Failed",
                )
                raise typer.Exit(1)
            name = selected
        protocol = protocol_manager.get_protocol(name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {name}"]],
                title="Protocol Edit Failed",
            )
            raise typer.Exit(1)
        file_path = protocol.path
        editor_cmd = editor or os.environ.get("EDITOR", "nano")
        os.system(f"{editor_cmd} {file_path}")
        print_table(["Info"], [[f"Edited protocol: {name}"]], title="Protocol Edited")
        raise typer.Exit(0)
    except ProtocolError as error:
        print_table(["Error"], [[str(error)]], title="Protocol Edit Failed")
        raise typer.Exit(1)


@protocol_app.command("watch")
def watch_protocol():
    """Monitor .ctx.*.xml files for changes and update the rules file with the current protocol. Does NOT monitor the rules file itself."""
    import time

    path_manager = get_path_manager()
    protocol_manager = ProtocolManager()
    ctx_files = [
        path_manager.get_architecture_file(),
        path_manager.get_progress_file(),
        path_manager.get_tasks_file(),
    ]
    template_path = path_manager.template_dir / "meta_rules.xml"
    rules_file = path_manager.get_rules_file()
    current_protocol_path = Path(path_manager.erasmus_dir) / "current_protocol.txt"

    def get_protocol_name():
        if current_protocol_path.exists():
            return current_protocol_path.read_text().strip()
        protocols = protocol_manager.list_protocols()
        if not protocols:
            print_table(["Error"], [["No protocols found."]], title="Protocol Watch Failed")
            raise typer.Exit(1)
        protocol_rows = [[str(i + 1), p] for i, p in enumerate(protocols)]
        print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            idx = int(choice)
            if 1 <= idx <= len(protocols):
                selected = protocols[idx - 1]
        elif choice in protocols:
            selected = choice
        if not selected:
            print_table(
                ["Error"],
                [[f"Invalid selection: {choice}"]],
                title="Protocol Watch Failed",
            )
            raise typer.Exit(1)
        current_protocol_path.write_text(selected)
        return selected

    def merge_and_write():
        if not template_path.exists():
            print_table(
                ["Error"],
                [["meta_rules.xml template not found."]],
                title="Protocol Watch Failed",
            )
            return
        meta_rules_content = template_path.read_text()
        architecture = ctx_files[0].read_text() if ctx_files[0].exists() else ""
        progress = ctx_files[1].read_text() if ctx_files[1].exists() else ""
        tasks = ctx_files[2].read_text() if ctx_files[2].exists() else ""
        meta_rules_content = re.sub(
            r"<!--ARCHITECTURE-->[\s\S]*?<!--/ARCHITECTURE-->",
            architecture,
            meta_rules_content,
        )
        meta_rules_content = re.sub(
            r"<!--PROGRESS-->[\s\S]*?<!--/PROGRESS-->", progress, meta_rules_content
        )
        meta_rules_content = re.sub(r"<!--TASKS-->[\s\S]*?<!--/TASKS-->", tasks, meta_rules_content)
        protocol_name = get_protocol_name()
        protocol = protocol_manager.get_protocol(protocol_name)
        if not protocol:
            print_table(
                ["Error"],
                [[f"Protocol not found: {protocol_name}"]],
                title="Protocol Watch Failed",
            )
            return
        meta_rules_content = re.sub(
            r"<!--PROTOCOL-->[\s\S]*?<!--/PROTOCOL-->",
            protocol.content,
            meta_rules_content,
        )
        if not rules_file:
            print_table(
                ["Error"],
                [["No rules file configured."]],
                title="Protocol Watch Failed",
            )
            return
        rules_file.write_text(meta_rules_content)
        print_table(
            ["Info"],
            [[f"Rules file updated with protocol: {protocol_name}"]],
            title="Rules File Updated",
        )

    # Track last modification times for only the .ctx.*.xml files
    last_mtimes = [f.stat().st_mtime if f.exists() else 0 for f in ctx_files]
    print_table(["Info"], [["Watching .ctx.*.xml files for changes..."]], title="Protocol Watch")
    try:
        while True:
            changed = False
            for i, f in enumerate(ctx_files):
                if f.exists():
                    mtime = f.stat().st_mtime
                    if mtime != last_mtimes[i]:
                        changed = True
                        last_mtimes[i] = mtime
            if changed:
                merge_and_write()
            time.sleep(1)
    except KeyboardInterrupt:
        print_table(["Info"], [["Stopped watching context files."]], title="Protocol Watch")


show_protocol_help_and_exit = show_protocol_help_and_exit
protocol_callback = protocol_callback
create = create
update = update
delete = delete
list = list
show = show
select_protocol = select_protocol
load_protocol = load_protocol
edit = edit
watch_protocol = watch_protocol

# setup_commands.py
import typer
from pathlib import Path


setup_app = typer.Typer(help="Setup Erasmus: initialize project, environment, and context.")


@setup_app.callback(invoke_without_command=True)
def setup_callback(ctx: typer.Context):
    if ctx.invoked_subcommand is not None:
        return
    """Interactive setup for Erasmus: configure IDE, project, context, and protocol."""
    # Step 1: Use path manager for IDE detection and prompting
    path_manager = get_path_manager()
    print_table(["Info"], [[f"IDE detected: {path_manager.ide.name}"]], title="Setup")

    # Step 2: Prompt for project name
    project_name = typer.prompt("Enter the project name")
    if not project_name:
        print_table(["Error"], [["Project name is required."]], title="Setup Failed")
        raise typer.Exit(1)

    # Step 3: Create project directory and context using path manager
    project_dir = Path.cwd() / project_name
    project_dir.mkdir(parents=True, exist_ok=True)
    print_table(["Info"], [[f"Project directory created: {project_dir}"]], title="Setup")

    # Step 4: Use path manager for all Erasmus folders inside project
    erasmus_dir = path_manager.erasmus_dir
    context_dir = path_manager.context_dir
    protocol_dir = path_manager.protocol_dir
    template_dir = path_manager.template_dir
    for d in [erasmus_dir, context_dir, protocol_dir, template_dir]:
        d.mkdir(parents=True, exist_ok=True)
    print_table(["Info"], [[f"Erasmus folders created in: {erasmus_dir}"]], title="Setup")

    # Step 5: Create a template context in the context folder and update root .ctx.*.xml files
    context_manager = ContextManager(base_dir=str(context_dir))
    context_manager.create_context(project_name)
    print_table(["Info"], [[f"Template context created: {project_name}"]], title="Setup")
    # Load the new context to root .ctx.*.xml files
    context_manager.load_context(project_name)
    print_table(
        ["Info"],
        [[f"Root .ctx.*.xml files updated for: {project_name}"]],
        title="Setup",
    )

    # Step 6: Prompt for protocol selection
    protocol_manager = ProtocolManager()
    protocols = protocol_manager.list_protocols()
    if not protocols:
        print_table(["Error"], [["No protocols found."]], title="Setup Failed")
        raise typer.Exit(1)
    protocol_rows = [[str(i + 1), p] for i, p in enumerate(protocols)]
    print_table(["#", "Protocol Name"], protocol_rows, title="Available Protocols")
    while True:
        choice = typer.prompt("Select a protocol by number or name")
        selected = None
        if choice.isdigit():
            idx = int(choice)
            if 1 <= idx <= len(protocols):
                selected = protocols[idx - 1]
        elif choice in protocols:
            selected = choice
        if selected:
            # Write the selected protocol to current_protocol.txt using path manager
            current_protocol_path = path_manager.erasmus_dir / "current_protocol.txt"
            current_protocol_path.write_text(selected)
            print_table(["Info"], [[f"Protocol set to: {selected}"]], title="Setup")
            # Immediately update the rules file to reflect the selected protocol
            try:
                _merge_rules_file()
                print_table(
                    ["Info"],
                    [[f"Rules file updated with protocol: {selected}"]],
                    title="Setup",
                )
            except Exception as e:
                print_table(
                    ["Error"],
                    [[f"Failed to update rules file: {e}"]],
                    title="Setup Warning",
                )
            break
        print(f"Invalid selection: {choice}")

    print_table(
        ["Info"],
        [
            [
                "Erasmus setup complete. Ask the AI to help you generate an architecture documetn to start"
            ]
        ],
        ["Basic commands to get you started:"],
        [
            ["erasmus context store", "Store your new context"],
            ["erasmus context select", "Select a context"],
            ["erasmus protocol list", "List available protocols"],
            ["erasmus protocol select", "Select a protocol"],
            ["erasmus setup", "Setup Erasmus"],
        ],
        title="Setup Success",
    )
    raise typer.Exit(0)


setup_callback = setup_callback

# main.py
import typer


app = typer.Typer(
    help="Erasmus - Development Context Management System\n\nA tool for managing development contexts, protocols, and Model Context Protocol (MCP) interactions.\n\nFor more information, visit: https://github.com/hydra-dynamics/erasmus"
)

# Add sub-commands
app.add_typer(context_app, name="context", help="Manage development contexts")
app.add_typer(protocol_app, name="protocol", help="Manage protocols")
app.add_typer(setup_app, name="setup", help="Setup Erasmus")


# Custom error handler for unknown commands and argument errors
def print_main_help_and_exit():
    try:
        from rich.console import Console

        console = Console()
        banner = [
            ("green", " _____                                  "),
            ("green", "|  ___|                                 "),
            ("cyan", "| |__ _ __ __ _ ___ _ __ ___  _   _ ___ "),
            ("green", "|  __| '__/ _` / __| '_ ` _ \\| | | / __|"),
            ("cyan", "| |__| | | (_| \\__ \\ | | | | | |_| \\__ \\"),
            ("green", "\\____/_|  \\__,_|___/_| |_| |_|\\__,_|___/"),
        ]
        for color, line in banner:
            console.print(line, style=color)
    except ImportError:
        # Fallback to plain text if rich is not available
        typer.echo(r"""
 _____                                  
|  ___|                                 
| |__ _ __ __ _ ___ _ __ ___  _   _ ___ 
|  __| '__/ _` / __| '_ ` _ \| | | / __|
| |__| | | (_| \__ \ | | | | | |_| \__ \
\____/_|  \__,_|___/_| |_| |_|\__,_|___/
""")
    typer.echo("\nErasmus - Development Context Management System")
    command_rows = [
        ["erasmus context", "Manage development contexts"],
        ["erasmus protocol", "Manage protocols"],
        ["erasmus setup", "Setup Erasmus"],
        ["erasmus watch", "Watch for .ctx file changes"],
        ["erasmus status", "Show current status"],
        ["erasmus version", "Show Erasmus version"],
    ]
    print_table(["Command", "Description"], command_rows, title="Available Erasmus Commands")
    typer.echo("\nFor more information about a command, run:")
    typer.echo("  erasmus <command> --help")
    raise typer.Exit(1)


@app.callback(invoke_without_command=True)
def main(ctx: typer.Context):
    """
    Erasmus - Development Context Management System
    """
    if ctx.invoked_subcommand is None:
        print_main_help_and_exit()


# Patch Typer's error handling to show help on unknown command
from typer.main import get_command
from typer.core import TyperGroup
from click import UsageError

original_command = get_command(app)


class HelpOnErrorGroup(TyperGroup):
    def main(self, *args, **kwargs):
        try:
            return super().main(*args, **kwargs)
        except UsageError as e:
            typer.echo(str(e))
            print_main_help_and_exit()


app.command_class = HelpOnErrorGroup


@app.command()
def watch():  # pragma: no cover
    """Watch for changes to .ctx files and update the IDE rules file automatically.

    Press Ctrl+C to stop watching.
    """
    import time

    pm = get_path_manager()
    root = pm.get_root_dir()
    monitor = FileMonitor(str(root))
    monitor.start()
    typer.echo(f"Watching {root} for .ctx file changes (Ctrl+C to stop)...")
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        monitor.stop()
        typer.echo("Stopped watching.")


@app.command()
def status():
    """Show the current Erasmus context and protocol status."""

    import os

    context_manager = ContextManager()
    protocol_manager = ProtocolManager()

    # Current context (from .erasmus/current_context.txt if exists)
    current_context = None
    current_context_path = os.path.join(context_manager.base_dir.parent, "current_context.txt")
    if os.path.exists(current_context_path):
        with open(current_context_path) as f:
            current_context = f.read().strip()

    # List all contexts
    try:
        contexts = context_manager.list_contexts()
    except Exception as e:
        contexts = []

    # List all protocols
    try:
        protocols = protocol_manager.list_protocols()
    except Exception as e:
        protocols = []

    print_table(
        ["Status", "Value"],
        [
            ["Current Context", current_context or "(none set)"],
            ["Available Contexts", ", ".join(contexts) if contexts else "(none)"],
            ["Available Protocols", ", ".join(protocols) if protocols else "(none)"],
        ],
        title="Erasmus Status",
    )


@app.command()
def version():
    """Show the Erasmus version."""

    typer.echo(f"Erasmus version: {erasmus.__version__}")


if __name__ == "__main__":
    app()
